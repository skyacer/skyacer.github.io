<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>SkyAcer&#39;s blog</title>
  <icon>https://www.gravatar.com/avatar/ab1bde2e4262f68c89b5a9c5c5424696</icon>
  <subtitle>Hacking,Thoughts.</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://skyacer.github.io/"/>
  <updated>2018-09-06T09:43:29.000Z</updated>
  <id>http://skyacer.github.io/</id>
  
  <author>
    <name>SkyAcer</name>
    <email>skyacer.me@gmail.com</email>
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Android动态权限管理原理（6.0及以上）</title>
    <link href="http://skyacer.github.io/2018/09/06/Android%E5%8A%A8%E6%80%81%E6%9D%83%E9%99%90%E7%AE%A1%E7%90%86%E5%8E%9F%E7%90%86%EF%BC%886-0%E5%8F%8A%E4%BB%A5%E4%B8%8A%EF%BC%89/"/>
    <id>http://skyacer.github.io/2018/09/06/Android动态权限管理原理（6-0及以上）/</id>
    <published>2018-09-06T09:39:16.000Z</published>
    <updated>2018-09-06T09:43:29.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Android动态权限管理原理（6-0及以上）"><a href="#Android动态权限管理原理（6-0及以上）" class="headerlink" title="Android动态权限管理原理（6.0及以上）"></a>Android动态权限管理原理（6.0及以上）</h1><blockquote><p>在6.0之前，所有权限都是在安装时候授予的，在6.0之后，允许用户动态控制权限。<br>国内手机厂商却将Google隐藏的权限管理用了起来，本文主要涉及一下几个部分内容：</p><ul><li>Android6.0之前的动态权限管理模型及原理-AppOpsManager（这个不做具体分析，了解即可，毕竟已经弃用）</li><li>Android6.0及之后的动态权限管理原理-runtime permission</li><li>两种权限的特点与区别</li></ul></blockquote><h2 id="Android-6-0权限管理原理"><a href="#Android-6-0权限管理原理" class="headerlink" title="Android 6.0权限管理原理"></a>Android 6.0权限管理原理</h2><p>从Android6.0开始，原生支持runtime-permission机制，用户在任何时候都可以授权/取消授权，并且APP能够在请求服务之前知道<strong>是否已经获得所需要的权限。</strong></p><p>工具类PermissionChecker，可以用来检查权限获取情况。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public static int checkPermission(@NonNull Context context, @NonNull String permission,</span><br><span class="line">        int pid, int uid, String packageName) &#123;</span><br><span class="line">    &lt;!--关键点1 --&gt;</span><br><span class="line">    if (context.checkPermission(permission, pid, uid) == PackageManager.PERMISSION_DENIED) &#123;</span><br><span class="line">        return PERMISSION_DENIED;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">    return PERMISSION_GRANTED;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最终会通过ActivityManagerNative将请求发送给AMS</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public static int checkPermission(@NonNull Context context, @NonNull String permission,</span><br><span class="line">        int pid, int uid, String packageName) &#123;</span><br><span class="line">    &lt;!--关键点1 --&gt;</span><br><span class="line">    if (context.checkPermission(permission, pid, uid) == PackageManager.PERMISSION_DENIED) &#123;</span><br><span class="line">        return PERMISSION_DENIED;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">    return PERMISSION_GRANTED;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>AMS端对应的处理是：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">int checkComponentPermission(String permission, int pid, int uid,</span><br><span class="line">        int owningUid, boolean exported) &#123;</span><br><span class="line">    if (pid == MY_PID) &#123;</span><br><span class="line">        return PackageManager.PERMISSION_GRANTED;</span><br><span class="line">    &#125;</span><br><span class="line">    return ActivityManager.checkComponentPermission(permission, uid,</span><br><span class="line">            owningUid, exported);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>进而调用ActivityManager.checkComponentPermission,调用AppGlobals.getPackageManager().checkUidPermission(permission, uid)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">/** @hide */</span><br><span class="line">public static int checkComponentPermission(String permission, int uid,</span><br><span class="line">        int owningUid, boolean exported) &#123;</span><br><span class="line">    </span><br><span class="line">    &lt;!--root及System进程能获取所有权限--&gt;</span><br><span class="line">    if (uid == 0 || uid == Process.SYSTEM_UID) &#123;</span><br><span class="line">        return PackageManager.PERMISSION_GRANTED;</span><br><span class="line">    &#125;</span><br><span class="line">。。。</span><br><span class="line">    &lt;!--普通应用的权限查询--&gt;</span><br><span class="line">    try &#123;</span><br><span class="line">        return AppGlobals.getPackageManager()</span><br><span class="line">                .checkUidPermission(permission, uid);</span><br><span class="line">    &#125; catch (RemoteException e) &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    return PackageManager.PERMISSION_DENIED;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最终调用PackageManagerService.java去查看是否有某种权限，到这里，只需要关心权限的查询其实是通过PKMS来进行的，后面还会看到权限的更新，持久化，恢复也是通过PKMS来进行的。checkUidPermission在不同的版本都是支持的，只不过Android6.0的实现跟之前的版本有很大不同，看一下6.0之前的， Android5.0的checkUidPermission：主要是通过Setting获取当前APP的权限列表，对于6.0之前的APP，这些权限都是静态申请的，或者说只要在Menifest文件中声明了，这里就认为是申请了。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">//6.0之前的</span><br><span class="line">public int checkUidPermission(String permName, int uid) &#123;</span><br><span class="line">        final boolean enforcedDefault = isPermissionEnforcedDefault(permName);</span><br><span class="line">        synchronized (mPackages) &#123;</span><br><span class="line">        &lt;!--PackageManagerService.Setting.mUserIds数组中，根据uid查找uid（也就是package）的权限列表--&gt;</span><br><span class="line">            Object obj = mSettings.getUserIdLPr(UserHandle.getAppId(uid));</span><br><span class="line">            if (obj != null) &#123;</span><br><span class="line">            &lt;!--关键点1 --&gt;</span><br><span class="line">                GrantedPermissions gp = (GrantedPermissions)obj;</span><br><span class="line">                if (gp.grantedPermissions.contains(permName)) &#123;</span><br><span class="line">                    return PackageManager.PERMISSION_GRANTED;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; </span><br><span class="line">            ...</span><br><span class="line">        return PackageManager.PERMISSION_DENIED;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>GrantedPermissions是一个APP所对应权限的集合，内部有一个权限列表 HashSet grantedPermissions = new HashSet()，只要权限在Menifest中申请了，该列表中就会包含其对应的字符串，完全是静态的。但是6.0的runtime-permmison就不同了，Android6.0+的checkUidPermission.</p><p><strong>这也是为什么Android6.0之后改成动态获取权限的原因。</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">//6.0之后的</span><br><span class="line">@Override</span><br><span class="line">    public int checkUidPermission(String permName, int uid) &#123;</span><br><span class="line">        final int userId = UserHandle.getUserId(uid);</span><br><span class="line">...</span><br><span class="line">        synchronized (mPackages) &#123;</span><br><span class="line">            Object obj = mSettings.getUserIdLPr(UserHandle.getAppId(uid));</span><br><span class="line">            if (obj != null) &#123;</span><br><span class="line">                final SettingBase ps = (SettingBase) obj;</span><br><span class="line">                final PermissionsState permissionsState = ps.getPermissionsState();</span><br><span class="line">                if (permissionsState.hasPermission(permName, userId)) &#123;</span><br><span class="line">                    return PackageManager.PERMISSION_GRANTED;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; </span><br><span class="line">            ...</span><br><span class="line">        &#125;</span><br><span class="line">        return PackageManager.PERMISSION_DENIED;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>hasPermission如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public boolean hasPermission(String name, int userId) &#123;</span><br><span class="line">    enforceValidUserId(userId);</span><br><span class="line"></span><br><span class="line">    if (mPermissions == null) &#123;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line">    PermissionData permissionData = mPermissions.get(name);</span><br><span class="line">    return permissionData != null &amp;&amp; permissionData.isGranted(userId);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>动态权限申请如下：</p><p><img src="https://note.youdao.com/yws/api/personal/file/WEB915885c4d793c69b0ce753c1eef72030?method=download&amp;shareKey=e561995c1cceb4b98b10991ce4fd7621" alt=""></p><h2 id="动态申请权限"><a href="#动态申请权限" class="headerlink" title="动态申请权限"></a>动态申请权限</h2><p>Android 6.0动态申请权限通过ActivityCompat来进行</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">public static void requestPermissions(final @NonNull Activity activity,</span><br><span class="line">           final @NonNull String[] permissions, final int requestCode) &#123;</span><br><span class="line">       if (Build.VERSION.SDK_INT &gt;= 23) &#123;</span><br><span class="line">       //大于6.0</span><br><span class="line">           ActivityCompatApi23.requestPermissions(activity, permissions, requestCode);</span><br><span class="line">       &#125; else if (activity instanceof OnRequestPermissionsResultCallback) &#123;</span><br><span class="line">       //小于6.0</span><br><span class="line">           Handler handler = new Handler(Looper.getMainLooper());</span><br><span class="line">           handler.post(new Runnable() &#123;</span><br><span class="line">               @Override</span><br><span class="line">               public void run() &#123;</span><br><span class="line">                   final int[] grantResults = new int[permissions.length];</span><br><span class="line"></span><br><span class="line">                   PackageManager packageManager = activity.getPackageManager();</span><br><span class="line">                   String packageName = activity.getPackageName();</span><br><span class="line"></span><br><span class="line">                   final int permissionCount = permissions.length;</span><br><span class="line">                   for (int i = 0; i &lt; permissionCount; i++) &#123;</span><br><span class="line">                       grantResults[i] = packageManager.checkPermission(</span><br><span class="line">                               permissions[i], packageName);</span><br><span class="line">                   &#125;</span><br><span class="line"></span><br><span class="line">                   ((OnRequestPermissionsResultCallback) activity).onRequestPermissionsResult(</span><br><span class="line">                           requestCode, permissions, grantResults);</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;);</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>如果是6.0以下，直接通过ActivityCompatPKMS查询是否在Manifest中申请权限，如果申请了就默认具备该权限，并将onRequestPermissionResult将结果回传给Activity或者Fragment。</p><p>对于6.0以上，则会通过activity.requestPermission去申请权限。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public final void requestPermissions(@NonNull String[] permissions, int requestCode) &#123;</span><br><span class="line">    Intent intent = getPackageManager().buildRequestPermissionsIntent(permissions);</span><br><span class="line">    startActivityForResult(REQUEST_PERMISSIONS_WHO_PREFIX, intent, requestCode, null);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里的intent其实是PackageManager（ApplicationPackageManager实现类）获取的intent</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">    public Intent buildRequestPermissionsIntent(@NonNull String[] permissions) &#123;</span><br><span class="line">    Intent intent = new Intent(ACTION_REQUEST_PERMISSIONS);</span><br><span class="line">    intent.putExtra(EXTRA_REQUEST_PERMISSIONS_NAMES, permissions);</span><br><span class="line">    intent.setPackage(getPermissionControllerPackageName());</span><br><span class="line">    return intent;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面函数主要是为了获取悬浮授权的Activity组件信息，GrantPermissionsActivity样式，类似于对话框：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;activity android:name=&quot;.permission.ui.GrantPermissionsActivity&quot;</span><br><span class="line">            android:configChanges=&quot;orientation|keyboardHidden|screenSize&quot;</span><br><span class="line">            android:excludeFromRecents=&quot;true&quot;</span><br><span class="line">            android:theme=&quot;@style/GrantPermissions&quot;&gt;</span><br><span class="line">        &lt;intent-filter&gt;</span><br><span class="line">            &lt;action android:name=&quot;android.content.pm.action.REQUEST_PERMISSIONS&quot; /&gt;</span><br><span class="line">            &lt;category android:name=&quot;android.intent.category.DEFAULT&quot; /&gt;</span><br><span class="line">        &lt;/intent-filter&gt;</span><br><span class="line">    &lt;/activity&gt;</span><br></pre></td></tr></table></figure><p>这是一个类似于对话框的悬浮窗样式Activity</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;style name=&quot;GrantPermissions&quot; parent&quot;Settings&quot;&gt;</span><br><span class="line"> &lt;item name=&quot;android:windowIsFloating&quot;&gt;true&lt;/item&gt;</span><br><span class="line">    &lt;item name=&quot;android:windowElevation&quot;&gt;@dimen/action_dialog_z&lt;/item&gt;</span><br><span class="line">    &lt;item name=&quot;android:windowSwipeToDismiss&quot;&gt;false&lt;/item&gt;</span><br><span class="line">&lt;/style&gt;</span><br></pre></td></tr></table></figure><h3 id="6-0之前，权限申请（未在release版本发布）是同步的，会阻塞UI线程"><a href="#6-0之前，权限申请（未在release版本发布）是同步的，会阻塞UI线程" class="headerlink" title="6.0之前，权限申请（未在release版本发布）是同步的，会阻塞UI线程"></a>6.0之前，权限申请（未在release版本发布）是同步的，会阻塞UI线程</h3><p>在国产ROM中，申请权限的线程会被阻塞（即使是UI线程），这是因为鉴权的Binder通信是同步的，并且，服务端一直等到用户操作后才将结果返回给客户端，这就导致了客户端请求线程一直阻塞，直到用户操作结束。askOperationLocked通过mHandler发送鉴权Message，并返回一个支持阻塞操作的PermissionDialogResult.Result，通过其get函数阻塞等待操作结束。</p><h3 id="6-0之后，权限申请是异步的，走的是startActivityForResult流程"><a href="#6-0之后，权限申请是异步的，走的是startActivityForResult流程" class="headerlink" title="6.0之后，权限申请是异步的，走的是startActivityForResult流程"></a>6.0之后，权限申请是异步的，走的是startActivityForResult流程</h3><p>流程如下：</p><p><img src="https://note.youdao.com/yws/api/personal/file/WEB35e1e4a29a4e0e5865e1bdc1b711dd48?method=download&amp;shareKey=31ee157fef4961039530624ba9b5f86c" alt=""></p><h2 id="动态更新及持久化权限"><a href="#动态更新及持久化权限" class="headerlink" title="动态更新及持久化权限"></a>动态更新及持久化权限</h2><p>流程如下：</p><p><img src="https://note.youdao.com/yws/api/personal/file/WEB76969987697ff8b4b0176cd7869f8a4f?method=download&amp;shareKey=f0ccf76b58043e6c2a7fe9eb4ce907e9" alt=""></p><p>我们可以看到，最终持久化的文件是data/system/0/runtime-permissions.xml，该文件只有在Android6.0以上才有，应用包名+权限名+授权状态</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;pkg name=&quot;com.snail.xxx&quot;&gt;</span><br><span class="line">  &lt;item name=&quot;android.permission.CALL_PHONE&quot; granted=&quot;true&quot; flags=&quot;0&quot; /&gt;</span><br><span class="line">  &lt;item name=&quot;android.permission.CAMERA&quot; granted=&quot;false&quot; flags=&quot;1&quot; /&gt;</span><br><span class="line">&lt;/pkg&gt;</span><br></pre></td></tr></table></figure><h2 id="Runtime-Permission读取"><a href="#Runtime-Permission读取" class="headerlink" title="Runtime-Permission读取"></a>Runtime-Permission读取</h2><p>读取时机：在手机重新启动时，由PKMS读取，开机时，PKMS会扫描APK，读取packages.xml文件，而运行时权限，是在启动时读取。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">boolean readLPw(@NonNull List&lt;UserInfo&gt; users) &#123;</span><br><span class="line">    FileInputStream str = null;</span><br><span class="line">    if (mBackupSettingsFilename.exists()) &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            str = new FileInputStream(mBackupSettingsFilename);</span><br><span class="line">            mReadMessages.append(&quot;Reading from backup settings file\n&quot;);</span><br><span class="line">     ...</span><br><span class="line">   while ((type = parser.next()) != XmlPullParser.END_DOCUMENT</span><br><span class="line">                &amp;&amp; (type != XmlPullParser.END_TAG || parser.getDepth() &gt; outerDepth)) &#123;     </span><br><span class="line">            String tagName = parser.getName();</span><br><span class="line">            if (tagName.equals(&quot;package&quot;)) &#123;</span><br><span class="line">            </span><br><span class="line">  &lt;!--关键点1--读取package信息，包括install权限信息（对于Android6.0package.xml）--&gt;</span><br><span class="line">    readPackageLPw(parser); </span><br><span class="line"> ...</span><br><span class="line"> &lt;!--关键点2 读取runtime permmsion权限信息--&gt;</span><br><span class="line"> </span><br><span class="line">    for (UserInfo user : users) &#123;</span><br><span class="line">        mRuntimePermissionsPersistence.readStateForUserSyncLPr(user.id);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>流程如下：</p><p><img src="https://note.youdao.com/yws/api/personal/file/WEB2d3e3b184fbc80950299de348dac2a33?method=download&amp;shareKey=cc38db059df41f3373f59619c2c335d8" alt=""></p><h2 id="Android6-0及以上动态申请普通权限会怎么样？"><a href="#Android6-0及以上动态申请普通权限会怎么样？" class="headerlink" title="Android6.0及以上动态申请普通权限会怎么样？"></a>Android6.0及以上动态申请普通权限会怎么样？</h2><p>申请结果永远是取得授权的，因为在安装时就已经获取了。</p><p>我们可以看到对应的xml：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;perms&gt;</span><br><span class="line">    &lt;item name=&quot;android.permission.INTERNET&quot; granted=&quot;true&quot; flags=&quot;0&quot; /&gt;</span><br><span class="line">    &lt;item name=&quot;android.permission.ACCESS_WIFI_STATE&quot; granted=&quot;true&quot; flags=&quot;0&quot; /&gt;</span><br><span class="line">&lt;/perms&gt;</span><br></pre></td></tr></table></figure><h2 id="Android动态管理权限的关键节点在哪里？"><a href="#Android动态管理权限的关键节点在哪里？" class="headerlink" title="Android动态管理权限的关键节点在哪里？"></a>Android动态管理权限的关键节点在哪里？</h2><p>Android6.0之后采用鉴权与申请分开的做法，先查询一下有没有这种权限，没有再去申请，这样可以避免了权限管理的混淆，更加清晰灵活。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Android动态权限管理原理（6-0及以上）&quot;&gt;&lt;a href=&quot;#Android动态权限管理原理（6-0及以上）&quot; class=&quot;headerlink&quot; title=&quot;Android动态权限管理原理（6.0及以上）&quot;&gt;&lt;/a&gt;Android动态权限管理原理（6
      
    
    </summary>
    
      <category term="framework" scheme="http://skyacer.github.io/categories/framework/"/>
    
    
      <category term="authority" scheme="http://skyacer.github.io/tags/authority/"/>
    
  </entry>
  
  <entry>
    <title>被后台杀死后，Android应用如何重新走闪屏逻辑</title>
    <link href="http://skyacer.github.io/2018/09/04/%E8%A2%AB%E5%90%8E%E5%8F%B0%E6%9D%80%E6%AD%BB%E5%90%8E%EF%BC%8CAndroid%E5%BA%94%E7%94%A8%E5%A6%82%E4%BD%95%E9%87%8D%E6%96%B0%E8%B5%B0%E9%97%AA%E5%B1%8F%E9%80%BB%E8%BE%91/"/>
    <id>http://skyacer.github.io/2018/09/04/被后台杀死后，Android应用如何重新走闪屏逻辑/</id>
    <published>2018-09-04T09:18:34.000Z</published>
    <updated>2018-09-06T09:41:25.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="被后台杀死后，Android应用如何重新走闪屏逻辑"><a href="#被后台杀死后，Android应用如何重新走闪屏逻辑" class="headerlink" title="被后台杀死后，Android应用如何重新走闪屏逻辑"></a>被后台杀死后，Android应用如何重新走闪屏逻辑</h1><h2 id="当应用被后台杀死后，Android是如何走闪屏逻辑的？"><a href="#当应用被后台杀死后，Android是如何走闪屏逻辑的？" class="headerlink" title="当应用被后台杀死后，Android是如何走闪屏逻辑的？"></a>当应用被后台杀死后，Android是如何走闪屏逻辑的？</h2><p>恢复的过程是先恢复的第一个界面是用户最后看到的那个界面。</p><p>如下图是杀死之前的堆栈：</p><p><img src="https://note.youdao.com/yws/api/personal/file/WEB2f84d35cf0c4a3ab857e07bd0f6082eb?method=download&amp;shareKey=71fed6e166102570e8dfa292da0935de" alt="1"></p><p>如下图是被后台杀死后，Activity的堆栈，既然被销毁了自然堆栈为空，但是AMS被保留下来</p><p><img src="https://note.youdao.com/yws/api/personal/file/WEBc6474e767aeb6109c6a3903d92d04497?method=download&amp;shareKey=64470545d28b457a7a8ff992673b41e7" alt="2"></p><p>当用户再次启动APP，看到的是最后看到的那个Activity，也就是C Activity。</p><p><img src="https://note.youdao.com/yws/api/personal/file/WEB349d70ce807cc1dc6085997918af3613?method=download&amp;shareKey=03555c2281bdc1c87dc7cb77bf290651" alt="3"></p><p>在用户点击返回后，看到的C Activity之前的B Activity，以此类推。</p><p><img src="https://note.youdao.com/yws/api/personal/file/WEB3145fd6a76f1f11a2c1a6be0a52cbc44?method=download&amp;shareKey=18ec2082543c4199a4ce8ae97a71e3fb" alt=""></p><h2 id="怎么判断当前Activity是否为恢复流程状态？"><a href="#怎么判断当前Activity是否为恢复流程状态？" class="headerlink" title="怎么判断当前Activity是否为恢复流程状态？"></a>怎么判断当前Activity是否为恢复流程状态？</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">public void onCreate(Bundle savedInstanceState) &#123;</span><br><span class="line">    super.onCreate(savedInstanceState);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>只需要判断savedInstanceState是否非空即可判断，如果为非空，则为后台杀死恢复流程。</p><h2 id="如何在恢复流程APP，走闪屏的逻辑？"><a href="#如何在恢复流程APP，走闪屏的逻辑？" class="headerlink" title="如何在恢复流程APP，走闪屏的逻辑？"></a>如何在恢复流程APP，走闪屏的逻辑？</h2><ul><li>进程存活，Activity存活</li><li>进程存活，但是没有Activity存活</li><li>进程不存在（无论是否被杀）</li></ul><p>其实后面两种完全可以看做一种，这个时候，都是要先start MainActivity，然后让MainActivity在其OnCreate中通过startActivityForResult启动SplashActivity，SplashActivity返回后，在start TargetActivity。下面的讨论都是针对后面两种，需要做的有两件事</p><ul><li>一是：检测出后面两种场景，并且在唤起主界面的时候需要添加Intent.FLAG_ACTIVITY_CLEAR_TASK清理之前的现场</li><li>二是：在MainActivity的路由系统中，针对这两种场景要，先跳转闪屏，闪屏回来后，再跳转推送页</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Intent intent = new Intent(this, MainActivity.class);</span><br><span class="line">intent.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK|Intent.FLAG_ACTIVITY_CLEAR_TASK);</span><br><span class="line">intent.setDate(跳转的Uri scheme)</span><br><span class="line">startActivity(intent);</span><br></pre></td></tr></table></figure><p>在MainActivity的路由中，需要区分是否推送跳转进来的</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">public void onCreate(Bundle savedInstanceState) &#123;</span><br><span class="line">    super.onCreate(savedInstanceState);</span><br><span class="line">    Uri uri= getIntent().getData();</span><br><span class="line">    &lt;!--只有在intent被设置了跳转数据的时候才去跳转，一般是推送就来，如果冷启动，是没有数据的--&gt;</span><br><span class="line">    if(uri!=null)&#123;</span><br><span class="line">        SplashActivity.startActivityForResult(this,JUMP_TO_TARGET)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;!--Intent.FLAG_ACTIVITY_CLEAR_TASK保证了onNewIntent被调用的时候，进程一定是正常活着的--&gt;</span><br><span class="line">@Override</span><br><span class="line">protected void onNewIntent(Intent intent) &#123;</span><br><span class="line">    Uri uri= intent.getData();</span><br><span class="line">    intent.setData(null);</span><br><span class="line">    router(uri);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">protected void onActivityResult(int requestCode, int resultCode, Intent data) &#123;</span><br><span class="line">    super.onActivityResult(requestCode, resultCode, data);</span><br><span class="line">    if(requestCode==JUMP_TO_TARGET &amp;&amp; requestCode == RESULT_OK)&#123;</span><br><span class="line">        router(getIntent().getData());</span><br><span class="line">        getIntent().setData(null);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private void router(Uri uri) &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;被后台杀死后，Android应用如何重新走闪屏逻辑&quot;&gt;&lt;a href=&quot;#被后台杀死后，Android应用如何重新走闪屏逻辑&quot; class=&quot;headerlink&quot; title=&quot;被后台杀死后，Android应用如何重新走闪屏逻辑&quot;&gt;&lt;/a&gt;被后台杀死后，Andr
      
    
    </summary>
    
      <category term="framework" scheme="http://skyacer.github.io/categories/framework/"/>
    
    
      <category term="Activity" scheme="http://skyacer.github.io/tags/Activity/"/>
    
  </entry>
  
  <entry>
    <title>Android四大组件之Activity的启动模式</title>
    <link href="http://skyacer.github.io/2018/09/04/Android%E5%9B%9B%E5%A4%A7%E7%BB%84%E4%BB%B6%E4%B9%8BActivity%E7%9A%84%E5%90%AF%E5%8A%A8%E6%A8%A1%E5%BC%8F/"/>
    <id>http://skyacer.github.io/2018/09/04/Android四大组件之Activity的启动模式/</id>
    <published>2018-09-04T06:19:50.000Z</published>
    <updated>2018-09-04T09:19:48.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Android四大组件之Activity的启动模式"><a href="#Android四大组件之Activity的启动模式" class="headerlink" title="Android四大组件之Activity的启动模式"></a>Android四大组件之Activity的启动模式</h1><h2 id="简单的Launchmode"><a href="#简单的Launchmode" class="headerlink" title="简单的Launchmode"></a>简单的Launchmode</h2><ul><li>standard: 标准启动模式，每次都会启动一个新的activity实例</li><li>singleTop: 单独使用这种模式时，<strong>如果Activity实例位于当前任务栈顶</strong>，就重用栈顶实例，而不新建，并回调该实例onNewIntent()方法，否则走新建流程。</li></ul><p><img src="https://note.youdao.com/yws/api/personal/file/WEBe890f0a6c728b0483f1488f944a8f497?method=download&amp;shareKey=5a98551511c9f170759b5473e357d65d" alt=""></p><ul><li>singleTask: 又称为栈内复用模式。这是一种单例模式，与singTop点类似，只不过singTop是检测栈顶元素是否有需要启动的Activity，而singTask则是检测整个栈中是否存在当前需要启动的Activity，如果存在就直接将该Activity置于栈顶，并将该Activity以上的Activity都从任务栈中移出销毁，同时也会回调onNewIntent方法</li></ul><p><img src="https://note.youdao.com/yws/api/personal/file/WEBec1daa96a120de9938157f6585c49d38?method=download&amp;shareKey=44ff4caa4a0ad3ed629c5266772f9fae" alt=""></p><ul><li>singleInstance: 该Activity在<strong>整个android系统内存</strong>中有且只有一个实例，而且该实例单独尊享一个Task。换句话说，A应用需要启动的MainActivity 是singleInstance模式，当A启动后，系统会为它创建一个新的任务栈，然后A单独在这个新的任务栈中，如果此时B应用也要激活MainActivity，由于栈内复用的特性，则不会重新创建，而是两个应用共享一个Activity的实例。</li></ul><p><img src="https://note.youdao.com/yws/api/personal/file/WEB6509384afecf0f84738e09246228e86f?method=download&amp;shareKey=d8547aa7eac86b329b8b9a4e55a87f0e" alt=""></p><p><strong>上面只适用于Activity启动Activity，而且采用的都是默认Intent，没有额外添加任何Flag</strong>，尤其主要的是FLAG_ACTIVITY_NEW_TASK的使用。</p><h2 id="Intent-FLAG-ACTIVITY-NEW-TASK分析"><a href="#Intent-FLAG-ACTIVITY-NEW-TASK分析" class="headerlink" title="Intent.FLAG_ACTIVITY_NEW_TASK分析"></a>Intent.FLAG_ACTIVITY_NEW_TASK分析</h2><ol><li>对于非Activity启动的Activity（比如Service或者通知中启动的Activity）需要显示地设置Intent.FLAG_ACTIVITY_NEW_TASK。</li><li>singleTask及singleInstance两种模式，被AMS处理后，会隐形设置Intent.FLAG_ACTIVITY_NEW_TASK</li><li>standard和singleTop的Activity不会被设置成Intent.FLAG_ACTIVITY_NEW_TASK，除非通过显示的intent.setFlag进行设置</li></ol><p><strong>Intent.FLAG_ACTIVITY_NEW_TASK的初衷是Activity目标taskAffinity的task中启动</strong></p><h2 id="Intent-FLAG-ACTIVITY-CLEAR-TASK分析"><a href="#Intent-FLAG-ACTIVITY-CLEAR-TASK分析" class="headerlink" title="Intent.FLAG_ACTIVITY_CLEAR_TASK分析"></a>Intent.FLAG_ACTIVITY_CLEAR_TASK分析</h2><ol><li>CLEAR_TASK必须配合FLAG_ACTIVITY_NEW_TASK使用</li><li>如果目标task已经存在，将清空已存在的目标Task，否则，会新建一个Task栈</li><li>在新建或清空后，会新建一个Activity作为根Activity。Intent.FLAG_ACTIVITY_CLEAR_TASK的优先级最高。</li><li>可以无视所有的配置，包括启动模式及Intent Flag，哪怕是singleInstance也会被finish并重建。</li></ol><p><img src="https://note.youdao.com/yws/api/personal/file/WEBaf8f745c56f6ef3796510aaed21a92c6?method=download&amp;shareKey=d3d237c58770d949edac74372c85543b" alt="CLEAR_TASK标识"></p><h2 id="Intent-FLAG-ACTIVITY-CLEAR-TOP分析"><a href="#Intent-FLAG-ACTIVITY-CLEAR-TOP分析" class="headerlink" title="Intent.FLAG_ACTIVITY_CLEAR_TOP分析"></a>Intent.FLAG_ACTIVITY_CLEAR_TOP分析</h2><p><img src="https://note.youdao.com/yws/api/personal/file/WEB95a60412c1c372688a92cdb1cca836c8?method=download&amp;shareKey=506250f1deca84ea6de7002162c18c4f" alt=""></p><p>在TASK2中的D采用CLEAR_TOP唤起B，首先CD先出栈，B会不会重建，取决于B有没有设置SINGLE_TOP启动模式，如果设置则不会重新，回调onNewIntent方法，如果没有设置，则先出栈，然后创建B入栈。</p><p>如果没有会新建，但不会去另一个任务栈中寻找。<br><img src="https://note.youdao.com/yws/api/personal/file/WEB515b74e655e9c2a9946d24f3d806c0f3?method=download&amp;shareKey=19ce94d5422734c23d789ab277fe877f" alt=""></p><p>该标志位表示使用singleTask模式来启动一个Activity，与在清单文件指定android：launchMode=”singleTask”效果相同。</p><h2 id="Intent-FLAG-ACTIVITY-SINGLE-TOP"><a href="#Intent-FLAG-ACTIVITY-SINGLE-TOP" class="headerlink" title="Intent.FLAG_ACTIVITY_SINGLE_TOP"></a>Intent.FLAG_ACTIVITY_SINGLE_TOP</h2><p>和launchmode中的singleTop一致，有的话就创建，没有的话就新建。</p><h2 id="为什么非Activity启动Activity要强制使用参数FLAG-ACTIVITY-NEW-TASK？"><a href="#为什么非Activity启动Activity要强制使用参数FLAG-ACTIVITY-NEW-TASK？" class="headerlink" title="为什么非Activity启动Activity要强制使用参数FLAG_ACTIVITY_NEW_TASK？"></a>为什么非Activity启动Activity要强制使用参数FLAG_ACTIVITY_NEW_TASK？</h2><p>在ContextImpl中的startActivity做了检查，如果没添加，则会抛出AndroidRuntimeException。</p><h2 id="Intent-FLAG-ACTIVITY-NO-HISTORY"><a href="#Intent-FLAG-ACTIVITY-NO-HISTORY" class="headerlink" title="Intent.FLAG_ACTIVITY_NO_HISTORY"></a>Intent.FLAG_ACTIVITY_NO_HISTORY</h2><p>使用该模式来启动Activity，当该Activity启动其他Activity后，该Activity就被销毁了，不会保留在任务栈中。如A-B,B中以这种模式启动C，C再启动D，则任务栈只有ABD。</p><h2 id="Intent-FLAG-ACTIVITY-EXCLUDE-FROM-RECENTS"><a href="#Intent-FLAG-ACTIVITY-EXCLUDE-FROM-RECENTS" class="headerlink" title="Intent.FLAG_ACTIVITY_EXCLUDE_FROM_RECENTS"></a>Intent.FLAG_ACTIVITY_EXCLUDE_FROM_RECENTS</h2><p>  使用该标识位启动的Activity不添加到最近应用列表，也即我们从最近应用里面查看不到我们启动的这个activity。与属性android:excludeFromRecents=”true”效果相同。</p><h2 id="Android任务栈是什么？"><a href="#Android任务栈是什么？" class="headerlink" title="Android任务栈是什么？"></a>Android任务栈是什么？</h2><ol><li>android任务栈又称为Task，它是一个栈结构，具有后进先出的特性，用于存放我们的Activity组件。 </li><li>我们每次打开一个新的Activity或者退出当前Activity都会在一个称为任务栈的结构中添加或者减少一个Activity组件，因此一个任务栈包含了一个activity的集合, android系统可以通过Task有序地管理每个activity，并决定哪个Activity与用户进行交互:只有在任务栈栈顶的activity才可以跟用户进行交互。 </li><li>在我们退出应用程序时，必须把所有的任务栈中所有的activity清除出栈时,任务栈才会被销毁。当然任务栈也可以移动到后台, 并且保留了每一个activity的状态. 可以有序的给用户列出它们的任务, 同时也不会丢失Activity的状态信息。 </li><li>需要注意的是，<strong>一个App中可能不止一个任务栈，某些特殊情况下，单独一个Actvity可以独享一个任务栈。还有一点就是一个Task中的Actvity可以来自不同的App，同一个App的Activity也可能不在一个Task中。</strong></li></ol><h2 id="TaskAffinity属性是什么？"><a href="#TaskAffinity属性是什么？" class="headerlink" title="TaskAffinity属性是什么？"></a>TaskAffinity属性是什么？</h2><ul><li>TaskAffinity标识着Activity所需要的任务栈名称，默认情况下，一个应用中所有的Activity所需要的任务栈名称都为该应用的包名。</li><li>TaskAffinity属性一般跟singleTask模式或者allowTaskReparenting属性结合使用，其他情况下没有实际意义。</li><li>TaskAffinity属性的值不能与当前应用包名相同，否则其值跟作废没两样。</li></ul><h2 id="allowTaskReparenting属性是什么？"><a href="#allowTaskReparenting属性是什么？" class="headerlink" title="allowTaskReparenting属性是什么？"></a>allowTaskReparenting属性是什么？</h2><p>首先我们来聊聊allowTaskReparenting属性，它的主要作用是activity的迁移，即从一个task迁移到另一个task，这个迁移跟activity的taskAffinity有关。当allowTaskReparenting的值为“true”时，则表示Activity能从启动的Task移动到有着affinity的Task（当这个Task进入到前台时），当allowTaskReparenting的值为“false”，表示它必须呆在启动时呆在的那个Task里。如果这个特性没有被设定，元素(当然也可以作用在每次activity元素上)上的allowTaskReparenting属性的值会应用到Activity上。默认值为“false”。这样说可能还比较难理解，我们举个例子，比如现在有两个应用A和B，A启动了B的一个ActivityC，然后按Home键回到桌面，再单击B应用时，如果此时，allowTaskReparenting的值为“true”，那么这个时候并不会启动B的主Activity，而是直接显示已被应用A启动的ActivityC，我们也可以认为ActivityC从A的任务栈转移到了B的任务栈中。这就好比我们在路边收养了一只与主人走失了的猫，养着养着突然有一天，主人找上门来了，这只猫也就被带回去了。我们通过图解来更好地理解这种情景： </p><p><img src="https://note.youdao.com/yws/api/personal/file/WEB9ca1c10c00630f9721831a729e848376?method=download&amp;shareKey=eb5ee6463ed6ffee39a32ca04f8692c8" alt="allowTaskReparenting"></p><p>  对比发现，如果allowTaskReparenting值为false时，ActivityC并不会直接从A应用的任务栈迁移到B应用的任务栈，而是B应用直接重新创建了ActivityC的实例。到此我们对于allowTaskReparenting和taskAffinity属性的了解就已经相当深入了，不过有点需要说明的是allowTaskReparenting仅限于singleTop和standard模式，这是因为一个activity的affinity属性由它的taskAffinity属性定义（代表栈名），而一个task的affinity由它的root activity定义。所以，一个task的root activity总是拥有和它所在task相同的affinity。由于以singleTask和singleInstance启动的activity只能是一个task的root activity，因此allowTaskReparenting仅限于以standard 和singleTop启动的activity，大家可以自行测试一下，这里我们就不测试了哈，下面我们再来说说它们可能应用用场景。</p><h2 id="怎么指定Activity所属的栈？"><a href="#怎么指定Activity所属的栈？" class="headerlink" title="怎么指定Activity所属的栈？"></a>怎么指定Activity所属的栈？</h2><p>通过设置TaskAffinity属性值为android:taskAffinity=”xxx”</p><h2 id="TaskAffinity和SingleTask结合的应用场景"><a href="#TaskAffinity和SingleTask结合的应用场景" class="headerlink" title="TaskAffinity和SingleTask结合的应用场景"></a>TaskAffinity和SingleTask结合的应用场景</h2><p>假如现在有这么一个需求,我们的客户端app正处于后台运行，此时我们因为某些需要，让微信调用自己客户端app的某个页面，用户完成相关操作后，我们不做任何处理，按下回退或者当前Activity.finish()，页面都会停留在自己的客户端（此时我们的app回退栈不为空），这显然不符合逻辑的，用户体验也是相当出问题的。我们要求是，回退必须回到微信客户端,而且要保证不杀死自己的app.这时候我们的处理方案就是，设置当前被调起Activity的属性为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">LaunchMode=&quot;&quot;SingleTask&quot; taskAffinity=&quot;com.tencent.mm&quot;</span><br></pre></td></tr></table></figure><p>其中com.tencent.mm是借助于工具找到的微信包名，就是把自己的Activity放到微信默认的Task栈里面，这样回退时就会遵循“Task只要有Activity一定从本Task剩余Activity回退”的原则，不会回到自己的客户端；而且也不会影响自己客户端本来的Activity和Task逻辑。</p><h2 id="TaskAffinity与allowTaskReparenting的应用场景"><a href="#TaskAffinity与allowTaskReparenting的应用场景" class="headerlink" title="TaskAffinity与allowTaskReparenting的应用场景"></a>TaskAffinity与allowTaskReparenting的应用场景</h2><p>一个e-mail应用消息包含一个网页链接，点击这个链接将出发一个activity来显示这个页面，虽然这个activity是浏览器应用定义的，但是activity由于e-mail应用程序加载的，所以在这个时候该activity也属于e-mail这个task。如果e-mail应用切换到后台，浏览器在下次打开时由于allowTaskReparenting值为true，此时浏览器就会显示该activity而不显示浏览器主界面，同时actvity也将从e-mail的任务栈迁移到浏览器的任务栈，下次打开e-mail时并不会再显示该activity </p><p>在AndroidMainifest的<activity>标签设置该activity的<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">allowTaskReparenting:true</span><br></pre></td></tr></table></figure></activity></p><h2 id="如何清空任务栈？"><a href="#如何清空任务栈？" class="headerlink" title="如何清空任务栈？"></a>如何清空任务栈？</h2><p>我们只需要在<activity>标签指明相应的属性值</activity></p><h3 id="android-clearTaskOnLaunch"><a href="#android-clearTaskOnLaunch" class="headerlink" title="android:clearTaskOnLaunch"></a>android:clearTaskOnLaunch</h3><p>  这个属性用来标记是否从task清除除根Activity之外的所有的Activity，“true”表示清除，“false”表示不清除，默认为“false”。这里有点我们必须要注意的，这个属性只对任务栈内的root Activity起作用，任务栈内其他的Activity都会被忽略。如果android:clearTaskOnLaunch属性为“true”，每次我们重新进入这个应用时，我们只会看到根Activity，任务栈中的其他Activity都会被清除出栈。<br>  比如一个应用的Activity A,B,C，其中clearTaskOnLaunch设置为true，C为默认值，我们依次启动A,B,C，点击HOME,再在桌面点击图标。启动的是A，而B，C将都被移除当前任务栈。也就是说，当Activity的属性clearTaskOnLaunch为true时将被优先启动，其余的Activity(B、C)都被移除任务栈并销毁，除非前面A已经finish销毁，后面的已注册clearTaskOnLaunch为true的activity(B)才会生效。<br>  特别地，如果我们的应用中引用到了其他应用的Activity，这些Activity设置了android:allowTaskReparenting属性为“true”，则它们会被重新宿主到有共同affinity的task中。    </p><h3 id="android-finishOnTaskLaunch"><a href="#android-finishOnTaskLaunch" class="headerlink" title="android:finishOnTaskLaunch"></a>android:finishOnTaskLaunch</h3><p>如果将finishOnTaskLauch属性值设置为true，离开这个Activity所依赖的任务栈后，重新返回时，该Activity会被finish掉，其他的Activity不受影响。</p><h3 id="android-alwaysRetainTaskState"><a href="#android-alwaysRetainTaskState" class="headerlink" title="android:alwaysRetainTaskState"></a>android:alwaysRetainTaskState</h3><p>当该属性设置为true时，该Activity不受到任何清理命令的影响，一直保持当前任务栈状态。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Android四大组件之Activity的启动模式&quot;&gt;&lt;a href=&quot;#Android四大组件之Activity的启动模式&quot; class=&quot;headerlink&quot; title=&quot;Android四大组件之Activity的启动模式&quot;&gt;&lt;/a&gt;Android四大组件
      
    
    </summary>
    
      <category term="framework" scheme="http://skyacer.github.io/categories/framework/"/>
    
    
      <category term="Activity" scheme="http://skyacer.github.io/tags/Activity/"/>
    
  </entry>
  
  <entry>
    <title>Chrome调试javascript方法</title>
    <link href="http://skyacer.github.io/2018/08/10/Chrome%E8%B0%83%E8%AF%95javascript%E6%96%B9%E6%B3%95/"/>
    <id>http://skyacer.github.io/2018/08/10/Chrome调试javascript方法/</id>
    <published>2018-08-10T07:34:43.000Z</published>
    <updated>2018-08-10T07:35:30.000Z</updated>
    
    <content type="html"><![CDATA[<div class="devsite-article-body clearfix            " itemprop="articleBody"><br><br><style><br>.devtools-inline {<br>  max-height: 1em;<br>  vertical-align: middle;<br>}<br></style><br><br><!-- TODO     make demo responsive--><br><br><br><!-- wf_template: src/templates/contributors/include.html --><br><br><style><br>.wf-byline {display: inline-flex; margin: 16px 32px 16px 0;}<br>.wf-byline .attempt-left {margin: 0 16px 0 0;}<br>.wf-byline img {border-radius: 100%; min-width: 64px; height: 64px;}<br>.wf-byline .wf-byline-desc {font-size: smaller; word-break: break-word;}<br>.wf-byline .wf-byline-social {font-size: smaller;}<br></style><br><br><section class="wf-byline" itemprop="author" itemscope="" itemtype="http://schema.org/Person"><br>  <div class="attempt-left"><br>    <figure><br>      <img itemprop="image" src="https://developers.google.com/web/images/contributors/kaycebasques.jpg?hl=zh-cn" alt="Kayce Basques"><br>    </figure><br>  </div><br>  <section class="wf-byline-meta"><br>    <div class="wf-byline-name"><br>      <strong>By</strong><br>      <span itemprop="name"><br>        <a href="https://developers.google.com/web/resources/contributors/kaycebasques?hl=zh-cn" target="_blank" rel="noopener"><br>          <span itemprop="givenName">Kayce</span><br>          <span itemprop="familyName">Basques</span><br>        </a><br>      </span><br>    </div><br>    <div class="wf-byline-desc"><br>        Technical Writer for Chrome DevTools<br>    </div><br>  </section><br></section><br><br><p>本交互式教程循序渐进地教您在 Chrome DevTools 中调试 JavaScript 的基本工作流程。<br>虽然教程介绍的是如何调试一种具体问题，但您学到的一般工作流程对调试各种类型的 JavaScript 错误均有帮助。</p><br><p>如果您使用 <code>console.log()</code> 来查找和修正代码中的错误，可以考虑改用本教程介绍的工作流程。<br>其速度快得多，也更有效。</p><br><h2 id="step-1"><a href="#top_of_page" class="devsite-back-to-top-link material-icons" data-tooltip-align="b,c" data-tooltip="返回页首" aria-label="返回页首" data-title="返回页首"></a>第 1 步：重现错误</h2><br><p>重现错误始终是调试的第一步。“重现错误”是指找到一系列总是能导致错误出现的操作。</p><br><p>您可能需要多次重现错误，因此要尽量避免任何多余的步骤。</p><br><p>请按照以下说明重现您要在本教程中修正的错误。</p><br><ol><br><li><br><p>点击 <strong>Open Demo</strong>。演示页面在新标签中打开。</p><br><p><a href="https://googlechrome.github.io/devtools-samples/debug-js/get-started" target="devtools" rel="noopener noreferrer"><br>   <button>Open Demo</button><br> </a></p><br></li><br><li><br><p>在演示页面上，输入 <code>5</code> 作为 <strong>Number 1</strong>。</p><br></li><br><li>输入 <code>1</code> 作为 <strong>Number 2</strong>。</li><br><li>点击 <strong>Add Number 1 and Number 2</strong>。</li><br><li>查看输入和按钮下方的标签。上面显示的是 <code>5 + 1 = 51</code>。</li><br></ol><br><p>啊呜。这个结果是错误的。正确结果应为 <code>6</code>。这就是您要修正的错误。</p><br><h2 id="2"><a href="#top_of_page" class="devsite-back-to-top-link material-icons" data-tooltip-align="b,c" data-tooltip="返回页首" aria-label="返回页首" data-title="返回页首"></a>第 2 步：使用断点暂停代码</h2><br><p>DevTools 让您可以暂停执行中的代码，并对暂停时刻的<em>所有</em>变量值进行检查。<br>用于暂停代码的工具称为<strong>断点</strong>。<br>立即试一试：</p><br><ol><br><li><br><p>按 <kbd>Command</kbd>+<kbd>Option</kbd>+<kbd>I</kbd> (Mac) 或 <kbd>Ctrl</kbd>+<kbd>Shift</kbd>+<kbd>I</kbd>（Windows、Linux）在演示页面上打开 DevTools。</p><br></li><br><li><br><p>点击 <strong>Sources</strong> 标签。</p><br></li><br></ol><br><!-- TODO add a screenshot.Don't create the screenshot until demo design is     finished.Add it here rather than previous screenshot in case Sources     is hidden --><br><br><ol><br><li>点击 <strong>Event Listener Breakpoints</strong> 将该部分展开。DevTools 显示一个包含 <strong>Animation</strong> 和 <strong>Clipboard</strong> 等可展开事件类别的列表。</li><br></ol><br><!-- TODO or maybe add it here --><br><br><ol><br><li>在 <strong>Mouse</strong> 事件类别旁，点击 <strong>Expand</strong> <img alt="Expand 图标" class="devtools-inline" src="https://developers.google.com/web/tools/chrome-devtools/images/expand.png?hl=zh-cn">。DevTools 显示一个包含 <strong>click</strong> 等 Mouse 事件的列表，事件旁有相应的复选框。</li><br><li><br><p>选中 <strong>click</strong> 复选框。</p><br><p></p><figure><br>   &lt;img src=”<a href="https://developers.google.com/web/tools/chrome-devtools/javascript/imgs/get-started-click-breakpoint.png?hl=zh-cn&quot;" target="_blank" rel="noopener">https://developers.google.com/web/tools/chrome-devtools/javascript/imgs/get-started-click-breakpoint.png?hl=zh-cn&quot;</a> alt=”DevTools 在演示页面上打开，Sources 面板获得焦点，click 事件侦听器断点处于启用状态。” &lt;figcaption=””&gt;<br>     <b>图 1</b>：DevTools 在演示页面上打开，Sources 面板获得焦点，click 事件侦听器断点处于启用状态。<br>     如果 DevTools 窗口较大，则 <b>Event Listener Breakpoints</b> 窗格位于右侧，而不是像屏幕截图中那样位于左下方。<br> </figure><p></p><br></li><br><li><br><p>返回至演示页面，再次点击 <strong>Add Number 1 and Number 2</strong>。DevTools 暂停演示并在 <strong>Sources</strong> 面板中突出显示一行代码。<br>   DevTools 突出显示的是下面这行代码：</p><br><p><code>function onClick() {</code></p><br></li><br></ol><br><p>当您选中 <strong>click</strong> 复选框时，就是在所有 <code>click</code> 事件上设置了一个基于事件的断点。<br>点击了<em>任何</em>节点，并且该节点具有 <code>click</code> 处理程序时，DevTools 会自动暂停在该节点 <code>click</code> 处理程序的第一行。</p><br><aside class="note"><strong>Note:</strong><span> 这不过是 DevTools 提供的众多断点类型中的一种。应使用的断点类型取决于您要调试的问题类型。</span></aside><br><h2 id="3"><a href="#top_of_page" class="devsite-back-to-top-link material-icons" data-tooltip-align="b,c" data-tooltip="返回页首" aria-label="返回页首" data-title="返回页首"></a>第 3 步：单步调试代码</h2><br><p>一个常见的错误原因是脚本执行顺序有误。<br>可以通过单步调试代码一次一行地检查代码执行情况，准确找到执行顺序异常之处。立即试一试：</p><br><ol><br><li><br><p>在 DevTools 的 <strong>Sources</strong> 面板上，点击 <strong>Step into next function call</strong> <img alt="单步执行到下一个函数调用中" class="devtools-inline" src="https://developers.google.com/web/tools/chrome-devtools/images/step-into.png?hl=zh-cn">，一次一行地单步调试 <code>onClick()</code> 函数的执行。DevTools 突出显示下面这行代码：</p><br><p><code>if (inputsAreEmpty()) {</code></p><br></li><br><li><br><p>点击 <strong>Step over next function call</strong> <img alt="单步执行时越过下一个函数调用" class="devtools-inline" src="https://developers.google.com/web/tools/chrome-devtools/images/step-over.png?hl=zh-cn">。<br>DevTools 执行 <code>inputsAreEmpty()</code> 但不进入它。<br>请注意 DevTools 是如何跳过几行代码的。<br>   这是因为 <code>inputsAreEmpty()</code> 求值结果为 false，所以 <code>if</code> 语句的代码块未执行。</p><br></li><br></ol><br><p>这就是单步调试代码的基本思路。如果您看一下 <code>get-started.js</code> 中的代码，就能发现错误多半出在 <code>updateLabel()</code> 函数的某处。您可以不必单步调试每一行代码，而是使用另一种断点在靠近错误位置的地方暂停代码。</p><br><h2 id="4"><a href="#top_of_page" class="devsite-back-to-top-link material-icons" data-tooltip-align="b,c" data-tooltip="返回页首" aria-label="返回页首" data-title="返回页首"></a>第 4 步：设置另一个断点</h2><br><p>代码行断点是最常见的断点类型。如果您想在执行到某一行代码时暂停，请使用代码行断点。立即试一试：</p><br><ol><br><li><br><p>看一下 <code>updateLabel()</code> 中的最后一行代码，其内容类似于：</p><br><p><code>label.textContent = addend1 + ‘ + ‘ + addend2 + ‘ = ‘ + sum;</code></p><br></li><br><li><br><p>在这行代码的左侧，可以看到这行代码的行号：<br><strong>32</strong>。点击 <strong>32</strong>。DevTools 会在 <strong>32</strong> 上放置一个蓝色图标。<br>这意味着这行代码上有一个代码行断点。<br>   DevTools 现在总是会在执行这行代码之前暂停。</p><br></li><br><li>点击 <strong>Resume script execution</strong> <img alt="继续执行脚本" class="devtools-inline" src="https://developers.google.com/web/tools/chrome-devtools/images/resume-script-execution.png?hl=zh-cn">。<br>脚本继续执行，直至到达您设置了断点的代码行。</li><br><li>看一下 <code>updateLabel()</code> 中已执行的代码行。</li><br></ol><br><p>DevTools 打印输出 <code>addend1</code>、<code>addend2</code> 和 <code>sum</code> 的值。</p><br><p><code>sum</code> 的值疑似有问题。其求值结果本应是数字，而实际结果却是字符串。<br>这可能就是造成错误的原因。</p><br><h2 id="5"><a href="#top_of_page" class="devsite-back-to-top-link material-icons" data-tooltip-align="b,c" data-tooltip="返回页首" aria-label="返回页首" data-title="返回页首"></a>第 5 步：检查变量值</h2><br><p>另一种常见的错误原因是，变量或函数产生的值异常。<br>许多开发者都利用 <code>console.log()</code> 来了解值随时间变化的情况，但 <code>console.log()</code> 可能单调乏味而又效率低下，原因有两个。<br>其一，您可能需要手动编辑大量调用 <code>console.log()</code> 的代码。<br>其二，由于您不一定知晓究竟哪一个变量与错误有关，因此可能需要对许多变量进行记录。</p><br><p>DevTools 为 <code>console.log()</code> 提供的其中一个替代工具是监视表达式。可以使用监视表达式来监视变量值随时间变化的情况。顾名思义，监视表达式的监视对象不仅限于变量。您可以将任何有效的 JavaScript 表达式存储在监视表达式中。<br>立即试一试：</p><br><ol><br><li>在 DevTools 的 <strong>Sources</strong> 面板上，点击 <strong>Watch</strong>。该部分随即展开。</li><br><li>点击 <strong>Add Expression</strong> <img alt="添加表达式" class="devtools-inline" src="https://developers.google.com/web/tools/chrome-devtools/javascript/imgs/add-expression.png?hl=zh-cn">。</li><br><li>键入 <code>typeof sum</code>。</li><br><li><br><p>按 <kbd>Enter</kbd>。DevTools 显示 <code>typeof sum: “string”</code>。冒号右侧的值就是监视表达式的结果。</p><br><p></p><figure><br>   &lt;img src=”<a href="https://developers.google.com/web/tools/chrome-devtools/javascript/imgs/get-started-watch-expression.png?hl=zh-cn&quot;" target="_blank" rel="noopener">https://developers.google.com/web/tools/chrome-devtools/javascript/imgs/get-started-watch-expression.png?hl=zh-cn&quot;</a> alt=”“监视表达式”窗格。” &lt;figcaption=””&gt;<br>     <b>图 1</b>：创建  <code>typeof sum</code> 监视表达式后的“监视表达式”窗格（右下方）。<br>     如果 DevTools 窗口较大，则“监视表达式”窗格位于右侧，<b>Event Listener Breakpoints</b> 窗格的上方。<br> </figure><p></p><br></li><br></ol><br><p>正如猜想的那样，<code>sum</code> 的求值结果本应是数字，而实际结果却是字符串。<br>这就是演示页面错误的原因。</p><br><p>DevTools 为 <code>console.log()</code> 提供的另一个替代工具是 Console。可以使用 Console 对任意 JavaScript 语句求值。开发者通常利用 Console 在调试时覆盖变量值。在您所处的情况下，Console 可帮助您测试刚发现的错误的潜在解决方法。<br>立即试一试：</p><br><ol><br><li>如果您尚未打开 Console 抽屉，请按 <kbd>Escape</kbd> 将其打开。<br>它会在 DevTools 窗口底部打开。</li><br><li>在 Console 中，键入 <code>parseInt(addend1) + parseInt(addend2)</code>。</li><br><li><br><p>按 <kbd>Enter</kbd>。DevTools 对语句求值并打印输出 <code>6</code>，即您预料演示页面会产生的结果。</p><br><p></p><figure><br>   &lt;img src=”<a href="https://developers.google.com/web/tools/chrome-devtools/javascript/imgs/get-started-console.png?hl=zh-cn&quot;" target="_blank" rel="noopener">https://developers.google.com/web/tools/chrome-devtools/javascript/imgs/get-started-console.png?hl=zh-cn&quot;</a> alt=”对一个语句求值后的 Console 抽屉。” &lt;figcaption=””&gt;<br>     <b>图 1</b>：对  <code>parseInt(addend1) + parseInt(addend2)</code> 求值后的 Console 抽屉。<br> </figure><p></p><br></li><br></ol><br><h2 id="6"><a href="#top_of_page" class="devsite-back-to-top-link material-icons" data-tooltip-align="b,c" data-tooltip="返回页首" aria-label="返回页首" data-title="返回页首"></a>第 6 步：应用修正</h2><br><p>您已找到错误的潜在解决方法。剩下的工作就是编辑代码后重新运行演示页面来测试修正效果。<br>您不必离开 DevTools 就能应用修正。<br>您可以直接在 DevTools UI 内编辑 JavaScript 代码。<br>立即试一试：</p><br><ol><br><li>在 DevTools 的 <strong>Sources</strong> 面板上的代码编辑器中，将 <code>var sum = addend1 + addend2</code> 替换为 <code>var sum = parseInt(addend1) + parseInt(addend2);</code>。它就是您当前暂停位置上面那行代码。</li><br><li>按 <kbd>Command</kbd>+<kbd>S</kbd> (Mac) 或 <kbd>Ctrl</kbd>+<kbd>S</kbd>（Windows、Linux）保存更改。代码的背景色变为红色，这表示在 DevTools 内更改了脚本。</li><br><li>点击 <strong>Deactivate breakpoints</strong> <img alt="停用断点" class="devtools-inline" src="https://developers.google.com/web/tools/chrome-devtools/images/deactivate-breakpoints-button.png?hl=zh-cn">。它变为蓝色，表示处于活动状态。<br>如果进行了此设置，DevTools 会忽略您已设置的任何断点。</li><br><li>点击 <strong>Resume script execution</strong> <img alt="继续执行脚本" class="devtools-inline" src="https://developers.google.com/web/tools/chrome-devtools/images/resume-script-execution.png?hl=zh-cn">。</li><br><li>使用不同的值测试演示页面。现在演示页面应能正确计算求和。</li><br></ol><br><p>切记，此工作流程只对运行在浏览器中的代码应用修正。<br>它不会为所有运行您的页面的用户修正代码。<br>要实现该目的，您需要修正运行在提供页面的服务器上的代码。</p><br><h2 id="_1"><a href="#top_of_page" class="devsite-back-to-top-link material-icons" data-tooltip-align="b,c" data-tooltip="返回页首" aria-label="返回页首" data-title="返回页首"></a>后续步骤</h2><br><p>恭喜！现在您已掌握了在 DevTools 中调试 JavaScript 的基础知识。</p><br><p>本教程只向您介绍了两种设置断点的方法。DevTools 还提供了许多其他方法，其中包括：</p><br><ul><br><li>仅在满足您指定的条件时触发的条件断点。</li><br><li>发生已捕获或未捕获异常时触发的断点。</li><br><li>当请求的网址与您提供的子字符串匹配时触发的 XHR 断点。</li><br></ul><br><p><a class="gc-analytics-event" data-category="DevTools / Debug JS / Get Started / Next Steps / Breakpoints" href="https://developers.google.com/web/tools/chrome-devtools/javascript/add-breakpoints?hl=zh-cn" target="_blank" rel="noopener noreferrer"><button>为我演示所有断点</button></a></p><br><p>有几个代码单步执行控件在本教程中未予说明。<br>请点击以下链接，了解有关它们的更多信息。</p><br><p><a class="gc-analytics-event" data-category="DevTools / Debug JS / Get Started / Next Steps / Breakpoints" href="https://developers.google.com/web/tools/chrome-devtools/javascript/step-code?hl=zh-cn#stepping_in_action" target="_blank" rel="noopener noreferrer"><button>我想要掌握代码单步调试知识</button></a></p><br><h2 id="_2"><a href="#top_of_page" class="devsite-back-to-top-link material-icons" data-tooltip-align="b,c" data-tooltip="返回页首" aria-label="返回页首" data-title="返回页首"></a></h2><br><br>  </div>]]></content>
    
    <summary type="html">
    
      
      
        &lt;div class=&quot;devsite-article-body clearfix
            &quot; itemprop=&quot;articleBody&quot;&gt;&lt;br&gt;&lt;br&gt;&lt;style&gt;&lt;br&gt;.devtools-inline {&lt;br&gt;  max-height: 1em;&lt;b
      
    
    </summary>
    
      <category term="前端" scheme="http://skyacer.github.io/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="debug" scheme="http://skyacer.github.io/tags/debug/"/>
    
  </entry>
  
  <entry>
    <title>Android窗口管理分析（五）-——-硬件加速和软件加速的区别</title>
    <link href="http://skyacer.github.io/2018/07/30/Android%E7%AA%97%E5%8F%A3%E7%AE%A1%E7%90%86%E5%88%86%E6%9E%90%EF%BC%88%E4%BA%94%EF%BC%89-%E2%80%94%E2%80%94-%E7%A1%AC%E4%BB%B6%E5%8A%A0%E9%80%9F%E5%92%8C%E8%BD%AF%E4%BB%B6%E5%8A%A0%E9%80%9F%E7%9A%84%E5%8C%BA%E5%88%AB/"/>
    <id>http://skyacer.github.io/2018/07/30/Android窗口管理分析（五）-——-硬件加速和软件加速的区别/</id>
    <published>2018-07-30T06:54:25.000Z</published>
    <updated>2018-07-30T06:55:27.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Android窗口管理分析（五）-——-硬件加速和软件加速的区别"><a href="#Android窗口管理分析（五）-——-硬件加速和软件加速的区别" class="headerlink" title="Android窗口管理分析（五） —— 硬件加速和软件加速的区别"></a>Android窗口管理分析（五） —— 硬件加速和软件加速的区别</h1><blockquote><p>硬件加速直观上说是依赖GPU实现图形绘制加速，软硬件加速的区别是指图形绘制究竟是GPU来处理还是CPU，如果是GPU就认为是硬件加速，反之用CPU就是软件绘制。</p></blockquote><p>主要分为两部分分析：</p><ol><li>前期策略：如何构建需要绘制的区域</li><li>后期绘制：单独渲染线程，依赖GPU进行绘制</li></ol><h2 id="硬-软件加速有什么异同点？"><a href="#硬-软件加速有什么异同点？" class="headerlink" title="硬/软件加速有什么异同点？"></a>硬/软件加速有什么异同点？</h2><h3 id="相同点"><a href="#相同点" class="headerlink" title="相同点"></a>相同点</h3><ol><li>绘制内存的分配都是类似的，都是需要请求SurfaceFlinger服务分配一块内存</li><li>绘制都是在APP端，绘制后同样需要通知SurfaceFlinger进行合成</li></ol><h3 id="不同点"><a href="#不同点" class="headerlink" title="不同点"></a>不同点</h3><ol><li>硬件加速有可能FrameBuffer硬件缓冲区直接分配内存，软件加速都是SurfaceFlinger分配的内存</li><li>在App端的绘制流程不同</li></ol><h2 id="软硬件加速的分歧点在哪？"><a href="#软硬件加速的分歧点在哪？" class="headerlink" title="软硬件加速的分歧点在哪？"></a>软硬件加速的分歧点在哪？</h2><p>在ViewRootImpl的draw方法开始分歧，有个判断点如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">private void draw(boolean fullRedrawNeeded) &#123;</span><br><span class="line">    ...</span><br><span class="line">    if (!dirty.isEmpty() || mIsAnimating || accessibilityFocusDirty) &#123;</span><br><span class="line">        &lt;!--关键点1 是否开启硬件加速--&gt;</span><br><span class="line">        if (mAttachInfo.mHardwareRenderer != null &amp;&amp; mAttachInfo.mHardwareRenderer.isEnabled()) &#123;</span><br><span class="line">             ...</span><br><span class="line">            dirty.setEmpty();</span><br><span class="line">            mBlockResizeBuffer = false;</span><br><span class="line">            &lt;!--关键点2 硬件加速绘制--&gt;</span><br><span class="line">            mAttachInfo.mHardwareRenderer.draw(mView, mAttachInfo, this);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">          ...</span><br><span class="line">           &lt;!--关键点3 软件绘制--&gt;</span><br><span class="line">            if (!drawSoftware(surface, mAttachInfo, xOffset, yOffset, scalingRequired, dirty)) &#123;</span><br><span class="line">                return;</span><br><span class="line">            &#125;</span><br><span class="line">        ...</span><br></pre></td></tr></table></figure><ol><li>4.+的手机一般都是支持硬件加速</li><li>在添加窗口时，ViewRootImpl会enableHardwareAcceleration开启硬件加速，并初始化硬件加速环境</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">private void enableHardwareAcceleration(WindowManager.LayoutParams attrs) &#123;</span><br><span class="line"></span><br><span class="line">    &lt;!--根据配置，获取硬件加速的开关--&gt;</span><br><span class="line">    // Try to enable hardware acceleration if requested</span><br><span class="line">    final boolean hardwareAccelerated =</span><br><span class="line">            (attrs.flags &amp; WindowManager.LayoutParams.FLAG_HARDWARE_ACCELERATED) != 0;</span><br><span class="line">   if (hardwareAccelerated) &#123;</span><br><span class="line">        ...</span><br><span class="line">            &lt;!--新建硬件加速图形渲染器--&gt;</span><br><span class="line">            mAttachInfo.mHardwareRenderer = HardwareRenderer.create(mContext, translucent);</span><br><span class="line">            if (mAttachInfo.mHardwareRenderer != null) &#123;</span><br><span class="line">                mAttachInfo.mHardwareRenderer.setName(attrs.getTitle().toString());</span><br><span class="line">                mAttachInfo.mHardwareAccelerated =</span><br><span class="line">                        mAttachInfo.mHardwareAccelerationRequested = true;</span><br><span class="line">            &#125;</span><br><span class="line">        ...</span><br></pre></td></tr></table></figure><p>需要硬件加速就利用HardwareRenderer进行draw，否则走软件绘制流程的drawSoftware，就是上一篇讲过的利用Surface.lockCanvas, 向SurfaceFlinger申请一块匿名共享内存分配，同时获取一个普通的SkiaCanvas（2d），用于调用Skia库，并进行图形绘制。</p><p>软件绘制如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">private boolean drawSoftware(Surface surface, AttachInfo attachInfo, int xoff, int yoff,</span><br><span class="line">            boolean scalingRequired, Rect dirty) &#123;</span><br><span class="line">        final Canvas canvas;</span><br><span class="line">        try &#123;</span><br><span class="line">            &lt;!--关键点1 --&gt;</span><br><span class="line">            canvas = mSurface.lockCanvas(dirty);</span><br><span class="line">            ..</span><br><span class="line">            &lt;!--关键点2 绘制--&gt;</span><br><span class="line">             mView.draw(canvas);</span><br><span class="line">             ..</span><br><span class="line">             关键点3 通知SurfaceFlinger进行图层合成</span><br><span class="line">                surface.unlockCanvasAndPost(canvas);</span><br><span class="line">            &#125;   ...        </span><br><span class="line">           return true;  </span><br><span class="line">           &#125;</span><br></pre></td></tr></table></figure><h2 id="硬件加速分为哪两个阶段？"><a href="#硬件加速分为哪两个阶段？" class="headerlink" title="硬件加速分为哪两个阶段？"></a>硬件加速分为哪两个阶段？</h2><ol><li>构建阶段    ，递归遍历所有视图，将需要的操作缓存下来，之后再交给单独的Render线程利用OpenGL渲染。</li><li>绘制阶段    ，View视图被抽象成一个个DrawOp(DisplayListOp)，比如View中drawLine，构建中就会被抽象成一个DrawLintOp，每个DrawOp有对应的OpenGL绘制命令，同时内部也握着绘图所需要的数据。</li></ol><p>如下图所示：</p><p><img src="https://note.youdao.com/yws/api/personal/file/WEB780ed116c9ad80aac7355683579ac6b3?method=download&amp;shareKey=1d86c23836b1aef7a346b70867ebaed7" alt=""></p><h2 id="绘制上硬件加速有什么优势？"><a href="#绘制上硬件加速有什么优势？" class="headerlink" title="绘制上硬件加速有什么优势？"></a>绘制上硬件加速有什么优势？</h2><p>绘制时，软件绘制，View一般都在主线程中完成绘制。而硬件加速，一般都是在单独线程中完成绘制，如此一来，就分担了主线程很多压力，提高了UI线程的响应速度。</p><p><img src="https://note.youdao.com/yws/api/personal/file/WEBc61c3f0d1d6ca85681e5a958766fd507?method=download&amp;shareKey=c84c51a991f5d9cb61c38118ba2d1a9f" alt=""></p><h2 id="硬件加速的HardWareRenderer是如何构建DrawOp集的？"><a href="#硬件加速的HardWareRenderer是如何构建DrawOp集的？" class="headerlink" title="硬件加速的HardWareRenderer是如何构建DrawOp集的？"></a>硬件加速的HardWareRenderer是如何构建DrawOp集的？</h2><p>HardWareRenderer是硬件加速绘制的入口，实现是一个ThreadedRenderer对象，跟一个Render线程息息相关，不过ThreadedRenderer是在UI线程中创建的，作用如下：</p><ul><li><ol><li>在UI线程中完成DrawOp集的构建</li></ol></li><li><ol start="2"><li>负责跟渲染线程通信</li></ol></li></ul><p>ThreadedRenderer RenderProxy ——&gt; RenderThread 单例线程，不会出现多线程并发访问冲突的问题 ——&gt; ThreadedRenderer的draw函数 ——&gt; updateRootDisplayList构建RootDisplayList，构建View的DrawOp树 ——&gt; 递归完成DrawOp树的构建</p><p>DisplayListCanvas及RenderNode类图如下：</p><p><img src="https://note.youdao.com/yws/api/personal/file/WEBc56e6da15a3544ff72ae846efc8bfdbe?method=download&amp;shareKey=72f595155a380c480e270021677be648" alt=""></p><p>完成DrawOp树构建之后，可以利用RenderProxy向RenderThread发送消息，请求OpenGL线程进行渲染。</p><p><img src="https://note.youdao.com/yws/api/personal/file/WEB4b34e2323dbd8f62b7c73b679003ba3b?method=download&amp;shareKey=2d10769b0f602b420b8cbced7b1858c3" alt=""></p><h2 id="RenderThread如何渲染UI到Graphic-Buffer"><a href="#RenderThread如何渲染UI到Graphic-Buffer" class="headerlink" title="RenderThread如何渲染UI到Graphic Buffer?"></a>RenderThread如何渲染UI到Graphic Buffer?</h2><p>在DrawOp树构建完毕之后，开始渲染，大致流程如下：</p><ul><li>首先进行DrawOp的合并</li><li>接着绘制特殊的Layer</li><li>最后绘制其余所有的DrawOpList</li><li>调用swapBuffers将前面已经绘制好的图形缓冲区提交给Surface Flinger合成和显示</li></ul><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>软件绘制同硬件合成的区别主要是在绘制上，内存分配、合成等整体流程是一样的，只不过硬件加速相比软件绘制算法更加合理，同时减轻了主线程的负担。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Android窗口管理分析（五）-——-硬件加速和软件加速的区别&quot;&gt;&lt;a href=&quot;#Android窗口管理分析（五）-——-硬件加速和软件加速的区别&quot; class=&quot;headerlink&quot; title=&quot;Android窗口管理分析（五） —— 硬件加速和软件加
      
    
    </summary>
    
      <category term="framework" scheme="http://skyacer.github.io/categories/framework/"/>
    
    
      <category term="View" scheme="http://skyacer.github.io/tags/View/"/>
    
  </entry>
  
  <entry>
    <title>Android窗口管理分析（四）—— Android View绘制图层内存的分配、传递、使用</title>
    <link href="http://skyacer.github.io/2018/07/20/Android%E7%AA%97%E5%8F%A3%E7%AE%A1%E7%90%86%E5%88%86%E6%9E%90%EF%BC%88%E5%9B%9B%EF%BC%89%E2%80%94%E2%80%94%20Android-View%E7%BB%98%E5%88%B6%E5%9B%BE%E5%B1%82%E5%86%85%E5%AD%98%E7%9A%84%E5%88%86%E9%85%8D%E3%80%81%E4%BC%A0%E9%80%92%E3%80%81%E4%BD%BF%E7%94%A8/"/>
    <id>http://skyacer.github.io/2018/07/20/Android窗口管理分析（四）—— Android-View绘制图层内存的分配、传递、使用/</id>
    <published>2018-07-20T06:19:00.000Z</published>
    <updated>2018-07-30T06:56:17.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Android窗口管理分析（四）——-Android-View绘制图层内存的分配、传递、使用"><a href="#Android窗口管理分析（四）——-Android-View绘制图层内存的分配、传递、使用" class="headerlink" title="Android窗口管理分析（四）—— Android View绘制图层内存的分配、传递、使用"></a>Android窗口管理分析（四）—— Android View绘制图层内存的分配、传递、使用</h1><blockquote><p>本文来看Android是怎么利用Ashmem分配及绘制的</p></blockquote><h2 id="View视图内存是怎么分配的？"><a href="#View视图内存是怎么分配的？" class="headerlink" title="View视图内存是怎么分配的？"></a>View视图内存是怎么分配的？</h2><p>添加窗口时，WMS为APP分配一个WindowState，标识当前窗口用于窗口管理，</p><p>Surface握有一块可以绘图的内存，这块内存是APP端需要的时候，通过sp GraphicBufferProducer申请的。</p><h3 id="如何获得sp-gdp这个服务代理？"><a href="#如何获得sp-gdp这个服务代理？" class="headerlink" title="如何获得sp gdp这个服务代理？"></a>如何获得sp gdp这个服务代理？</h3><p>在createNormalLayer中，建立了一个sp gbp容器 ——&gt; 请求SurfaceFlinger分配填充内容 ——&gt; SurfaceFlinger收到请求后为WMS建立与APP端对应的Layer ——&gt; 分配sp gbp ——&gt; 填充到Surface中返回给APP</p><h3 id="APP端如何获得申请内存的句柄BpGraphicBufferProducer？"><a href="#APP端如何获得申请内存的句柄BpGraphicBufferProducer？" class="headerlink" title="APP端如何获得申请内存的句柄BpGraphicBufferProducer？"></a>APP端如何获得申请内存的句柄BpGraphicBufferProducer？</h3><p>BufferQueueProducer是一个Binder通信对象，在服务端是BnGraphicBufferProducer，在App端是BpInterface<igraphicbufferproducer>{}</igraphicbufferproducer></p><p>SurfaceFlinger创建Binder实体 ——&gt; 打包Surface对象 ——&gt; 通过binder通信传递给APP端 ——&gt; APP端通过反序列化将其恢复出来——&gt; APP端获得了申请内存句柄BpGraphicBufferProducer </p><h3 id="BpGraphicBufferProducer有什么作用呢？"><a href="#BpGraphicBufferProducer有什么作用呢？" class="headerlink" title="BpGraphicBufferProducer有什么作用呢？"></a>BpGraphicBufferProducer有什么作用呢？</h3><p>ViewRootImpl的draw ——&gt; surface.nativeLockCanvas ——&gt; Surface.dequeueBuffer ——&gt; BpGraphicBufferProducer.dequeueBuffer请求分配内存</p><p>在Linux中一切都是文件，共享内存也是文件，分配成功后，跨进程传递tmpfs临时文件的描述符fd。</p><h2 id="View绘制内存是怎么传递的？"><a href="#View绘制内存是怎么传递的？" class="headerlink" title="View绘制内存是怎么传递的？"></a>View绘制内存是怎么传递的？</h2><p>fd利用Binder通信传递给App进程 ——&gt; App获取fd后，将共享内存映射到自己的进程空间，进行图形绘制 ——&gt; 等到App对GraphicBuffer反序列化的时候，将共享内存mmap到当前进程空间 ——&gt; 这样进程就拿到绘制后的数据了</p><h2 id="View绘制内存是怎么使用的？"><a href="#View绘制内存是怎么使用的？" class="headerlink" title="View绘制内存是怎么使用的？"></a>View绘制内存是怎么使用的？</h2><p>当内存经过反序列化，拿到内存地址后 ——&gt; 封装一个ANativeWindow_Buffer给上层调用  ——&gt; 对于2d绘图，利用skia库填充Bitmap对应的共享内存 ——&gt; 绘制完成 ——&gt; 通过unlock通知SurfaceFlinger服务进行图层合成</p><h2 id="Android-View局部重绘的原理是什么？"><a href="#Android-View局部重绘的原理是什么？" class="headerlink" title="Android View局部重绘的原理是什么？"></a>Android View局部重绘的原理是什么？</h2><p>lockCanvas ——&gt; 判断buffer宽高格式是否一致 ——&gt; 如果一致则进行数据拷贝 ——&gt; 如果不一致则整块绘制 ——&gt; 将绘制UI数据拷贝到申请内存中 ——&gt; 在拷贝数据中进行脏区域重绘</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Android窗口管理分析（四）——-Android-View绘制图层内存的分配、传递、使用&quot;&gt;&lt;a href=&quot;#Android窗口管理分析（四）——-Android-View绘制图层内存的分配、传递、使用&quot; class=&quot;headerlink&quot; title=&quot;
      
    
    </summary>
    
      <category term="framework" scheme="http://skyacer.github.io/categories/framework/"/>
    
    
      <category term="View" scheme="http://skyacer.github.io/tags/View/"/>
    
  </entry>
  
  <entry>
    <title>Android窗口管理分析（三）：WMS窗口的组织形式</title>
    <link href="http://skyacer.github.io/2018/07/03/Android%E7%AA%97%E5%8F%A3%E7%AE%A1%E7%90%86%E5%88%86%E6%9E%90%EF%BC%88%E4%B8%89%EF%BC%89%E2%80%94%E2%80%94%20WMS%E7%AA%97%E5%8F%A3%E7%9A%84%E7%BB%84%E7%BB%87%E5%BD%A2%E5%BC%8F/"/>
    <id>http://skyacer.github.io/2018/07/03/Android窗口管理分析（三）—— WMS窗口的组织形式/</id>
    <published>2018-07-03T07:24:37.000Z</published>
    <updated>2018-07-30T06:37:01.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Android窗口管理分析（三）：WMS窗口的组织形式"><a href="#Android窗口管理分析（三）：WMS窗口的组织形式" class="headerlink" title="Android窗口管理分析（三）：WMS窗口的组织形式"></a>Android窗口管理分析（三）：WMS窗口的组织形式</h1><blockquote><p>本文总共包括以下几点：</p><ul><li>窗口的分组管理：应用窗口组、子窗口组、系统窗口组</li><li>Activity、Dialg应用窗口及PopWindow子窗口的添加原理跟注意事项</li><li>窗口的Z次序管理：窗口的分配序号、次序调整等</li><li>WMS中窗口次序分配如何影响SurfaceFlinger服务</li></ul></blockquote><h2 id="各种窗口type和窗口类型的对应关系是什么样的？"><a href="#各种窗口type和窗口类型的对应关系是什么样的？" class="headerlink" title="各种窗口type和窗口类型的对应关系是什么样的？"></a>各种窗口type和窗口类型的对应关系是什么样的？</h2><h3 id="窗口和对应类型"><a href="#窗口和对应类型" class="headerlink" title="窗口和对应类型"></a>窗口和对应类型</h3><table><thead><tr><th>窗口type值</th><th>窗口类型</th></tr></thead><tbody><tr><td>FIRST_APPLICATION_WINDOW=1</td><td>开始应用程序窗口</td></tr><tr><td>TYPE_BASE_APPLICATION=1</td><td>所有程序窗口的base窗口，其他应用程序都显示在它上面</td></tr><tr><td>TYPE_APPLICATION=2</td><td>普通应用程序窗口，token必须设置为Activity的token</td></tr><tr><td>TYPE_APPLICATION_STARTING=3</td><td>应用程序启动时所显示的窗口</td></tr><tr><td>LAST_APPLICATION_WINDOW=99</td><td>结束应用程序窗口</td></tr></tbody></table><p>一般Activity都是TYPE_BASE_APPLICATION类型的，而TYPE_APPLICATION主要是用于Dialog，再看下子窗口类型</p><h3 id="子窗口和对应类型"><a href="#子窗口和对应类型" class="headerlink" title="子窗口和对应类型"></a>子窗口和对应类型</h3><table><thead><tr><th>窗口type值</th><th>窗口类型</th></tr></thead><tbody><tr><td>FIRST_SUB_WINDOW=1000</td><td>SubWindows子窗口，子窗口的Z序和坐标空间</td></tr><tr><td>TYPE_APPLICATION_PANEL =1000</td><td>面板窗口，显示于宿主窗口的上层</td></tr><tr><td>TYPE_APPLICATION_MEDIA=1001</td><td>媒体窗口（例如视频），显示于宿主窗口下层</td></tr><tr><td>TYPE_APPLICATION_SUB_PANEL=1002</td><td>应用程序窗口的子面板，显示于所有面板窗口的上层</td></tr><tr><td>TYPE_APPLICATION_ATTACHED_DIALOG=1003</td><td>对话框，类似于面板窗口，显示于所有面板窗口的上层</td></tr><tr><td>TYPE_APPLICATION_MEDIA_OVERLAY=1004</td><td>媒体信息，显示在媒体层和程序窗口之间，需要实现半透明效果</td></tr><tr><td>LAST_SUB_WINDOW=1999</td><td>结束子窗口</td></tr></tbody></table><h3 id="系统窗口类型"><a href="#系统窗口类型" class="headerlink" title="系统窗口类型"></a>系统窗口类型</h3><table><thead><tr><th>窗口type值</th><th>窗口类型</th></tr></thead><tbody><tr><td>FIRST_SYSTEM_WINDOW=2000</td><td>系统窗口</td></tr><tr><td>TYPE_STATUS_BAR=FIRST_SYSTEM_WINDOW</td><td>状态栏</td></tr><tr><td>TYPE_SYSTEM_ALERT=FIRST_SYSTEM_WINDOW+3</td><td>系统提示，出现在应用程序窗口之上</td></tr><tr><td>TYPE_TOAST=FIRST_SYSTEM_WINDOW+5</td><td>显示Toast</td></tr></tbody></table><h2 id="窗口的分组原理是什么样的？"><a href="#窗口的分组原理是什么样的？" class="headerlink" title="窗口的分组原理是什么样的？"></a>窗口的分组原理是什么样的？</h2><p><strong>Android的窗口是以token来分组的</strong></p><p>windowToken包含一个WindowList，包含一系列的WindowState</p><p><img src="https://note.youdao.com/yws/api/personal/file/WEB48b062a332232b68f2f86836f1d854dc?method=download&amp;shareKey=694d04d38e9b2467955b50a465d38a4d" alt="windowtoken"></p><h2 id="Activity对应token和WindowToken的添加过程是什么样的？"><a href="#Activity对应token和WindowToken的添加过程是什么样的？" class="headerlink" title="Activity对应token和WindowToken的添加过程是什么样的？"></a>Activity对应token和WindowToken的添加过程是什么样的？</h2><ol><li>AMS将Activity的token加入WMS中，为Activity创建APPWindowToken。</li><li>Activity分组在Activity显示之前就被AMS添加到WMS中，之后AMS才会去通知App新建Activity，并将Activity的Window添加到WMS中。</li><li>启动Activity步骤：新建一个Activity，并为Activity创建一个appContext，这个Context主要是为了activity.attach使用的，其实是单纯new一个ContextImpl，之后Activity会利用attach函数将ContextImpl绑定在自己身上。</li></ol><h3 id="创建ActivityContext"><a href="#创建ActivityContext" class="headerlink" title="创建ActivityContext"></a>创建ActivityContext</h3><ol><li>为Activity绑定ContextImpl，因为Activity只是一个ContextWrapper。</li><li>new一个PhoneWindow并设置回调。</li><li>利用当前的WindowManagerImpl为Window创建一个WindowManagerImpl并设置它的parentWindow。</li></ol><h3 id="setWindowManager"><a href="#setWindowManager" class="headerlink" title="setWindowManager"></a>setWindowManager</h3><ol><li>将window的WindowManager传递给Activity，作为Activity的WindowManager</li><li>Activity通过getSystemService获取WindowManager服务时，直接返回了Window的WindowManagerImpl</li></ol><h3 id="getSystemService"><a href="#getSystemService" class="headerlink" title="getSystemService"></a>getSystemService</h3><ol><li>通过需要获得的service名字返回不同manager对象。</li></ol><h3 id="handleResumeActivity"><a href="#handleResumeActivity" class="headerlink" title="handleResumeActivity"></a>handleResumeActivity</h3><ol><li>获取activity的window对象，如果用户没有通过setContentView方式新建DecorView，这里会利用PhoneWindow的getDecorView()新建DecorView，并把decorview设置为不可见。</li><li>获取windowManager以及window的各属性。添加decorview到WMS管理。</li></ol><h3 id="WindowManagerImpl的addView"><a href="#WindowManagerImpl的addView" class="headerlink" title="WindowManagerImpl的addView"></a>WindowManagerImpl的addView</h3><ol><li>最终会调用WindowManagerGlobal的addView方法</li><li>调整wparams的token参数</li><li>新建ViewRootImpl，并利用wparams参数添加窗口</li><li>ViewRootImpl设置view</li></ol><h3 id="adjustLayoutParamsForSubWindow"><a href="#adjustLayoutParamsForSubWindow" class="headerlink" title="adjustLayoutParamsForSubWindow"></a>adjustLayoutParamsForSubWindow</h3><ol><li>对于Activity来说，wp.token = mContainer其实是AMS端传过来的IApplicationToken</li><li>在ViewRootImpl中setView的时候，利用IWindowSession代理与WMS端的Session通信，将窗口及token信息传递到WMS端，其中IApplicationToken就是该Activity处于的分组</li><li>在WMS端，根据IApplicationToken IBinder键值，从全局的mTokenMap。</li></ol><h2 id="Dialog必须用Activity的context？"><a href="#Dialog必须用Activity的context？" class="headerlink" title="Dialog必须用Activity的context？"></a>Dialog必须用Activity的context？</h2><p>在添加到WMS时，Dialog窗口属性是WindowManager.LayoutParams.TYPE_APPLICATION，同样属于应用窗口，所以必须使用Activity的AppToken才可以。</p><p>Dialog和Activity共享一个同一个WindowManager（也就是WindowManagerImpl），而WindowManagerImpl里面有个Window类型的mParentWindow变量，这个变量在attach时传入当前Activity的Window。而Activity的Window里面的mAppToken是当前Activity的token。</p><p>所以最终是因为<strong>不能为Dialog提供正确的token</strong></p><h2 id="PopupWindow的子窗口添加流程是什么样的？"><a href="#PopupWindow的子窗口添加流程是什么样的？" class="headerlink" title="PopupWindow的子窗口添加流程是什么样的？"></a>PopupWindow的子窗口添加流程是什么样的？</h2><p>WMS为PopupWindow窗口创建一个子窗口分组WindowToken，每个子窗口都会有一个指向父窗口的引用，因为是利用父窗口IWindow作为键值，父窗口可以方便利用IWindow获取WindowToken，存入map中，进而得到全部的子窗口。</p><h2 id="窗口的Z次序管理是什么样的？"><a href="#窗口的Z次序管理是什么样的？" class="headerlink" title="窗口的Z次序管理是什么样的？"></a>窗口的Z次序管理是什么样的？</h2><p><img src="https://note.youdao.com/yws/api/personal/file/WEBf6552df5db0595bc726979ae4867e135?method=download&amp;shareKey=81992d5eb5b019920186bbbf1f7ef162" alt="Z序列坐标系"></p><p>在WMS中，窗口被抽象成WindowState，采用了三个int值来标志窗口所在位置。前两个主要根据窗口类型确定窗口位置，mLayer才是真正的值。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">final class WindowState implements WindowManagerPolicy.WindowState &#123;</span><br><span class="line">    </span><br><span class="line">    final WindowList mChildWindows = new WindowList();</span><br><span class="line">    final int mBaseLayer;</span><br><span class="line">    final int mSubLayer;</span><br><span class="line">     &lt;!--最终Z次序的赋值--&gt;</span><br><span class="line">   int mLayer;</span><br><span class="line">    </span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>由于前两个都是final修饰的，所以只有最后一个值可以改。</p><p>从坐标系知道，值越大，窗口越靠上。</p><p>对于Activity等应用窗口来说，主序都是一样的，怎么定他们真正的Z-order呢？其实是Activity的顺序由AMS来保证的。</p><p><strong>在系统层面，决定了不同类型窗口所处的位置，比如系统Toast类型的窗口一定处于所有应用窗口之上</strong></p><p>添加窗口的示意代码如下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">addWindow()&#123;</span><br><span class="line">    &lt;!--1--&gt;</span><br><span class="line">    new WindowState</span><br><span class="line">    &lt;!--2--&gt;</span><br><span class="line">    addWindowToListInOrderLocked(win, true);</span><br><span class="line">    &lt;!--3--&gt;</span><br><span class="line">    assignLayersLocked(displayContent.getWindowList());</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>Z-order通过addWindowToListInOrderLocked及assignLayersLocked才能确定</p><ol><li><p>第一步，new一个windowstate实例。</p></li><li><p>第二步，addWindowToListInOrderLocked主要根据窗口的Token找到归属，插入到对应Token的WindowState列表，插入到特定位置后，Z-order就确定了。</p></li><li><p>第三步，通过assignLayersLocked为WindowState分配真正的Z-order mLayer。</p></li></ol><p><img src="https://note.youdao.com/yws/api/personal/file/WEB438789e52f069cecb59102d2508a6d8c?method=download&amp;shareKey=dbd6fec50b6c1f847a3798dd6b6b17d8" alt=""></p><p>当mLayer(int)确定后，这个顺序最终确定，之后，在SurfaceFlinger图层混排的时候处理。</p><h2 id="WMS中窗口次序分配如何影响SurfaceFlinger服务？"><a href="#WMS中窗口次序分配如何影响SurfaceFlinger服务？" class="headerlink" title="WMS中窗口次序分配如何影响SurfaceFlinger服务？"></a>WMS中窗口次序分配如何影响SurfaceFlinger服务？</h2><p>SurfaceFlinger图层混排的时候不会混排所有的窗口，只会混排可见的窗口，比如有多个全屏Activity的时候，SurfaceFlinger只会处理最上面的。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">SurfaceControl.openTransaction();</span><br><span class="line">          try &#123;</span><br><span class="line">              mSurfaceX = left;</span><br><span class="line">              mSurfaceY = top;</span><br><span class="line">               try &#123;</span><br><span class="line">                  mSurfaceControl.setPosition(left, top);</span><br><span class="line">                  mSurfaceLayer = mAnimLayer;</span><br><span class="line">                  final DisplayContent displayContent = w.getDisplayContent();</span><br><span class="line">                  if (displayContent != null) &#123;</span><br><span class="line">                      mSurfaceControl.setLayerStack(displayContent.getDisplay().getLayerStack());</span><br><span class="line">                  &#125;</span><br><span class="line">                  &lt;!--设置次序--&gt;</span><br><span class="line">                  mSurfaceControl.setLayer(mAnimLayer);</span><br><span class="line">                  mSurfaceControl.setAlpha(0);</span><br><span class="line">                  mSurfaceShown = false;</span><br><span class="line">              &#125; catch (RuntimeException e) &#123;</span><br><span class="line">                  mService.reclaimSomeSurfaceMemoryLocked(this, &quot;create-init&quot;, true);</span><br><span class="line">              &#125;</span><br><span class="line">              mLastHidden = true;</span><br><span class="line">          &#125; finally &#123;</span><br><span class="line">              SurfaceControl.closeTransaction();</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure><p>通过事务来确保完整性，包括surface次序调整，通知SurfaceFlinger更新Surface信息。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Android窗口管理分析（三）：WMS窗口的组织形式&quot;&gt;&lt;a href=&quot;#Android窗口管理分析（三）：WMS窗口的组织形式&quot; class=&quot;headerlink&quot; title=&quot;Android窗口管理分析（三）：WMS窗口的组织形式&quot;&gt;&lt;/a&gt;Andro
      
    
    </summary>
    
      <category term="framework" scheme="http://skyacer.github.io/categories/framework/"/>
    
    
      <category term="View" scheme="http://skyacer.github.io/tags/View/"/>
    
  </entry>
  
  <entry>
    <title>Android窗口管理分析（二）——WindowManagerService图层管理之窗口的添加</title>
    <link href="http://skyacer.github.io/2018/06/09/Android%E7%AA%97%E5%8F%A3%E7%AE%A1%E7%90%86%E5%88%86%E6%9E%90%EF%BC%88%E4%BA%8C%EF%BC%89%E2%80%94%E2%80%94%20WindowManagerService%E5%9B%BE%E5%B1%82%E7%AE%A1%E7%90%86%E4%B9%8B%E7%AA%97%E5%8F%A3%E7%9A%84%E6%B7%BB%E5%8A%A0/"/>
    <id>http://skyacer.github.io/2018/06/09/Android窗口管理分析（二）—— WindowManagerService图层管理之窗口的添加/</id>
    <published>2018-06-09T10:54:07.000Z</published>
    <updated>2018-06-09T11:01:56.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Android窗口管理分析（二）——WindowManagerService图层管理之窗口的添加"><a href="#Android窗口管理分析（二）——WindowManagerService图层管理之窗口的添加" class="headerlink" title="Android窗口管理分析（二）——WindowManagerService图层管理之窗口的添加"></a>Android窗口管理分析（二）——WindowManagerService图层管理之窗口的添加</h1><blockquote><p>本文主要从以下几点分析：</p><ul><li>窗口的分类：Activity、Dialog、PopupWindow、Toast等对应窗口的区别</li><li>窗口的添加和删除</li><li>窗口的分组与窗口Z的顺序</li><li>Window、IWindow、WindowState、WindowToken、AppToken等之间的关系</li></ul></blockquote><h2 id="Android窗口大概分为几种？"><a href="#Android窗口大概分为几种？" class="headerlink" title="Android窗口大概分为几种？"></a>Android窗口大概分为几种？</h2><p>Android将窗口大致分为三类：</p><ol><li>应用窗口（拥有自己的WindowToken） 例如：Activity与Dialog</li><li>子窗口（必须依附到其他非子窗口才能存在，比如Activity等） 例如：PopupWindow</li><li>系统窗口 例如：Toast</li></ol><p>这里Dialog比较特殊，从表现上来说偏向于子窗口，必须依附到Activity才能存在，而从性质上来说，仍然是应用窗口，有自己的WindowToken。</p><p><img src="https://note.youdao.com/yws/api/personal/file/WEB057109037ca9e125198e2eead8d18b6c?method=download&amp;shareKey=9a0a33be9b12833c4e858b57b8a85175" alt=""></p><h2 id="窗口是怎么添加的？"><a href="#窗口是怎么添加的？" class="headerlink" title="窗口是怎么添加的？"></a>窗口是怎么添加的？</h2><p>以悬浮窗为例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">private void addTextViewWindow(Context context)&#123;</span><br><span class="line"></span><br><span class="line">    TextView mview=new TextView(context);</span><br><span class="line">...&lt;!--设置颜色 样式--&gt;</span><br><span class="line">&lt;!--关键点1--&gt;</span><br><span class="line">    WindowManager mWindowManager = (WindowManager) context.getApplicationContext().getSystemService(Context.WINDOW_SERVICE);</span><br><span class="line">    WindowManager.LayoutParams wmParams = new WindowManager.LayoutParams();</span><br><span class="line">    &lt;!--关键点2--&gt;</span><br><span class="line">    wmParams.type = WindowManager.LayoutParams.TYPE_TOAST;</span><br><span class="line">    wmParams.format = PixelFormat.RGBA_8888;</span><br><span class="line">    wmParams.width = 800;</span><br><span class="line">    wmParams.height = 800;</span><br><span class="line">    &lt;!--关键点3--&gt;</span><br><span class="line">    mWindowManager.addView(mview, wmParams);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://note.youdao.com/yws/api/personal/file/WEB9f0d62cfec2b9b86ad69ce5a2c1d5d5f?method=download&amp;shareKey=141858c3f2650257f1d92749d015eb66" alt="流程图"></p><h2 id="WindowToken是什么样的？"><a href="#WindowToken是什么样的？" class="headerlink" title="WindowToken是什么样的？"></a>WindowToken是什么样的？</h2><p>首先需要知道下面一些概念：</p><ul><li>IWindow： APP端窗口暴露给WMS的抽象实例，同时也是WMS向APP端发送消息的Binder通道。</li><li>WindowState：WMS端窗口的令牌，与IWindow窗口一一对应，是WMS管理窗口的重要依据。</li><li>WindowToken：是窗口的令牌，也是窗口分组的依据，在WMS端，和分组对应的数据结构是WindowToken</li><li>AppToken：是ActivityRecord里面的IApplicationToken.Stub appToken代理。</li></ul><p><img src="https://note.youdao.com/yws/api/personal/file/WEB48b062a332232b68f2f86836f1d854dc?method=download&amp;shareKey=694d04d38e9b2467955b50a465d38a4d" alt=""></p><p>Activity与Dialog对应的是AppWindowToken，PopupWindow对应的是普通的WindowToken。</p><h2 id="Session和App进程对应关系是什么样的？"><a href="#Session和App进程对应关系是什么样的？" class="headerlink" title="Session和App进程对应关系是什么样的？"></a>Session和App进程对应关系是什么样的？</h2><p><img src="https://note.youdao.com/yws/api/personal/file/WEBa1d0149bfa323db501e5a50e9943f40d?method=download&amp;shareKey=702e142fb9d4e9a4de6d6fc0dfc945cd" alt=""></p><ol><li>Session与App进程一一对应，进一步为当前进程建立SurfaceSession会话。</li><li>Session是App同WMS通信的通道，SurfaceSession是WMS为SurfaceFlinger申请的通信通道，SurfaceSession与APP也是一一对应的。</li><li>SurfaceSession的SurfaceFlinger代理就是SurfaceComposerClient里的ISurfaceComposerClient mClient对象，它是SurfaceFlinger为每个APP封装的一个代理。</li></ol><h2 id="ISurfaceComposerClient是怎么一步步创建的？"><a href="#ISurfaceComposerClient是怎么一步步创建的？" class="headerlink" title="ISurfaceComposerClient是怎么一步步创建的？"></a>ISurfaceComposerClient是怎么一步步创建的？</h2><p><img src="https://note.youdao.com/yws/api/personal/file/WEB83a988108f7640d3f3da543ac13c9d6e?method=download&amp;shareKey=8cf63d1649205192dbb11c052d9c06e0" alt=""></p><p>利用ComposerService这样的单例对象为每个App在WMS申请一个ISurfaceComposerClient对象。在WMS端表现为BPSurfaceComposerClient，在SurfaceFlinger端表现为BnSurfaceComposerClient。</p><h2 id="postSyncBarrier-有什么用？在ViewRootImpl的setView中的应用是什么样的？"><a href="#postSyncBarrier-有什么用？在ViewRootImpl的setView中的应用是什么样的？" class="headerlink" title="postSyncBarrier()有什么用？在ViewRootImpl的setView中的应用是什么样的？"></a>postSyncBarrier()有什么用？在ViewRootImpl的setView中的应用是什么样的？</h2><p>这个挡板是用来阻塞同步消息的，在挡板撤销之前，只会执行异步消息。在ViewRootImpl的setView中，目的是保证在mTraversalRunnable的所有同步Message之前被执行，保证View绘制的最高优先级。</p><h2 id="performTraversals函数主要作用是什么？"><a href="#performTraversals函数主要作用是什么？" class="headerlink" title="performTraversals函数主要作用是什么？"></a>performTraversals函数主要作用是什么？</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">private void performTraversals() &#123;</span><br><span class="line">    final View host = mView;</span><br><span class="line">   ...</span><br><span class="line">    if (mFirst || windowShouldResize || insetsChanged ||</span><br><span class="line">            viewVisibilityChanged || params != null) &#123;</span><br><span class="line">            &lt;!--关键点1 申请Surface或者重新设置参数--&gt;</span><br><span class="line">            relayoutResult = relayoutWindow(params, viewVisibility, insetsPending);</span><br><span class="line">          &lt;!--关键点2 测量--&gt;</span><br><span class="line">                performMeasure(childWidthMeasureSpec, childHeightMeasureSpec);</span><br><span class="line">            &#125;        </span><br><span class="line">          &lt;!--关键点3 布局--&gt;</span><br><span class="line">                performLayout(lp, desiredWindowWidth, desiredWindowHeight);</span><br><span class="line">           &lt;!--关键点4 更新window--&gt;</span><br><span class="line">              try &#123;</span><br><span class="line">                mWindowSession.setInsets(mWindow, insets.mTouchableInsets,</span><br><span class="line">                        contentInsets, visibleInsets, touchableRegion);</span><br><span class="line">            ...</span><br><span class="line">          &lt;!--关键点5 绘制--&gt;</span><br><span class="line">           performDraw();</span><br><span class="line">           ...  </span><br><span class="line">       &#125;</span><br></pre></td></tr></table></figure><h2 id="relayout是如何向SurfaceFlinger申请Surface？"><a href="#relayout是如何向SurfaceFlinger申请Surface？" class="headerlink" title="relayout是如何向SurfaceFlinger申请Surface？"></a>relayout是如何向SurfaceFlinger申请Surface？</h2><p><img src="https://note.youdao.com/yws/api/personal/file/WEBe71e95c3cd0470eda95fccfcbe38a3d3?method=download&amp;shareKey=21aebce9d3d76fef32cb15afb840bc30" alt=""></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p><img src="https://note.youdao.com/yws/api/personal/file/WEBc3fddfc737f1b81cba23081ac3605d40?method=download&amp;shareKey=be9e6a33752602f050ac7e185c641b5f" alt="Add View整体流程"></p><ul><li>APP去WMS登记窗口</li><li>APP新建Surface壳子，请求WMS填充Surface</li><li>WMS请求SurfaceFlinger分配窗口图层</li><li>SurfaceFlinger分配Layer，将结果回传给WMS</li><li>WMS将窗口信息填充到Surface传输到APP</li><li>APP端获得填充信息，获取与SurfaceFlinger通信的能力</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Android窗口管理分析（二）——WindowManagerService图层管理之窗口的添加&quot;&gt;&lt;a href=&quot;#Android窗口管理分析（二）——WindowManagerService图层管理之窗口的添加&quot; class=&quot;headerlink&quot; tit
      
    
    </summary>
    
      <category term="framework" scheme="http://skyacer.github.io/categories/framework/"/>
    
    
      <category term="View" scheme="http://skyacer.github.io/tags/View/"/>
    
  </entry>
  
  <entry>
    <title>快速排序简单实现</title>
    <link href="http://skyacer.github.io/2018/06/05/%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F%E7%AE%80%E5%8D%95%E5%AE%9E%E7%8E%B0/"/>
    <id>http://skyacer.github.io/2018/06/05/快速排序简单实现/</id>
    <published>2018-06-05T12:24:23.000Z</published>
    <updated>2018-06-05T12:25:32.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="快速排序简单实现"><a href="#快速排序简单实现" class="headerlink" title="快速排序简单实现"></a>快速排序简单实现</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line">public class QuickSort &#123;</span><br><span class="line"></span><br><span class="line">    public static int partition(int[] arr, int low, int high)&#123;</span><br><span class="line">        if (arr == null || low &gt;= arr.length || low &lt; 0 || high &gt;= arr.length || high &lt; 0)&#123;</span><br><span class="line">            return -1;//错误入参</span><br><span class="line">        &#125;</span><br><span class="line">        int pivotPos = low;</span><br><span class="line">        int pivot = arr[low];</span><br><span class="line">        while(low &lt; high)&#123;</span><br><span class="line">            while (low &lt; high &amp;&amp; arr[high] &gt;= pivot)&#123;</span><br><span class="line">                high--;</span><br><span class="line">            &#125;</span><br><span class="line">            while (low &lt; high &amp;&amp; arr[low] &lt;= pivot)&#123;</span><br><span class="line">                low++;</span><br><span class="line">            &#125;</span><br><span class="line">            if (low &lt; high) &#123;</span><br><span class="line">                swap(arr, low, high);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        swap(arr, pivotPos, low);</span><br><span class="line">        return low;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    public static void swap(int arr[], int a, int b)&#123;</span><br><span class="line">        if (a &gt;= arr.length || a &lt; 0 || b &gt;= arr.length || b &lt; 0)&#123;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        int temp = arr[a];</span><br><span class="line">        arr[a] = arr[b];</span><br><span class="line">        arr[b] = temp;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void quickSort(int[] arr, int low, int high)&#123;</span><br><span class="line">    //递归实现</span><br><span class="line">         if (arr == null || low &lt; 0 || high &lt;= 0 || low&gt;high)</span><br><span class="line">                return;</span><br><span class="line">         int k = partition(arr, low, high);</span><br><span class="line">        if (k &lt; high)&#123;</span><br><span class="line">            quickSort(arr, k+1, high);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if (k &gt; low)&#123;</span><br><span class="line">            quickSort(arr, low ,k-1);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public static void quickSortNonRecursion(int[] arr, int low, int high)&#123;</span><br><span class="line">    //非递归，使用stack保存partition返回值</span><br><span class="line">           if (arr == null || low &lt; 0 || high &lt;= 0 || low&gt;high)</span><br><span class="line">               return;</span><br><span class="line">           Stack&lt;Integer&gt; temp = new Stack&lt;&gt;();</span><br><span class="line">           int i, j;</span><br><span class="line">           //（注意保存顺序）先将初始状态的左右指针压栈</span><br><span class="line">           temp.push(high);//先存右指针</span><br><span class="line">           temp.push(low);//再存左指针</span><br><span class="line">           while (!temp.empty()) &#123;</span><br><span class="line">               i = temp.pop();//先弹出左指针</span><br><span class="line">               j = temp.pop();//再弹出右指针</span><br><span class="line">               if (i &lt; j) &#123;</span><br><span class="line">                   int k = partition(arr, i, j);</span><br><span class="line">                   if (k &gt; i) &#123;</span><br><span class="line">                       temp.push(k - 1);//保存中间变量</span><br><span class="line">                       temp.push(i);  //保存中间变量</span><br><span class="line">                   &#125;</span><br><span class="line">                   if (j &gt; k) &#123;</span><br><span class="line">                       temp.push(j);</span><br><span class="line">                       temp.push(k + 1);</span><br><span class="line">                   &#125;</span><br><span class="line">               &#125;</span><br><span class="line"></span><br><span class="line">           &#125;</span><br><span class="line">           &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    public static void main(String[] args)&#123;</span><br><span class="line">        int[] arr = &#123;8,4,5,1,3,66,6,6&#125;;</span><br><span class="line">        quickSort(arr, 0, arr.length-1);</span><br><span class="line"></span><br><span class="line">        for (int i : arr)&#123;</span><br><span class="line">            System.out.println(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;快速排序简单实现&quot;&gt;&lt;a href=&quot;#快速排序简单实现&quot; class=&quot;headerlink&quot; title=&quot;快速排序简单实现&quot;&gt;&lt;/a&gt;快速排序简单实现&lt;/h1&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td cl
      
    
    </summary>
    
      <category term="基础知识" scheme="http://skyacer.github.io/categories/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    
    
      <category term="数据结构与算法" scheme="http://skyacer.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>简单易懂的堆排序</title>
    <link href="http://skyacer.github.io/2018/05/27/%E7%AE%80%E5%8D%95%E6%98%93%E6%87%82%E7%9A%84%E5%A0%86%E6%8E%92%E5%BA%8F/"/>
    <id>http://skyacer.github.io/2018/05/27/简单易懂的堆排序/</id>
    <published>2018-05-27T11:11:30.000Z</published>
    <updated>2018-06-05T12:25:24.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="简单易懂的堆排序"><a href="#简单易懂的堆排序" class="headerlink" title="简单易懂的堆排序"></a>简单易懂的堆排序</h1><p>网上已经有很多文章都在介绍堆排序的原理，这里记录下比较容易理解的代码思路，通过元素下沉的方式，构建大根堆，以及将首尾元素互换后的调整过程。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line">public class HeapSort &#123;</span><br><span class="line">    public static void main(String []args)&#123;</span><br><span class="line">        int []arr = &#123;8,9,6,5,10,2,3,2,1&#125;;</span><br><span class="line">        sort(arr);</span><br><span class="line">        System.out.println(Arrays.toString(arr));</span><br><span class="line">    &#125;</span><br><span class="line">    public static void sort(int []arr)&#123;</span><br><span class="line">        //1.构建大顶堆</span><br><span class="line">        for(int i=(arr.length-1)/2;i&gt;=0;i--)&#123;</span><br><span class="line">            //从第一个非叶子结点从下至上，从右至左调整结构</span><br><span class="line">            nodeDown(arr,i,arr.length);</span><br><span class="line">        &#125;</span><br><span class="line">        //2.调整堆结构+交换堆顶元素与末尾元素</span><br><span class="line">        for(int j=arr.length-1;j&gt;0;j--)&#123;</span><br><span class="line">            swap(arr,0,j);//将堆顶元素与末尾元素进行交换</span><br><span class="line">            nodeDown(arr,0,j);//重新对堆进行调整</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 调整大顶堆（仅是调整过程，建立在大顶堆已构建的基础上),即元素下沉,对于2i+1为左子节点</span><br><span class="line">     * 2i+2为右子节点,在子节点中找出最大的一个,并交换,如此一步步下沉到最底部</span><br><span class="line">     * @param arr</span><br><span class="line">     * @param i 需要调整的节点序列</span><br><span class="line">     * @param length</span><br><span class="line">     */</span><br><span class="line">    public static void nodeDown(int []arr, int i, int length)&#123;</span><br><span class="line">        for(int k=i*2+1;k&lt;length;k=k*2+1)&#123;//从i结点的左子结点开始，也就是2i+1处开始</span><br><span class="line">            int temp = arr[i];//先取出当前元素i</span><br><span class="line">            if(k+1&lt;length &amp;&amp; arr[k]&lt;arr[k+1])&#123;//如果左子结点小于右子结点，k指向右子结点</span><br><span class="line">                k++;</span><br><span class="line">            &#125;</span><br><span class="line">            if(arr[k] &gt;temp)&#123;//如果子节点大于父节点，将子节点值赋给父节点（不用进行交换）</span><br><span class="line">                swap(arr, i, k);</span><br><span class="line">                i = k;</span><br><span class="line">            &#125;else&#123;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 交换元素</span><br><span class="line">     * @param arr</span><br><span class="line">     * @param a</span><br><span class="line">     * @param b</span><br><span class="line">     */</span><br><span class="line">    public static void swap(int []arr,int a ,int b)&#123;</span><br><span class="line">        int temp=arr[a];</span><br><span class="line">        arr[a] = arr[b];</span><br><span class="line">        arr[b] = temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;简单易懂的堆排序&quot;&gt;&lt;a href=&quot;#简单易懂的堆排序&quot; class=&quot;headerlink&quot; title=&quot;简单易懂的堆排序&quot;&gt;&lt;/a&gt;简单易懂的堆排序&lt;/h1&gt;&lt;p&gt;网上已经有很多文章都在介绍堆排序的原理，这里记录下比较容易理解的代码思路，通过元素下沉的方式
      
    
    </summary>
    
      <category term="基础知识" scheme="http://skyacer.github.io/categories/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    
    
      <category term="数据结构与算法" scheme="http://skyacer.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>Android View分发机制及解决滑动冲突方案</title>
    <link href="http://skyacer.github.io/2018/05/26/Android-View%E5%88%86%E5%8F%91%E6%9C%BA%E5%88%B6%E5%8F%8A%E8%A7%A3%E5%86%B3%E6%BB%91%E5%8A%A8%E5%86%B2%E7%AA%81%E6%96%B9%E6%A1%88/"/>
    <id>http://skyacer.github.io/2018/05/26/Android-View分发机制及解决滑动冲突方案/</id>
    <published>2018-05-26T14:04:52.000Z</published>
    <updated>2018-05-29T08:58:06.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Android-View分发机制及解决滑动冲突方案"><a href="#Android-View分发机制及解决滑动冲突方案" class="headerlink" title="Android View分发机制及解决滑动冲突方案"></a>Android View分发机制及解决滑动冲突方案</h1><div id="article_content" class="article_content clearfix csdn-tracking-statistics" data-pid="blog" data-mod="popu_307" data-dsm="post"><br>                    <div class="markdown_views"><br>                <p></p><div class="toc"><div class="toc"><br><ul><br><li><ul><br><li><a href="#初探view事件" target="">初探View事件</a></li><br><li><a href="#事件分发" target="">事件分发</a><ul><br><li><a href="#理论知识" target="">理论知识</a></li><br><li><a href="#实战讲解" target="">实战讲解</a><ul><br><li><a href="#验证view的事件分发" target="">验证View的事件分发</a></li><br><li><a href="#验证不消耗actiondown事件" target="">验证不消耗ACTION_DOWN事件</a></li><br><li><a href="#验证-viewgroup事件拦截" target="">验证 ViewGroup事件拦截</a></li><br></ul><br></li><br><li><a href="#源码分析viewgroup" target="">源码分析ViewGroup</a><ul><br><li><a href="#activity的事件分发" target="">Activity的事件分发</a></li><br><li><a href="#viewgroup的事件拦截" target="">ViewGroup的事件拦截</a></li><br><li><a href="#viewgroup的事件分发" target="">ViewGroup的事件分发</a></li><br></ul><br></li><br></ul><br></li><br><li><a href="#view的滑动冲突" target="">View的滑动冲突</a><ul><br><li><a href="#外部拦截" target="">外部拦截</a></li><br><li><a href="#内部拦截" target="">内部拦截</a></li><br></ul><br></li><br><li><a href="#总结" target="">总结</a></li><br><iframe id="tmp_downloadhelper_iframe" style="display: none;"></iframe></ul><br></li><br></ul><br></div><br></div><br><p></p><br><br><br><br><h2 id="初探view事件"><a name="t0"></a>初探View事件</h2><br><br><p>前言View的事件分发和滑动冲突处理是老生常谈的知识了，<br>我们常说的View事件是指： 从手指亲密接触屏幕的那一刻到手指离开屏幕的这个过程，<font color="#84331f" size="4">该事件序列以down事件为起点，move事件为过程，up事件为终点</font>。 <br><br>一次down-move-up这一个事件过程我们称为一个<font color="#84331f" size="5">事件序列</font>。所以我们今天研究的对象就是<font color="#84331f" size="4">MotionEvent</font>。</p><br><br><br><br><h2 id="事件分发"><a name="t1"></a>事件分发</h2><br><br><br><br><h3 id="理论知识"><a name="t2"></a>理论知识</h3><br><br><ul><br><li><font color="#f36c21" size="4">public boolean dispatchTouchEvent(MotionEvent ev)</font> <br><br>用来分发事件，即事件序列的大门，如果事件传递到当前View的<code>onTouchEvent</code>或者是子View的<code>dispatchTouchEvent</code>，即该方法被调用了。 <br><br><font color="#f05b72">return true: </font>  表示消耗了当前事件，有可能是当前View的<code>onTouchEvent</code>或者是子View的<code>dispatchTouchEvent</code>消费了，事件终止，不再传递。 <br><br><font color="#f05b72">return false: </font> 调用父ViewGroup或则Activity的<code>onTouchEvent</code>。 （不再往下传）。<font color="#7fb80e">①另外如果不消耗ACTION_DOWN事件，那么down,move,up事件都与该View无关，交由父类处理(父类的<code>onTouchEvent</code>方法)</font> <br><br><font color="#f05b72">return super.dispatherTouchEvent:</font>  则继续往下(子View)传递，或者是调用当前View的onTouchEvent方法;</li><br></ul><br><br><p><br></p><br><br><ul><br><li><font color="#f36c21" size="4">public boolean onInterceptTouchEvent(MotionEvent ev)</font> <br><br>在<code>dispatchTouchEvent</code>内部调用，顾名思义就是判断是否拦截某个事件。(注：ViewGroup才有的方法，View因为没有子View了，所以不需要也没有该方法) <br><br><font color="#f05b72">return true: </font> ViewGroup将该事件拦截，交给自己的<code>onTouchEvent</code>处理。<font color="#7fb80e">②而且这一个事件序列（当前和其它事件）都只能由该ViewGroup处理，并且不会再调用该<code>onInterceptTouchEvent</code>方法去询问是否拦截。</font> <br><br><font color="#f05b72">return false: </font> 继续传递给子元素的<code>dispatchTouchEvent</code>处理。 <br><br><font color="#f05b72">return super.dispatherTouchEvent:</font>   事件默认不会被拦截。 </li><br></ul><br><br><p><br></p><br><br><ul><br><li><font color="#f36c21" size="4">public boolean onTouchEvent(MotionEvent ev)</font> <br><br>在<code>dispatchTouchEvent</code>内部调用 <br><br><font color="#f05b72">return true: </font> 事件消费，当前事件终止。 <br><br><font color="#f05b72">return false: </font>交给父View的<code>onTouchEvent</code>。 <br><br><font color="#f05b72">return super.dispatherTouchEvent:</font>  默认处理事件的逻辑和返回 false 时相同。</li><br></ul><br><br><p><br> <br><br>其实上面的关系可以用以下代码简单描述。</p><br><br><br><br><pre class="prettyprint" name="code"><code class="hljs java has-numbering"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">dispatchTouchEvent</span>(MotionEvent ev){<br>    <span class="hljs-keyword">boolean</span> consume = <span class="hljs-keyword">false</span>;<span class="hljs-comment">//是否消费事件</span><br>    <span class="hljs-keyword">if</span>(onInterceptTouchEvent(ev)){<span class="hljs-comment">//是否拦截事件</span><br>        consume = onTouchEvent(ev);<span class="hljs-comment">//拦截了，交给自己的View处理</span><br>    }<span class="hljs-keyword">else</span>{<br>        consume = child.dispatchTouchEvent(ev);<span class="hljs-comment">//不拦截，就交给子View处理</span><br>    }<br><br>    <span class="hljs-keyword">return</span> consume;<span class="hljs-comment">//true：消费事件，终止。false:交给父onTouchEvent处理。并不再往下传递当前事件。</span><br>}</code><ul class="pre-numbering" style=""><li style="color: rgb(153, 153, 153);">1</li><li style="color: rgb(153, 153, 153);">2</li><li style="color: rgb(153, 153, 153);">3</li><li style="color: rgb(153, 153, 153);">4</li><li style="color: rgb(153, 153, 153);">5</li><li style="color: rgb(153, 153, 153);">6</li><li style="color: rgb(153, 153, 153);">7</li><li style="color: rgb(153, 153, 153);">8</li><li style="color: rgb(153, 153, 153);">9</li><li style="color: rgb(153, 153, 153);">10</li></ul></pre><br><br><p>有图有真相</p><br><br><p></p><div> <br><br><img src="https://img-blog.csdn.net/20171121120051746?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcWlhbjUyMGFv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述" title=""></div><p></p><br><br><p>有点类似<a href="http://blog.csdn.net/qian520ao/article/details/73558275" title="optional title" target="_blank">责任链设计模式</a></p><br><br><p><br></p><br><br><h3 id="实战讲解"><a name="t3"></a>实战讲解</h3><br><br><br><br><h4 id="验证view的事件分发">验证View的事件分发</h4><br><br><ul><br><li>创建CustomViewGroup继承FrameLayout</li><br><li>创建CustomView继承View</li><br></ul><br><br><p>xml</p><br><br><br><br><pre class="prettyprint" name="code"><code class="hljs avrasm has-numbering"><br>&lt;FrameLayout xmlns:android=<span class="hljs-string">“<a href="http://schemas.android.com/apk/res/android&quot;" target="_blank" rel="noopener">http://schemas.android.com/apk/res/android&quot;</a></span><br>    xmlns:tools=<span class="hljs-string">“<a href="http://schemas.android.com/tools&quot;" target="_blank" rel="noopener">http://schemas.android.com/tools&quot;</a></span><br>    android:layout_width=<span class="hljs-string">“match_parent”</span><br>    android:layout_height=<span class="hljs-string">“match_parent”</span><br>    tools:context=<span class="hljs-string">“qdx.viewtouchevent.MainActivity”</span>&gt;<br><br>//最外层为activity（白色背景）<br>    &lt;qdx<span class="hljs-preprocessor">.viewtouchevent</span><span class="hljs-preprocessor">.CustomViewGroup</span><br>        android:layout_width=<span class="hljs-string">“300dp”</span><br>        android:layout_height=<span class="hljs-string">“400dp”</span><br>        android:layout_gravity=<span class="hljs-string">“right”</span><br>        android:background=<span class="hljs-string">“#84bf96”</span>&gt;<br>//CustomViewGroup（绿色背景）包含CustomView（黄色背景）<br>        &lt;qdx<span class="hljs-preprocessor">.viewtouchevent</span><span class="hljs-preprocessor">.CustomView</span><br>            android:layout_width=<span class="hljs-string">“150dp”</span><br>            android:layout_height=<span class="hljs-string">“300dp”</span><br>            android:layout_gravity=<span class="hljs-string">“right”</span><br>            android:background=<span class="hljs-string">“#f2eada”</span> /&gt;<br><br>    &lt;/qdx<span class="hljs-preprocessor">.viewtouchevent</span><span class="hljs-preprocessor">.CustomViewGroup</span>&gt;<br><br>&lt;/FrameLayout&gt;<br></code><ul class="pre-numbering" style=""><li style="color: rgb(153, 153, 153);">1</li><li style="color: rgb(153, 153, 153);">2</li><li style="color: rgb(153, 153, 153);">3</li><li style="color: rgb(153, 153, 153);">4</li><li style="color: rgb(153, 153, 153);">5</li><li style="color: rgb(153, 153, 153);">6</li><li style="color: rgb(153, 153, 153);">7</li><li style="color: rgb(153, 153, 153);">8</li><li style="color: rgb(153, 153, 153);">9</li><li style="color: rgb(153, 153, 153);">10</li><li style="color: rgb(153, 153, 153);">11</li><li style="color: rgb(153, 153, 153);">12</li><li style="color: rgb(153, 153, 153);">13</li><li style="color: rgb(153, 153, 153);">14</li><li style="color: rgb(153, 153, 153);">15</li><li style="color: rgb(153, 153, 153);">16</li><li style="color: rgb(153, 153, 153);">17</li><li style="color: rgb(153, 153, 153);">18</li><li style="color: rgb(153, 153, 153);">19</li><li style="color: rgb(153, 153, 153);">20</li><li style="color: rgb(153, 153, 153);">21</li><li style="color: rgb(153, 153, 153);">22</li><li style="color: rgb(153, 153, 153);">23</li><li style="color: rgb(153, 153, 153);">24</li></ul></pre><br><br><p><br></p><br><br><p></p><div> <br><br><img src="https://img-blog.csdn.net/20170820190556008?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcWlhbjUyMGFv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="无事件处理者" title=""></div><p></p><br><br><p>如上图所示，down事件由activity-&gt;ViewGroup-&gt;View，因为View并没有处理down事件，所以事件消费情况为false，并且最后由View-&gt;ViewGroup-&gt;activity传递。 <br><br><br></p><br><br><h4 id="验证不消耗actiondown事件">验证不消耗ACTION_DOWN事件</h4><br><br><p>我们再来验证<font color="#7fb80e">①另外如果不消耗ACTION_DOWN事件，那么down,move,up事件系列都与该View无关，交由父类处理(父类的<code>onTouchEvent</code>方法)</font> <br><br>根据上面文字描述，因为我们的<code>CustomViewGroup</code>和<code>CustomView</code>都没有去处理任何事件，即当前序列的所有事件都<font color="#f05b72">return false</font>，所以我们也无法接收/处理其他事件(move,up)</p><br><br><p></p><div> <br><br><img src="https://img-blog.csdn.net/20170820192518176?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcWlhbjUyMGFv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt=" 不消耗ACTION_DOWN事件" title=""></div><p></p><br><br><p><br></p><br><br><p>我们再将customView设置为可点击状态，即消费touch事件。<code>setClickable(true);</code></p><br><br><p></p><div> <br><br><img src="https://img-blog.csdn.net/20170820214522582?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcWlhbjUyMGFv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="子View消费touch事件" title=""></div><p></p><br><br><p><br></p><br><br><h4 id="验证-viewgroup事件拦截">验证 ViewGroup事件拦截</h4><br><br><p>viewGroup将事件拦截后，<font color="#7fb80e">②而且这一个事件序列（当前和其它事件）都只能由该ViewGroup处理，并且不会再调用该<code>onInterceptTouchEvent</code>方法去询问是否拦截。</font></p><br><br><p></p><div> <br><br><img src="https://img-blog.csdn.net/20170820232415501?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcWlhbjUyMGFv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="View事件拦截" title=""></div><p></p><br><br><p>通过上面的几个验证，我们越来越接近真相，用通俗的话来解释就是：</p><br><br><blockquote><br>  <p>老板发现BUG解决，一开始是由上级往下级问话。（<a href="http://blog.csdn.net/qian520ao/article/details/73558275" title="optional title" target="_blank">类似责任链设计模式</a>）</p><br><br>  <p>例如突然间出现了BUG，老板问小组A有没有空处理一下BUG(即分发ACTION_DOWN)，小组A说没时间(return false)，那么老板就不会把这个序列的BUG（ACTION_MOVE和ACTION_UP）交给小组A。如果再次出现BUG，老板还会再次询问小组A。①</p><br><br>  <p>如果你举手揽了这个BUG（即拦截），那么这一事件的BUG都交由你解决，并且相同序列的BUG老板不会问话，直接找你处理。②</p><br></blockquote><br><br><p><br></p><br><br><h3 id="源码分析viewgroup"><a name="t4"></a>源码分析ViewGroup</h3><br><br><p>源码分析这一块主要还是基于《Android开发艺术探索》这本书的引导和理解做出的总结。PS：这本书性价比很高，涵盖知识面广。</p><br><br><br><br><h4 id="activity的事件分发">Activity的事件分发</h4><br><br><p>Activity的事件分发还关系到View的绘制和加载机制，等待下一篇来更详细认识这个知识点。</p><br><br><br><br><pre class="prettyprint" name="code"><code class="hljs java has-numbering">    <span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">dispatchTouchEvent</span>(MotionEvent ev) {<br>        <span class="hljs-keyword">if</span> (ev.getAction() == MotionEvent.ACTION_DOWN) {<br>            onUserInteraction();<br>        }<br><br>        <span class="hljs-comment">//最终获取到顶级View(ViewGroup)分发事件</span><br>        <span class="hljs-comment">//（getWindow().getDecorView().findViewById(android.R.id.Content)）.getChildAt(0)</span><br>        <span class="hljs-keyword">if</span> (getWindow().superDispatchTouchEvent(ev)) {<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>        }<br><br>        <span class="hljs-comment">//如果所有的View都没有处理事件，则由Activity亲自出马</span><br>        <span class="hljs-keyword">return</span> onTouchEvent(ev);<br>    }</code><ul class="pre-numbering" style=""><li style="color: rgb(153, 153, 153);">1</li><li style="color: rgb(153, 153, 153);">2</li><li style="color: rgb(153, 153, 153);">3</li><li style="color: rgb(153, 153, 153);">4</li><li style="color: rgb(153, 153, 153);">5</li><li style="color: rgb(153, 153, 153);">6</li><li style="color: rgb(153, 153, 153);">7</li><li style="color: rgb(153, 153, 153);">8</li><li style="color: rgb(153, 153, 153);">9</li><li style="color: rgb(153, 153, 153);">10</li><li style="color: rgb(153, 153, 153);">11</li><li style="color: rgb(153, 153, 153);">12</li><li style="color: rgb(153, 153, 153);">13</li><li style="color: rgb(153, 153, 153);">14</li></ul></pre><br><br><p><br></p><br><br><br><br><h4 id="viewgroup的事件拦截">ViewGroup的事件拦截</h4><br><br><br><br><pre class="prettyprint" name="code"><code class="hljs java has-numbering">            <span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">dispatchTouchEvent</span>(MotionEvent ev) {<br>            ……<br><br>            <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> action = ev.getAction();<br>            <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> actionMasked = action &amp; MotionEvent.ACTION_MASK;<br><br>            <span class="hljs-keyword">if</span> (actionMasked == MotionEvent.ACTION_DOWN) {<br>                cancelAndClearTouchTargets(ev);<br><br>                <span class="hljs-comment">//清除FLAG_DISALLOW_INTERCEPT，并且设置mFirstTouchTarget为null</span><br>                resetTouchState(){<br>                    <span class="hljs-keyword">if</span>(mFirstTouchTarget!=<span class="hljs-keyword">null</span>){mFirstTouchTarget==<span class="hljs-keyword">null</span>;}<br>                    mGroupFlags &amp;= ~FLAG_DISALLOW_INTERCEPT;<br>                    ……<br>                };<br>            }<br>            <span class="hljs-keyword">final</span> <span class="hljs-keyword">boolean</span> intercepted;<span class="hljs-comment">//ViewGroup是否拦截事件</span><br><br>            <span class="hljs-comment">//mFirstTouchTarget是ViewGroup中处理事件(return true)的子View</span><br>            <span class="hljs-comment">//如果没有子View处理则mFirstTouchTarget=null,ViewGroup自己处理</span><br>            <span class="hljs-keyword">if</span> (actionMasked == MotionEvent.ACTION_DOWN|| mFirstTouchTarget != <span class="hljs-keyword">null</span>) {<br>                <span class="hljs-keyword">final</span> <span class="hljs-keyword">boolean</span> disallowIntercept = (mGroupFlags &amp; FLAG_DISALLOW_INTERCEPT) != <span class="hljs-number">0</span>;<br>                <span class="hljs-keyword">if</span> (!disallowIntercept) {<br>                    intercepted = onInterceptTouchEvent(ev);<span class="hljs-comment">//onInterceptTouchEvent</span><br>                    ev.setAction(action);<br>                } <span class="hljs-keyword">else</span> {<br>                    intercepted = <span class="hljs-keyword">false</span>;<br><br>                    <span class="hljs-comment">//如果子类设置requestDisallowInterceptTouchEvent（true）</span><br>                    <span class="hljs-comment">//ViewGroup将无法拦截MotionEvent.ACTION_DOWN以外的事件</span><br>                }<br>            } <span class="hljs-keyword">else</span> {<br>                intercepted = <span class="hljs-keyword">true</span>;<br><br>                <span class="hljs-comment">//actionMasked != MotionEvent.ACTION_DOWN并且没有子View处理事件，则将事件拦截</span><br>                <span class="hljs-comment">//并且不会再调用onInterceptTouchEvent询问是否拦截</span><br>            }<br><br>            ……<br>            ……<br>}</code><ul class="pre-numbering" style=""><li style="color: rgb(153, 153, 153);">1</li><li style="color: rgb(153, 153, 153);">2</li><li style="color: rgb(153, 153, 153);">3</li><li style="color: rgb(153, 153, 153);">4</li><li style="color: rgb(153, 153, 153);">5</li><li style="color: rgb(153, 153, 153);">6</li><li style="color: rgb(153, 153, 153);">7</li><li style="color: rgb(153, 153, 153);">8</li><li style="color: rgb(153, 153, 153);">9</li><li style="color: rgb(153, 153, 153);">10</li><li style="color: rgb(153, 153, 153);">11</li><li style="color: rgb(153, 153, 153);">12</li><li style="color: rgb(153, 153, 153);">13</li><li style="color: rgb(153, 153, 153);">14</li><li style="color: rgb(153, 153, 153);">15</li><li style="color: rgb(153, 153, 153);">16</li><li style="color: rgb(153, 153, 153);">17</li><li style="color: rgb(153, 153, 153);">18</li><li style="color: rgb(153, 153, 153);">19</li><li style="color: rgb(153, 153, 153);">20</li><li style="color: rgb(153, 153, 153);">21</li><li style="color: rgb(153, 153, 153);">22</li><li style="color: rgb(153, 153, 153);">23</li><li style="color: rgb(153, 153, 153);">24</li><li style="color: rgb(153, 153, 153);">25</li><li style="color: rgb(153, 153, 153);">26</li><li style="color: rgb(153, 153, 153);">27</li><li style="color: rgb(153, 153, 153);">28</li><li style="color: rgb(153, 153, 153);">29</li><li style="color: rgb(153, 153, 153);">30</li><li style="color: rgb(153, 153, 153);">31</li><li style="color: rgb(153, 153, 153);">32</li><li style="color: rgb(153, 153, 153);">33</li><li style="color: rgb(153, 153, 153);">34</li><li style="color: rgb(153, 153, 153);">35</li><li style="color: rgb(153, 153, 153);">36</li><li style="color: rgb(153, 153, 153);">37</li><li style="color: rgb(153, 153, 153);">38</li><li style="color: rgb(153, 153, 153);">39</li><li style="color: rgb(153, 153, 153);">40</li><li style="color: rgb(153, 153, 153);">41</li></ul></pre><br><br><p>我们将上面的结论再次写下来，方便对照。 <br><br><font color="#7fb80e">①另外如果不消耗ACTION_DOWN事件，那么down,move,up事件都与该View无关，交由父类处理(父类的<code>onTouchEvent</code>方法)</font>（dispatchTouchEvent） <br><br><font color="#7fb80e">②而且这一个事件序列（当前和其它事件）都只能由该ViewGroup处理，并且不会再调用该<code>onInterceptTouchEvent</code>方法去询问是否拦截。</font>（onInterceptTouchEvent return true）</p><br><br><ul><br><li>首先我们分析上面第21行代码： ViewGroup在两种情况下会拦截事件（ACTION_DOWN || mFirstTouchTarget != null）所以反过来也就是说 <font color="#f15a22">I : 当ACTION_MOVE和ACTION_UP事件到来时，如果没有子元素处理事件（mFirstTouchTarget==null），则ViewGroup的onInterceptTouchEvent不会再被调用，而且同一序列中的其它事件都会默认交给它处理（第34行 intercepted=true）；</font>与上面所说的<font color="#7fb80e">①②</font>呼应。</li><br><li>紧接着22行： ViewGroup<code>disallowIntercept</code>（不拦截）的判定是<code>FLAG_DISALLOW_INTERCEPT</code>标记位，这个标记是通过子View<code>requestDisallowInterceptTouchEvent</code>方法设置的。所以我们可以得出这么一个结论<font color="#f15a22">II : 当子View处理了ACTION_DOWN事件(mFirstTouchTarget =该子View)，而且设置了FLAG_DISALLOW_INTERCEPT标记位，那么ViewGroup将无法拦截除了ACTION_DOWN以外的其它事件。</font>（在11行代码ACTION_DOWN时清除了FLAG_DISALLOW_INTERCEPT标记位，所以ViewGroup无论如何都可以选择是否拦截处理ACTION_DOWN）</li><br></ul><br><br><p>上面变着花样的又一次验证了①②个知识点，不得不说<font color="#fdb933" size="4">read the fuck source code</font>让我们可以找到一个处理滑动冲突的方法：<font color="#7fb80e" size="4">子View处理DOWN事件并且设置<code>FLAG_DISALLOW_INTERCEPT</code>标记位，就可以不让ViewGroup拦截DOWN以外的事件。</font></p><br><br><p><br></p><br><br><br><br><h4 id="viewgroup的事件分发">ViewGroup的事件分发</h4><br><br><br><br><pre class="prettyprint" name="code"><code class="hljs java has-numbering">        <span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">dispatchTouchEvent</span>(MotionEvent ev) {<br>        <span class="hljs-keyword">final</span> View[] children = mChildren;<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = childrenCount - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i–) {<br>            <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> childIndex = getAndVerifyPreorderedIndex(childrenCount, i, customOrder);<br>            <span class="hljs-keyword">final</span> View child = getAndVerifyPreorderedView(preorderedList, children, childIndex);<br><br>            ……<br><br>            <span class="hljs-keyword">if</span> (!canViewReceivePointerEvents(child) || !isTransformedTouchPointInView(x, y, child, <span class="hljs-keyword">null</span>))<br>            {<br>                ev.setTargetAccessibilityFocus(<span class="hljs-keyword">false</span>);<br>                <span class="hljs-comment">//如果子View没有播放动画，而且点击事件的坐标在子View的区域内，继续下面的判断</span><br>                <span class="hljs-keyword">continue</span>;<br>            }<br>            <span class="hljs-comment">//判断是否有子View处理了事件</span><br>            newTouchTarget = getTouchTarget(child);<br><br>            <span class="hljs-keyword">if</span> (newTouchTarget != <span class="hljs-keyword">null</span>) {<br>                <span class="hljs-comment">//如果已经有子View处理了事件，即mFirstTouchTarget!=null，终止循环。</span><br>                newTouchTarget.pointerIdBits |= idBitsToAssign;<br>                <span class="hljs-keyword">break</span>;<br>            }<br><br>            <span class="hljs-keyword">if</span> (dispatchTransformedTouchEvent(ev, <span class="hljs-keyword">false</span>, child, idBitsToAssign)) {<br>                <span class="hljs-comment">//点击dispatchTransformedTouchEvent代码发现其执行方法实际为</span><br>                <span class="hljs-comment">//return child.dispatchTouchEvent(event); （因为child!=null）</span><br>                <span class="hljs-comment">//所以如果有子View处理了事件，我们就进行下一步：赋值</span><br><br>                ……<br><br>                newTouchTarget = addTouchTarget(child, idBitsToAssign);<br>                <span class="hljs-comment">//addTouchTarget方法里完成了对mFirstTouchTarget的赋值</span><br>                alreadyDispatchedToNewTouchTarget = <span class="hljs-keyword">true</span>;<br><br>                <span class="hljs-keyword">break</span>;<br>            }<br>        }<br>    }<br><br>    <span class="hljs-keyword">private</span> TouchTarget <span class="hljs-title">addTouchTarget</span>(@NonNull View child, <span class="hljs-keyword">int</span> pointerIdBits) {<br>        <span class="hljs-keyword">final</span> TouchTarget target = TouchTarget.obtain(child, pointerIdBits);<br>        target.next = mFirstTouchTarget;<br>        mFirstTouchTarget = target;<br>        <span class="hljs-keyword">return</span> target;<br>    }<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">dispatchTransformedTouchEvent</span>(MotionEvent event, <span class="hljs-keyword">boolean</span> cancel,<br>            View child, <span class="hljs-keyword">int</span> desiredPointerIdBits) {<br>            ……<br><br>            <span class="hljs-keyword">if</span> (child == <span class="hljs-keyword">null</span>) {<br>            <span class="hljs-comment">//如果没有子View处理事件，就自己处理</span><br>                handled = <span class="hljs-keyword">super</span>.dispatchTouchEvent(event);<br>            } <span class="hljs-keyword">else</span> {<br>           <span class="hljs-comment">//有子View，调用子View的dispatchTouchEvent方法</span><br>                handled = child.dispatchTouchEvent(event);<br><br>            ……<br><br>            <span class="hljs-keyword">return</span> handled;<br>    }<br></code><ul class="pre-numbering" style=""><li style="color: rgb(153, 153, 153);">1</li><li style="color: rgb(153, 153, 153);">2</li><li style="color: rgb(153, 153, 153);">3</li><li style="color: rgb(153, 153, 153);">4</li><li style="color: rgb(153, 153, 153);">5</li><li style="color: rgb(153, 153, 153);">6</li><li style="color: rgb(153, 153, 153);">7</li><li style="color: rgb(153, 153, 153);">8</li><li style="color: rgb(153, 153, 153);">9</li><li style="color: rgb(153, 153, 153);">10</li><li style="color: rgb(153, 153, 153);">11</li><li style="color: rgb(153, 153, 153);">12</li><li style="color: rgb(153, 153, 153);">13</li><li style="color: rgb(153, 153, 153);">14</li><li style="color: rgb(153, 153, 153);">15</li><li style="color: rgb(153, 153, 153);">16</li><li style="color: rgb(153, 153, 153);">17</li><li style="color: rgb(153, 153, 153);">18</li><li style="color: rgb(153, 153, 153);">19</li><li style="color: rgb(153, 153, 153);">20</li><li style="color: rgb(153, 153, 153);">21</li><li style="color: rgb(153, 153, 153);">22</li><li style="color: rgb(153, 153, 153);">23</li><li style="color: rgb(153, 153, 153);">24</li><li style="color: rgb(153, 153, 153);">25</li><li style="color: rgb(153, 153, 153);">26</li><li style="color: rgb(153, 153, 153);">27</li><li style="color: rgb(153, 153, 153);">28</li><li style="color: rgb(153, 153, 153);">29</li><li style="color: rgb(153, 153, 153);">30</li><li style="color: rgb(153, 153, 153);">31</li><li style="color: rgb(153, 153, 153);">32</li><li style="color: rgb(153, 153, 153);">33</li><li style="color: rgb(153, 153, 153);">34</li><li style="color: rgb(153, 153, 153);">35</li><li style="color: rgb(153, 153, 153);">36</li><li style="color: rgb(153, 153, 153);">37</li><li style="color: rgb(153, 153, 153);">38</li><li style="color: rgb(153, 153, 153);">39</li><li style="color: rgb(153, 153, 153);">40</li><li style="color: rgb(153, 153, 153);">41</li><li style="color: rgb(153, 153, 153);">42</li><li style="color: rgb(153, 153, 153);">43</li><li style="color: rgb(153, 153, 153);">44</li><li style="color: rgb(153, 153, 153);">45</li><li style="color: rgb(153, 153, 153);">46</li><li style="color: rgb(153, 153, 153);">47</li><li style="color: rgb(153, 153, 153);">48</li><li style="color: rgb(153, 153, 153);">49</li><li style="color: rgb(153, 153, 153);">50</li><li style="color: rgb(153, 153, 153);">51</li><li style="color: rgb(153, 153, 153);">52</li><li style="color: rgb(153, 153, 153);">53</li><li style="color: rgb(153, 153, 153);">54</li><li style="color: rgb(153, 153, 153);">55</li><li style="color: rgb(153, 153, 153);">56</li><li style="color: rgb(153, 153, 153);">57</li><li style="color: rgb(153, 153, 153);">58</li><li style="color: rgb(153, 153, 153);">59</li><li style="color: rgb(153, 153, 153);">60</li><li style="color: rgb(153, 153, 153);">61</li><li style="color: rgb(153, 153, 153);">62</li><li style="color: rgb(153, 153, 153);">63</li></ul></pre><br><br><p>上面为ViewGroup对事件的分发，主要有2点</p><br><br><ol><br><li>如果有子View，则调用子View的dispatchTouchEvent方法判断是否处理了事件，如果处理了便赋值mFirstTouchTarget，赋值成功则跳出循环。</li><br><li>ViewGroup的事件分发最终还是调用View的<code>dispatchTouchEvent</code>方法，具体如上代码所述。</li><br></ol><br><br><p>至此View的事件分发机制已经演练完毕，如果事件分发机制理解深入的话，那么处理滑动冲突便是手到擒来了。</p><br><br><p><br></p><br><br><br><br><h2 id="view的滑动冲突"><a name="t5"></a>View的滑动冲突</h2><br><br><p>关于View的滑动冲突我们就开门见山吧，因为上述的事件分发已经有足够的理论知识了，我们可以单刀赴会了。</p><br><br><br><p></p><div> <br><br><img src="https://img-blog.csdn.net/20170822232321861?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcWlhbjUyMGFv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="View的滑动冲突" title=""></div><p></p><br><br><p>针对上图，这个是比较普遍的滑动冲突事件，我们先拿它来开刀。</p><br><br><p><br> <br><br>好记性不如烂笔头，我们再次把结论搬到战场上 <br><br><font color="#7fb80e">①另外如果不消耗ACTION_DOWN事件，那么down,move,up事件都与该View无关，交由父类处理(父类的<code>onTouchEvent</code>方法)</font>（dispatchTouchEvent） <br><br><font color="#7fb80e">②而且这一个事件序列（当前和其它事件）都只能由该ViewGroup处理，并且不会再调用该<code>onInterceptTouchEvent</code>方法去询问是否拦截。</font>（onInterceptTouchEvent return true）</p><br><br><p><font color="#f15a22">I : 当ACTION_MOVE和ACTION_UP事件到来时，如果没有子元素处理事件（mFirstTouchTarget==null），则ViewGroup的onInterceptTouchEvent不会再被调用，而且同一序列中的其它事件都会默认交给它处理（第34行 intercepted=true）；</font></p><br><br><h3 id="外部拦截"><a name="t6"></a>外部拦截</h3><br><br>以下是外部拦截的伪代码：<br><br><img src="https://note.youdao.com/yws/api/personal/file/WEBa5be22d63894c59774c93ed5c167a2b3?method=download&amp;shareKey=66d44259265f8148df25421e0980fd2e" alt="外部拦截法"><br><br><br><p>外部拦截顾名思义就是由父ViewGroup对事件拦截处理（所以重写<code>onInterceptTouchEvent</code>方法即可），子View只能眼巴巴的处理父View“吃剩”的事件。主要有以下几点。</p><br><br><ul><br><li>父类不能拦截ACTION_DOWN，也就是说必须返回false，根据上述<font color="#7fb80e">①②</font>和<font color="#f15a22"> I </font>可得。</li><br><li>父类在ACTION_MOVE的时候根据需求，判断是否拦截。</li><br><li>ACTION_UP事件建议返回false或者<code>super.onInterceptTouchEvent</code>，因为如果已经拦截的话，那么并不会调用<code>onInterceptTouchEvent</code>方法再次询问。如果不拦截，而且返回true，子View可能就无法触发onClick等相关事件。</li><br></ul><br><br><p>ViewGroup ： 需要重写<code>onInterceptTouchEvent</code>，判断是否拦截即可。 <br><br>但是有一种情况：用户正在水平滑动（事件已拦截给ViewGroup），但是水平滑动停止前用户再进行竖直滑动，下面代码我用<code>isSolve</code>进行简单的处理。</p><br><br><br><br><pre class="prettyprint" name="code"><code class="hljs java has-numbering">    <span class="hljs-keyword">private</span> <span class="hljs-keyword">boolean</span> isIntercept;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">boolean</span> isSolve;<span class="hljs-comment">//是否完成了拦截判断，如果决定拦截，那么同系列事件就不能设置为不拦截</span><br><br>    <span class="hljs-annotation">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">onInterceptTouchEvent</span>(MotionEvent ev) {<br>        <span class="hljs-keyword">switch</span> (ev.getAction()) {<br>            <span class="hljs-keyword">case</span> MotionEvent.ACTION_DOWN:<br>                mPointGapF.x = ev.getX();<br>                mPointGapF.y = ev.getY();<br>                <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<span class="hljs-comment">//down的时候拦截后，就只能交给自己处理了</span><br><br>            <span class="hljs-keyword">case</span> MotionEvent.ACTION_MOVE:<br>                <span class="hljs-keyword">if</span> (!isSolve) {<span class="hljs-comment">//是否已经决定拦截/不拦截？</span><br>                    isIntercept = (Math.abs(ev.getX() - mPointGapF.x) &gt; Math.abs(ev.getY() - mPointGapF.y)<em><span class="hljs-number">2</span>);<span class="hljs-comment">//如果是左右滑动，且水平角度小于30°，就拦截</span><br>                    isSolve = <span class="hljs-keyword">true</span>;<br>                }<br>                <span class="hljs-keyword">return</span> isIntercept;<span class="hljs-comment">//如果是左右滑动，就拦截</span><br>        }<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">super</span>.onInterceptTouchEvent(ev);<br>    }<br><br>    <span class="hljs-annotation">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">onTouchEvent</span>(MotionEvent ev) {<br>        <span class="hljs-keyword">switch</span> (ev.getAction()) {<br>            <span class="hljs-keyword">case</span> MotionEvent.ACTION_MOVE:<br>                scrollBy((<span class="hljs-keyword">int</span>) (mPointGapF.x - ev.getX()), <span class="hljs-number">0</span>);<br><br>                mPointGapF.x = ev.getX();<br>                mPointGapF.y = ev.getY();<br>                <span class="hljs-keyword">break</span>;<br>        }<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">super</span>.onTouchEvent(ev);<br>    }</em></code><ul class="pre-numbering" style=""><li style="color: rgb(153, 153, 153);">1</li><li style="color: rgb(153, 153, 153);">2</li><li style="color: rgb(153, 153, 153);">3</li><li style="color: rgb(153, 153, 153);">4</li><li style="color: rgb(153, 153, 153);">5</li><li style="color: rgb(153, 153, 153);">6</li><li style="color: rgb(153, 153, 153);">7</li><li style="color: rgb(153, 153, 153);">8</li><li style="color: rgb(153, 153, 153);">9</li><li style="color: rgb(153, 153, 153);">10</li><li style="color: rgb(153, 153, 153);">11</li><li style="color: rgb(153, 153, 153);">12</li><li style="color: rgb(153, 153, 153);">13</li><li style="color: rgb(153, 153, 153);">14</li><li style="color: rgb(153, 153, 153);">15</li><li style="color: rgb(153, 153, 153);">16</li><li style="color: rgb(153, 153, 153);">17</li><li style="color: rgb(153, 153, 153);">18</li><li style="color: rgb(153, 153, 153);">19</li><li style="color: rgb(153, 153, 153);">20</li><li style="color: rgb(153, 153, 153);">21</li><li style="color: rgb(153, 153, 153);">22</li><li style="color: rgb(153, 153, 153);">23</li><li style="color: rgb(153, 153, 153);">24</li><li style="color: rgb(153, 153, 153);">25</li><li style="color: rgb(153, 153, 153);">26</li><li style="color: rgb(153, 153, 153);">27</li><li style="color: rgb(153, 153, 153);">28</li><li style="color: rgb(153, 153, 153);">29</li><li style="color: rgb(153, 153, 153);">30</li><li style="color: rgb(153, 153, 153);">31</li><li style="color: rgb(153, 153, 153);">32</li><li style="color: rgb(153, 153, 153);">33</li></ul></pre><br><br><p>子View ： 和子View没有多大关系，只需要处理自身的移动操作即可。</p><br><br><br><br><pre class="prettyprint" name="code"><code class="hljs avrasm has-numbering">public boolean onTouchEvent(MotionEvent ev) {<br>        switch (ev<span class="hljs-preprocessor">.getAction</span>()) {<br>            case MotionEvent<span class="hljs-preprocessor">.ACTION</span>_DOWN:<br>                mPointGapF<span class="hljs-preprocessor">.x</span> = ev<span class="hljs-preprocessor">.getX</span>()<span class="hljs-comment">;</span><br>                mPointGapF<span class="hljs-preprocessor">.y</span> = ev<span class="hljs-preprocessor">.getY</span>()<span class="hljs-comment">;</span><br>                <span class="hljs-keyword">break</span><span class="hljs-comment">;</span><br>            case MotionEvent<span class="hljs-preprocessor">.ACTION</span>_MOVE:<br>                scrollBy(<span class="hljs-number">0</span>, (int) (mPointGapF<span class="hljs-preprocessor">.y</span> - ev<span class="hljs-preprocessor">.getY</span>()))<span class="hljs-comment">;</span><br>                mPointGapF<span class="hljs-preprocessor">.x</span> = ev<span class="hljs-preprocessor">.getX</span>()<span class="hljs-comment">;</span><br>                mPointGapF<span class="hljs-preprocessor">.y</span> = ev<span class="hljs-preprocessor">.getY</span>()<span class="hljs-comment">;</span><br>                <span class="hljs-keyword">break</span><span class="hljs-comment">;</span><br>        }<br>        return true<span class="hljs-comment">;</span><br>    }</code><ul class="pre-numbering" style=""><li style="color: rgb(153, 153, 153);">1</li><li style="color: rgb(153, 153, 153);">2</li><li style="color: rgb(153, 153, 153);">3</li><li style="color: rgb(153, 153, 153);">4</li><li style="color: rgb(153, 153, 153);">5</li><li style="color: rgb(153, 153, 153);">6</li><li style="color: rgb(153, 153, 153);">7</li><li style="color: rgb(153, 153, 153);">8</li><li style="color: rgb(153, 153, 153);">9</li><li style="color: rgb(153, 153, 153);">10</li><li style="color: rgb(153, 153, 153);">11</li><li style="color: rgb(153, 153, 153);">12</li><li style="color: rgb(153, 153, 153);">13</li><li style="color: rgb(153, 153, 153);">14</li></ul></pre><br><br><p></p><div> <br><br><img src="https://img-blog.csdn.net/20170823135102485?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcWlhbjUyMGFv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="外部拦截冲突" title=""></div><p></p><br><br><p></p><div> <br><br><img src="https://img-blog.csdn.net/20170823134034862?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcWlhbjUyMGFv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="外部拦截冲突" title=""></div><p></p><br><br><p><br></p><br><br><h3 id="内部拦截"><a name="t7"></a>内部拦截</h3><br><br><br>以下是内部拦截方法的伪代码：<br><br><img src="https://note.youdao.com/yws/api/personal/file/WEB895b11d40d1cdddcac2f098c30ae4652?method=download&amp;shareKey=6f0bd71a1c4bb9db90f7e5eef112612a" alt=""><br><br><p><font color="#f15a22">II : 当子View处理了ACTION_DOWN事件(mFirstTouchTarget =该子View)，而且设置了FLAG_DISALLOW_INTERCEPT标记位，那么ViewGroup将无法拦截除了ACTION_DOWN以外的其它事件。</font></p><br><br><p>ViewGroup ： 只需在<code>onInterceptTouchEvent</code>MotionEvent.ACTION_DOWN时候不拦截，其他时候都需要拦截，否则父类的<code>onTouchEvent</code>就不能处理任何事件了。</p><br><br><br><br><pre class="prettyprint" name="code"><code class="hljs java has-numbering">    <span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">onInterceptTouchEvent</span>(MotionEvent ev) {<br>        <span class="hljs-keyword">switch</span> (ev.getAction()) {<br>            <span class="hljs-keyword">case</span> MotionEvent.ACTION_DOWN:<br>                <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<span class="hljs-comment">//down的时候拦截后，就只能交给自己处理了</span><br>        }<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<span class="hljs-comment">//如果不拦截，父类的onTouchEvent方法就无事件可以处理。</span><br>    }<br><br>    <span class="hljs-annotation">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">onTouchEvent</span>(MotionEvent ev) {<br>        <span class="hljs-keyword">switch</span> (ev.getAction()) {<br>            <span class="hljs-keyword">case</span> MotionEvent.ACTION_MOVE:<br>                scrollBy((<span class="hljs-keyword">int</span>) (mPointGapF.x - ev.getX()), <span class="hljs-number">0</span>);<br><br>                mPointGapF.x = ev.getX();<br>                mPointGapF.y = ev.getY();<br>                <span class="hljs-keyword">break</span>;<br>        }<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">super</span>.onTouchEvent(ev);<br>    }</code><ul class="pre-numbering" style=""><li style="color: rgb(153, 153, 153);">1</li><li style="color: rgb(153, 153, 153);">2</li><li style="color: rgb(153, 153, 153);">3</li><li style="color: rgb(153, 153, 153);">4</li><li style="color: rgb(153, 153, 153);">5</li><li style="color: rgb(153, 153, 153);">6</li><li style="color: rgb(153, 153, 153);">7</li><li style="color: rgb(153, 153, 153);">8</li><li style="color: rgb(153, 153, 153);">9</li><li style="color: rgb(153, 153, 153);">10</li><li style="color: rgb(153, 153, 153);">11</li><li style="color: rgb(153, 153, 153);">12</li><li style="color: rgb(153, 153, 153);">13</li><li style="color: rgb(153, 153, 153);">14</li><li style="color: rgb(153, 153, 153);">15</li><li style="color: rgb(153, 153, 153);">16</li><li style="color: rgb(153, 153, 153);">17</li><li style="color: rgb(153, 153, 153);">18</li><li style="color: rgb(153, 153, 153);">19</li><li style="color: rgb(153, 153, 153);">20</li></ul></pre><br><br><p>子View ： 需要在ACTION_DOWN事件设置getParent().requestDisallowInterceptTouchEvent(true)，并且在ACTION_MOVE的时候通过判断是否禁止父类的拦截。</p><br><br><br><br><pre class="prettyprint" name="code"><code class="hljs java has-numbering">    <span class="hljs-keyword">private</span> <span class="hljs-keyword">boolean</span> isSolve;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">boolean</span> isIntercept;<br><br>    <span class="hljs-annotation">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">dispatchTouchEvent</span>(MotionEvent ev) {<br>        <span class="hljs-keyword">switch</span> (ev.getAction()) {<br>            <span class="hljs-keyword">case</span> MotionEvent.ACTION_DOWN:<br>                isIntercept = <span class="hljs-keyword">false</span>;<br>                isSolve = <span class="hljs-keyword">false</span>;<br>                mPointGapF.x = ev.getX();<br>                mPointGapF.y = ev.getY();<br>                getParent().requestDisallowInterceptTouchEvent(<span class="hljs-keyword">true</span>);<br>                <span class="hljs-keyword">break</span>;<br><br>            <span class="hljs-keyword">case</span> MotionEvent.ACTION_MOVE:<br>                <span class="hljs-keyword">if</span> (!isSolve) {<br>                    isSolve = <span class="hljs-keyword">true</span>;<br>                    isIntercept = (Math.abs(ev.getX() - mPointGapF.x) &lt; Math.abs(ev.getY() - mPointGapF.y)  <span class="hljs-number">2</span>);<br>                    getParent().requestDisallowInterceptTouchEvent(isIntercept);<br>                }<br>                <span class="hljs-keyword">break</span>;<br>        }<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">super</span>.dispatchTouchEvent(ev);<br>    }</code><ul class="pre-numbering" style=""><li style="color: rgb(153, 153, 153);">1</li><li style="color: rgb(153, 153, 153);">2</li><li style="color: rgb(153, 153, 153);">3</li><li style="color: rgb(153, 153, 153);">4</li><li style="color: rgb(153, 153, 153);">5</li><li style="color: rgb(153, 153, 153);">6</li><li style="color: rgb(153, 153, 153);">7</li><li style="color: rgb(153, 153, 153);">8</li><li style="color: rgb(153, 153, 153);">9</li><li style="color: rgb(153, 153, 153);">10</li><li style="color: rgb(153, 153, 153);">11</li><li style="color: rgb(153, 153, 153);">12</li><li style="color: rgb(153, 153, 153);">13</li><li style="color: rgb(153, 153, 153);">14</li><li style="color: rgb(153, 153, 153);">15</li><li style="color: rgb(153, 153, 153);">16</li><li style="color: rgb(153, 153, 153);">17</li><li style="color: rgb(153, 153, 153);">18</li><li style="color: rgb(153, 153, 153);">19</li><li style="color: rgb(153, 153, 153);">20</li><li style="color: rgb(153, 153, 153);">21</li><li style="color: rgb(153, 153, 153);">22</li><li style="color: rgb(153, 153, 153);">23</li><li style="color: rgb(153, 153, 153);">24</li></ul></pre><br><br><p>最终的效果图和外部拦截的效果一致，这里就不再次贴出来了。 <br><br><br></p><br><br><br>## 一图看懂分发机制<br><br><img src="https://note.youdao.com/yws/api/personal/file/WEBe578b38e326c625af6d4bf41d73cd0c6?method=download&amp;shareKey=fc0868e4d6f2132ec5353a4a77e46a5a" alt="一图看懂分发机制"><br><br><br><h2 id="总结"><a name="t8"></a>总结</h2><br><br><p>通过理论和实战，更清晰的了解了事件的分发机制，从而这些理论知识使得我们更有效的处理滑动冲突事件，所以以后只要再遇见滑动冲突事件，再次巩固View的事件分发，万变不离其宗，定能手到擒来解决这一问题！</p>            </div><br>            <link rel="stylesheet" href="https://csdnimg.cn/release/phoenix/template/css/markdown_views-ea0013b516.css"><br>                </div>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Android-View分发机制及解决滑动冲突方案&quot;&gt;&lt;a href=&quot;#Android-View分发机制及解决滑动冲突方案&quot; class=&quot;headerlink&quot; title=&quot;Android View分发机制及解决滑动冲突方案&quot;&gt;&lt;/a&gt;Android Vie
      
    
    </summary>
    
      <category term="基础知识" scheme="http://skyacer.github.io/categories/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    
    
      <category term="View" scheme="http://skyacer.github.io/tags/View/"/>
    
  </entry>
  
  <entry>
    <title>《Android优化专题》—— 优化下载效率</title>
    <link href="http://skyacer.github.io/2018/05/23/%E3%80%8AAndroid%E4%BC%98%E5%8C%96%E4%B8%93%E9%A2%98%E3%80%8B%E2%80%94%E2%80%94-%E4%BC%98%E5%8C%96%E4%B8%8B%E8%BD%BD%E6%95%88%E7%8E%87/"/>
    <id>http://skyacer.github.io/2018/05/23/《Android优化专题》——-优化下载效率/</id>
    <published>2018-05-23T12:35:28.000Z</published>
    <updated>2018-05-23T12:36:06.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="《Android优化专题》——-优化下载效率"><a href="#《Android优化专题》——-优化下载效率" class="headerlink" title="《Android优化专题》—— 优化下载效率"></a>《Android优化专题》—— 优化下载效率</h1><h2 id="一、用有效率的网络访问方式来优化下载"><a href="#一、用有效率的网络访问方式来优化下载" class="headerlink" title="一、用有效率的网络访问方式来优化下载"></a>一、用有效率的网络访问方式来优化下载</h2><h3 id="1-无线电状态机"><a href="#1-无线电状态机" class="headerlink" title="1.无线电状态机"></a>1.无线电状态机</h3><ul><li>Full power：当无线连接被激活的时候，允许设备以最大的传输速率进行操作。</li><li>Low power：相对Full power来说，算是一种中间状态，差不多50%的传输速率。</li><li>Standby：最低的状态，没有数据连接需要传输。</li></ul><p>典型的3G无线电波状态机图示：</p><p><img src="https://note.youdao.com/yws/api/personal/file/WEB67e9adfaac62ea0736d6f24b4cc0f165?method=download&amp;shareKey=dc3ce6fbd2dec3ee1b1fd82ae1605f1f" alt=""></p><h3 id="2-apps如何影响无线状态机"><a href="#2-apps如何影响无线状态机" class="headerlink" title="2. apps如何影响无线状态机"></a>2. apps如何影响无线状态机</h3><h4 id="创建新连接"><a href="#创建新连接" class="headerlink" title="创建新连接"></a>创建新连接</h4><p>每次创建一个网络连接，无线电波就会切换到full power状态（这也是为什么降低连接数可以更省电量以及省流量的原因），结束之后会有一个附加的5s时间切换到low power，再之后会经过12s进入到low energy状态，每次数据传输的会话都会引起无线电波持续消耗大概20s的能量。</p><h4 id="传输bundle（序列化）与unbundled（未序列化）数据差别"><a href="#传输bundle（序列化）与unbundled（未序列化）数据差别" class="headerlink" title="传输bundle（序列化）与unbundled（未序列化）数据差别"></a>传输bundle（序列化）与unbundled（未序列化）数据差别</h4><p><img src="https://note.youdao.com/yws/api/personal/file/WEB7ab6e5aa0af3cc84fbf0e5e5bde4be5e?method=download&amp;shareKey=1e98b1be3b6eb2e4299ee7522bdffeb5" alt=""></p><p>一个app传递1秒钟的unbundled data会使得无线电波持续活动18秒【18=1秒的传输数据+5秒过渡时间回到low power+12秒过渡时间回到standby】。因此每一分钟，它会消耗18秒high power的电量，42秒的low power的电量。</p><p>如果每分钟app会传输bundle的data持续3秒的话，其中会使得无线电波持续在high power状态仅仅8秒钟，在low power状态仅仅12秒钟。 上面第二种传输bundle data的例子，可以看到减少了大量的电量消耗。</p><h3 id="3-预取数据"><a href="#3-预取数据" class="headerlink" title="3. 预取数据"></a>3. 预取数据</h3><blockquote><p>预取数据是一种减少独立数据传输会话数量的有效方法。在单次操作的时候，通过一次连接，在最大能力下，根据给出的时间下载到所有的数据。</p></blockquote><p>对于预取，取太多，不仅用户可能根本用不到那么多，而且还耗费了电量和流量。取太少，达不到预取的效果。</p><p>如何控制预取的大小？</p><p>这需要根据正在下载的数据大小与可能被用到的数据量来决定。一个基于上面状态机情况的比较大概的建议是：对于数据来说，大概有50%的机会可能用在当前用户的会话中，那么我们可以预取大约6秒(大约1-2Mb)，这大概使得潜在可能要用的数据量与可能已经下载好的数据量相一致。</p><p>通常来说，预取1-5Mb会比较好，这种情况下，我们仅仅只需要每隔2-5分钟开始另一段下载。根据这个原理，大数据的下载，比如视频文件，应该每隔2-5秒开始另一段下载，这样能有效的预取到下面几分钟内的数据进行预览。</p><h3 id="4-批量传输与连接"><a href="#4-批量传输与连接" class="headerlink" title="4. 批量传输与连接"></a>4. 批量传输与连接</h3><p>每次初始化一个连接（与需要传输的数据量无关），有可能导致无线电波持续花费20s的电量。</p><p>对于数据进行bundle操作，并且创建一个序列可以使得大量数据集中进行发送，这样可以使得无线电波的激活时间尽可能的少，同事减少大部分的电量花费。</p><h3 id="5-减少连接次数"><a href="#5-减少连接次数" class="headerlink" title="5. 减少连接次数"></a>5. 减少连接次数</h3><p>重用之前存在的网络连接比重新创建一个连接是更有效率的。当可以用一个GET请求解决的情况下，不要同时创建多个网络连接。</p><p>可以在一个连接要关闭时，不要立即关闭，而是在timeout之前关闭。</p><p>使用HttpUrlConnection，而不是HttpClient，前者做了response cache</p><h3 id="6-使用DDMS（Dalvik-Debug-Monitor-Server）网络通信工具来检测网络使用情况"><a href="#6-使用DDMS（Dalvik-Debug-Monitor-Server）网络通信工具来检测网络使用情况" class="headerlink" title="6. 使用DDMS（Dalvik Debug Monitor Server）网络通信工具来检测网络使用情况"></a>6. 使用DDMS（Dalvik Debug Monitor Server）网络通信工具来检测网络使用情况</h3><p><img src="https://note.youdao.com/yws/api/personal/file/WEB6200ba40b6d05b617272f233ce870afc?method=download&amp;shareKey=dbfc00a9fc45b3d02971ddadca2c65d4" alt=""></p><p>通过监测数据传输的频率和每次传输的数据量，可以看出哪些地方可以进行优化。类似于图中短小钉子形状的地方，可以和附近位置的请求进行merge操作。</p><p>Traffic Status API可以使用TrafficStats.setThreadStatsTag()的方法标记数据传输发生在某个Thread里面。可以手动使用tagSocket()进行标记或者untagSocket()来取消标记。</p><h2 id="二、调整更新的频率"><a href="#二、调整更新的频率" class="headerlink" title="二、调整更新的频率"></a>二、调整更新的频率</h2><h3 id="1-使用C2DM作为轮询方式之一"><a href="#1-使用C2DM作为轮询方式之一" class="headerlink" title="1.使用C2DM作为轮询方式之一"></a>1.使用C2DM作为轮询方式之一</h3><blockquote><p>C2DM是一个用来从server到特定app传输数据的轻量级机制。使用C2DM，server会在某个app有需要获取新数据的时候通知app有这个消息。</p></blockquote><p>但中国大陆的Google框架通常会被移除，使得C2DM没法在中国大陆的App上使用。</p><p>可参考各大厂商的推送定制。</p><h3 id="2-通过不定时的重复提醒和指数退避来优化轮询操作"><a href="#2-通过不定时的重复提醒和指数退避来优化轮询操作" class="headerlink" title="2.通过不定时的重复提醒和指数退避来优化轮询操作"></a>2.通过不定时的重复提醒和指数退避来优化轮询操作</h3><p>如果必须要使用轮询机制，可以考虑以下几个方面的优化：</p><ol><li>如果多个提醒都安排在某个小的时间段内，考虑把这多个操作在一个无线电状态下操作完。</li><li>使用Alarm时，设置的提醒类型为非wake类型（对于非紧急通知消息时，避免在屏幕熄灭状态下，将设备唤醒），减少电量的损耗。</li><li>在app上一次更新操作之后还未被使用的情况下，使用指数退避算法（exponential back-off algorithm）来减少更新频率。</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">private void retryIn(long interval) &#123;</span><br><span class="line">  boolean success = attemptTransfer();</span><br><span class="line"></span><br><span class="line">  if (!success) &#123;</span><br><span class="line">    retryIn(interval*2 &lt; MAX_RETRY_INTERVAL ?</span><br><span class="line">            interval*2 : MAX_RETRY_INTERVAL);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="二进制退避算法"><a href="#二进制退避算法" class="headerlink" title="二进制退避算法"></a>二进制退避算法</h4><ol><li>确定基本退避时间，一般为端到端的往返时间为2t，2t也成为冲突窗口或争用期。</li><li>定义参数k，k与冲突次数有关，规定k不能超过10，k=Min[冲突次数，10]。在冲突次数大于10，小于16时，k不再增大，一直取值为10。</li><li>从离散的整数集合[0,1,2，……，(2k-1)]中随机的取出一个数r，等待的时延为r倍的基本退避时间，等于r x 2t。r的取值范围与冲突次数k有关，r可选的随机取值为2k个、这也是称为二进制退避算法的起因。</li><li>当冲突次数大于10以后，都是从0—210-1个2t中随机选择一个作为等待时间。</li><li>当冲突次数超过16次后，发送失败，丢弃传输的帧，发送错误报告。</li></ol><h2 id="三、使用缓存来避免重复下载"><a href="#三、使用缓存来避免重复下载" class="headerlink" title="三、使用缓存来避免重复下载"></a>三、使用缓存来避免重复下载</h2><blockquote><p>减少下载的最基本方法是仅仅下载你想要的数据，通过类似上次更新时间来制定查询数据的条件。在下载图片时，server尽量减少图片的大小，比如对图片进行剪裁等处理。</p></blockquote><h3 id="1-缓存到本地"><a href="#1-缓存到本地" class="headerlink" title="1. 缓存到本地"></a>1. 缓存到本地</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">long currentTime = System.currentTimeMillis());</span><br><span class="line"></span><br><span class="line">HttpURLConnection conn = (HttpURLConnection) url.openConnection();</span><br><span class="line"></span><br><span class="line">long expires = conn.getHeaderFieldDate(&quot;Expires&quot;, currentTime);</span><br><span class="line">long lastModified = conn.getHeaderFieldDate(&quot;Last-Modified&quot;, currentTime);</span><br><span class="line"></span><br><span class="line">setDataExpirationDate(expires);</span><br><span class="line"></span><br><span class="line">if (lastModified &lt; lastUpdateTime) &#123;</span><br><span class="line">  // Skip update  </span><br><span class="line">&#125; else &#123;</span><br><span class="line">  // Parse update  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以使用下面的方法获取External缓存目录：目录是Android/data/data/com.xxx.xxx/cache</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Context.getExternalCacheDir();</span><br></pre></td></tr></table></figure><p>获取内部缓存的方法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Context.getCache()</span><br></pre></td></tr></table></figure><p>这里注意不要随便在sdcard下创建目录存放缓存，因为这个文件夹不会随着程序的卸载而删除。既影响用户体验，又会把一些不想让用户知道的数据泄露出去。</p><h3 id="2-使用HttpUrlConnect-Response缓存"><a href="#2-使用HttpUrlConnect-Response缓存" class="headerlink" title="2. 使用HttpUrlConnect Response缓存"></a>2. 使用HttpUrlConnect Response缓存</h3><p>我们可以通过反射机制开启HTTP response cache</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">private void enableHttpResponseCache() &#123;</span><br><span class="line">  try &#123;</span><br><span class="line">    long httpCacheSize = 10 * 1024 * 1024; // 10 MiB  </span><br><span class="line">    File httpCacheDir = new File(getCacheDir(), &quot;http&quot;);</span><br><span class="line">    Class.forName(&quot;android.net.http.HttpResponseCache&quot;)</span><br><span class="line">         .getMethod(&quot;install&quot;, File.class, long.class)</span><br><span class="line">         .invoke(null, httpCacheDir, httpCacheSize);</span><br><span class="line">  &#125; catch (Exception httpResponseCacheNotAvailable) &#123;</span><br><span class="line">    Log.d(TAG, &quot;HTTP response cache is unavailable.&quot;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>也可以在onCreate中加入以下代码开启</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">protected void onCreate(Bundle savedInstanceState) &#123;</span><br><span class="line">     ...</span><br><span class="line"></span><br><span class="line">     try &#123;</span><br><span class="line">         File httpCacheDir = new File(context.getCacheDir(), &quot;http&quot;);</span><br><span class="line">         long httpCacheSize = 10 * 1024 * 1024; // 10 MiB</span><br><span class="line">         HttpResponseCache.install(httpCacheDir, httpCacheSize);</span><br><span class="line">     &#125; catch (IOException e) &#123;</span><br><span class="line">         Log.i(TAG, &quot;HTTP response cache installation failed:&quot; + e);</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> protected void onStop() &#123;</span><br><span class="line">     ...</span><br><span class="line"></span><br><span class="line">     HttpResponseCache cache = HttpResponseCache.getInstalled();</span><br><span class="line">     if (cache != null) &#123;</span><br><span class="line">         cache.flush();</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>以上代码会在Android4.0以上开启response code，所有cache中的HTTP请求都可以直接在本地存储中响应，就不需要开启一个新的网络连接。被cache起来的response可以被server确保没有过期，这样减少了带宽。</p><h2 id="四、根据网络类型来切换下载模式"><a href="#四、根据网络类型来切换下载模式" class="headerlink" title="四、根据网络类型来切换下载模式"></a>四、根据网络类型来切换下载模式</h2><blockquote><p>WIFI要比无线电波消耗的电量要少很多，而且对于无线电波而言（3G,2G,LTE等）也存在不同电量的区别。</p></blockquote><h3 id="1-尽量WIFI"><a href="#1-尽量WIFI" class="headerlink" title="1. 尽量WIFI"></a>1. 尽量WIFI</h3><p>我们尽量要在连接WIFI的时候进行下载，更新数据等操作。</p><h3 id="2-尽量使用更大的带宽下载更多的数据，而不是经常去下载"><a href="#2-尽量使用更大的带宽下载更多的数据，而不是经常去下载" class="headerlink" title="2. 尽量使用更大的带宽下载更多的数据，而不是经常去下载"></a>2. 尽量使用更大的带宽下载更多的数据，而不是经常去下载</h3><p>相对更宽的带宽会有更长的状态切换时间（从full power过渡到standby有更长一段时间的延迟），过渡时间的电量通常是固定的，每次传输会话过程中尽量一次性把事情做完，而不是断断续续请求就更有效率了。</p><p>如果LTE无线电的带宽与电量消耗都是3G无线电的2倍，我们应该在每次会话的时候都下载4倍于3G的数据量，或者是差不多10Mb</p><p>我们可以根据connectivity manager来判断当前激活的无线电波，根据结果来做prefetch。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">ConnectivityManager cm =</span><br><span class="line"> (ConnectivityManager)getSystemService(Context.CONNECTIVITY_SERVICE);</span><br><span class="line"></span><br><span class="line">TelephonyManager tm =</span><br><span class="line">  (TelephonyManager)getSystemService(Context.TELEPHONY_SERVICE);</span><br><span class="line"></span><br><span class="line">NetworkInfo activeNetwork = cm.getActiveNetworkInfo();</span><br><span class="line"></span><br><span class="line">int PrefetchCacheSize = DEFAULT_PREFETCH_CACHE;</span><br><span class="line"></span><br><span class="line">switch (activeNetwork.getType()) &#123;</span><br><span class="line">  case (ConnectivityManager.TYPE_WIFI):</span><br><span class="line">    PrefetchCacheSize = MAX_PREFETCH_CACHE; break;</span><br><span class="line">  case (ConnectivityManager.TYPE_MOBILE): &#123;</span><br><span class="line">    switch (tm.getNetworkType()) &#123;</span><br><span class="line">      case (TelephonyManager.NETWORK_TYPE_LTE |</span><br><span class="line">            TelephonyManager.NETWORK_TYPE_HSPAP):</span><br><span class="line">        PrefetchCacheSize *= 4;</span><br><span class="line">        break;</span><br><span class="line">      case (TelephonyManager.NETWORK_TYPE_EDGE |</span><br><span class="line">            TelephonyManager.NETWORK_TYPE_GPRS):</span><br><span class="line">        PrefetchCacheSize /= 2;</span><br><span class="line">        break;</span><br><span class="line">      default: break;</span><br><span class="line">    &#125;</span><br><span class="line">    break;</span><br><span class="line">  &#125;</span><br><span class="line">  default: break;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;《Android优化专题》——-优化下载效率&quot;&gt;&lt;a href=&quot;#《Android优化专题》——-优化下载效率&quot; class=&quot;headerlink&quot; title=&quot;《Android优化专题》—— 优化下载效率&quot;&gt;&lt;/a&gt;《Android优化专题》—— 优化下载
      
    
    </summary>
    
      <category term="Android优化专题" scheme="http://skyacer.github.io/categories/Android%E4%BC%98%E5%8C%96%E4%B8%93%E9%A2%98/"/>
    
    
      <category term="下载" scheme="http://skyacer.github.io/tags/%E4%B8%8B%E8%BD%BD/"/>
    
  </entry>
  
  <entry>
    <title>Android热修复笔记</title>
    <link href="http://skyacer.github.io/2018/05/16/Android%E7%83%AD%E4%BF%AE%E5%A4%8D%E7%AC%94%E8%AE%B0/"/>
    <id>http://skyacer.github.io/2018/05/16/Android热修复笔记/</id>
    <published>2018-05-16T08:10:58.000Z</published>
    <updated>2018-05-31T08:13:36.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Android热修复笔记"><a href="#Android热修复笔记" class="headerlink" title="Android热修复笔记"></a>Android热修复笔记</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>代码修复有两大主要方案，一种是阿里系的底层替换方案，另一种是腾讯系的类加载方案。</p><h3 id="底层替换方案"><a href="#底层替换方案" class="headerlink" title="底层替换方案"></a>底层替换方案</h3><h4 id="优势"><a href="#优势" class="headerlink" title="优势"></a>优势</h4><p>时效性最好，加载轻快，即时生效。</p><h4 id="劣势"><a href="#劣势" class="headerlink" title="劣势"></a>劣势</h4><p>这个方案限制颇多，由于这类方案是根据公开的Android源码中的结构写死的，一旦厂商对ArtMethod结构体进行修改，那么就会出问题。</p><h2 id="AndFix"><a href="#AndFix" class="headerlink" title="AndFix"></a>AndFix</h2><h3 id="替换方法流程"><a href="#替换方法流程" class="headerlink" title="替换方法流程"></a>替换方法流程</h3><p>这里以Android版本大于4.4为例，进行分析</p><p><img src="https://note.youdao.com/yws/api/personal/file/WEB315390d16fc48dff84eeeba1cc8b0508?method=download&amp;shareKey=0ce2bfd9775ad2703418b0c700124cdb" alt="AndFix替换方案"></p><p>由流程图看出，替换方法所需ArtMethod中的字段有三个</p><ol><li>entry_point_from_interprete_</li><li>entry_point_from_quick_compiled_code_</li><li>dex_cache_resloved_methods </li></ol><p>ArtMethod到底是什么呢？</p><p>ART运行时在内部又会使用另外两个不同的术语来描述类和方法，其中将类描述为Class，而将类方法描述为ArtMethod</p><p>由于对于ArtMethod的结构写死，所以AndFix不支持很多机型的原因，也就是因为这些机型修改了底层的虚拟机结构。</p><h3 id="在AndFix基础上优化"><a href="#在AndFix基础上优化" class="headerlink" title="在AndFix基础上优化"></a>在AndFix基础上优化</h3><p>通过对于ArtMethod字段替换到整个结构的替换。<br><img src="https://note.youdao.com/yws/api/personal/file/WEBb13ecc4af0dfc784e57faf1b4b965d3d?method=download&amp;shareKey=9daf955e07100f61508da47e83eb1c7f" alt=""></p><p>分配Size流程如下：</p><p><img src="https://note.youdao.com/yws/api/personal/file/WEB07dd3d5faf50b5e999a6ef52622feab5?method=download&amp;shareKey=ec2d066417c6a92584454653b539a923" alt="ArtMethod分配Size流程"></p><p>如下图，通过在相邻两个方法中取对应ArtMethod的起始地址的差值来判断一个ArtMethod的大小。</p><p><img src="https://note.youdao.com/yws/api/personal/file/WEBa9ad2afafbd4aa9cb3dbc1774c63fa1f?method=download&amp;shareKey=28b9ae7c73bc793ba2d770640ff5de98" alt="地址差值"></p><h4 id="访问权限"><a href="#访问权限" class="headerlink" title="访问权限"></a>访问权限</h4><p>如何解决被替换的方法有权限访问这个类的其他private方法？</p><p><img src="https://note.youdao.com/yws/api/personal/file/WEB2049903c2ba4bc75ee5a597f465a1549?method=download&amp;shareKey=48b4fcb641d43d440ead566eaed3a8c0" alt=""><br>在机器码层面，调用逻辑和之前Activity的例子没有差别，并没有做任何的权限检查，所以替换后会正常执行而不是报错。</p><h4 id="同包名下的权限问题"><a href="#同包名下的权限问题" class="headerlink" title="同包名下的权限问题"></a>同包名下的权限问题</h4><p>如果补丁中的类在访问同包名下的类时会报出访问权限异常。</p><p>原因是因为在虚拟机中，替换了的方法与原来的方法不是同一个ClassLoader来加载，所以导致两个类无法被判断为同包名。</p><p>解决办法：通过设置新类的ClassLoader为原来类的就行了。通过反射即可进行设置。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Filed classLoaderField = Class.class.getDeclaredField(&quot;classLoader&quot;);</span><br><span class="line">classLoaderField.setAccessible(true);</span><br><span class="line">classLoaderField.set(newClass,oldClass.getClassLoader());</span><br></pre></td></tr></table></figure><h3 id="反射调用非静态方法产生的问题"><a href="#反射调用非静态方法产生的问题" class="headerlink" title="反射调用非静态方法产生的问题"></a>反射调用非静态方法产生的问题</h3><p>当一个非静态方法被替换后，如果代码里在反射调用时，会抛出异常。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// BaseBug.test 方法已经被热替换了</span><br><span class="line">BaseBug bb = new BaseBug();</span><br><span class="line">Method testMeth = BaseBug.class.getDeclaredMethod(&quot;test&quot;);</span><br><span class="line">testMeth.invoike(bb);</span><br></pre></td></tr></table></figure><p>在invoke的时候就会抛出 IllegalArgumentException异常。因为虽然都叫com.patch.demo.BaseBug，却是不同的类，不同在于由于把ArtMethod的declaring_class_替换了，因此就是新的补丁类，后者作为被调用的实例对象bb所属类是原有的BaseBug，两者是不同的。</p><p>具体原因：<br><strong>反射时调用InvokeMethod， InvokeMethod ——&gt; VerifyObjectIsClass(receiver, declaring_class) ——&gt; if(!o -&gt; InstanceOF(c)){ //抛异常 }</strong></p><p>由于静态类是在类级别的调用，不需要用到对象实例，就不会有这方面的检查。</p><p>解决方式：冷启动机制</p><h3 id="哪些情况适用热启动？哪些情况适用冷启动？"><a href="#哪些情况适用热启动？哪些情况适用冷启动？" class="headerlink" title="哪些情况适用热启动？哪些情况适用冷启动？"></a>哪些情况适用热启动？哪些情况适用冷启动？</h3><p>不适用于热启动情况：</p><ol><li>引起了原有的类中发生结构变化的修改</li><li>修复了的非静态方法会被反射调用</li></ol><p>其余情况适合用冷启动的方式</p><h2 id="你所不知道的Java"><a href="#你所不知道的Java" class="headerlink" title="你所不知道的Java"></a>你所不知道的Java</h2><h3 id="内部类"><a href="#内部类" class="headerlink" title="内部类"></a>内部类</h3><p><strong>内部类会在编译期编译成跟外部类一样的顶级类</strong></p><h4 id="静态内部类-非静态内部类有什么区别？"><a href="#静态内部类-非静态内部类有什么区别？" class="headerlink" title="静态内部类/非静态内部类有什么区别？"></a>静态内部类/非静态内部类有什么区别？</h4><p>非静态内部类，在编译期间会产生this$0，表示的是外部类的引用。</p><h4 id="既然内部类会在编译期间编译成跟外部类一样的顶级类，那么外部类怎么访问的内部类的私有方法？"><a href="#既然内部类会在编译期间编译成跟外部类一样的顶级类，那么外部类怎么访问的内部类的私有方法？" class="headerlink" title="既然内部类会在编译期间编译成跟外部类一样的顶级类，那么外部类怎么访问的内部类的私有方法？"></a>既然内部类会在编译期间编译成跟外部类一样的顶级类，那么外部类怎么访问的内部类的私有方法？</h4><p>因为在编译期间自动会为内部类生成access&amp;**相关方法，这个方法会简单返回私有域s的值。</p><h4 id="如何防止编译器生成access-amp-方法，从而使得能够进行热部署（不会改变方法数，从而也不会改变索引）？"><a href="#如何防止编译器生成access-amp-方法，从而使得能够进行热部署（不会改变方法数，从而也不会改变索引）？" class="headerlink" title="如何防止编译器生成access&amp;**方法，从而使得能够进行热部署（不会改变方法数，从而也不会改变索引）？"></a>如何防止编译器生成access&amp;**方法，从而使得能够进行热部署（不会改变方法数，从而也不会改变索引）？</h4><ul><li>把内部类的所有method/field的private访问权限改成protected或者默认访问权限public</li><li>如果一个类有内部类，那么把自身的method/field改成protected或者public</li></ul><h4 id="对于新增-删除匿名内部类，如何进行热部署？"><a href="#对于新增-删除匿名内部类，如何进行热部署？" class="headerlink" title="对于新增/删除匿名内部类，如何进行热部署？"></a>对于新增/删除匿名内部类，如何进行热部署？</h4><p><strong>编译器根据该匿名内部类在外部类中出现的先后关系，依次累加命名</strong></p><p>比如第一个匿名内部类叫DexFixDemo&amp;1。第二个叫DexFixDemo&amp;2，由于补丁工具拿到的是编译后的.class文件，所以无法区分DexFixDemo&amp;1/2类，所以要避免插入一个新的匿名内部类。</p><p><strong>当然如果匿名内部类在外部类的尾部，是允许的。</strong></p><h4 id="静态field初始化和静态代码块编译流程是什么样的？"><a href="#静态field初始化和静态代码块编译流程是什么样的？" class="headerlink" title="静态field初始化和静态代码块编译流程是什么样的？"></a>静态field初始化和静态代码块编译流程是什么样的？</h4><p>静态field和代码块初始化在编译后会放在<clinit>方法中</clinit></p><p><strong>静态代码块和静态域初始化在clinit中的先后关系就是两者出现在源码中的先后关系。</strong></p><p>尝试加载一个类的三个情况：</p><ol><li>new一个类的对象（new-instance指令）</li><li>调用类的静态方法（invoke-static指令）</li><li>获取类的静态域的值（sget指令）</li></ol><p>执行的流程是dvmResolve -&gt; Class -&gt; dvmLinkClass -&gt; dvmInitClass。</p><p>在dvmInitClass这个函数首先会对父类进行初始化，然后调用本类的clinit方法，所以此时静态field得到初始化和静态代码块得到执行。</p><p>父类初始化 ——&gt; 本类的静态field和代码块初始化</p><h4 id="非静态field初始化，非静态代码块编译流程是什么样的？"><a href="#非静态field初始化，非静态代码块编译流程是什么样的？" class="headerlink" title="非静态field初始化，非静态代码块编译流程是什么样的？"></a>非静态field初始化，非静态代码块编译流程是什么样的？</h4><p>非静态field初始化和非静态代码块被翻译在<init>无参构造函数中。</init></p><p><strong>构造函数会被android编译器翻译成<init>方法，实际上如果存在有参构造函数，那么每个有参构造函数都会执行一个非静态域的初始化和非静态代码块。</init></strong></p><p>String s = new String(“test”);在编译后翻译成如下代码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">new-instance vO, Ljava/lang/String;</span><br><span class="line">invoke-direct &#123;v0&#125;, Ljava/lang/String;-&gt;&lt;init&gt;()V</span><br></pre></td></tr></table></figure><ol><li>首先执行new-instance指令，分配堆内存</li><li>如果之前没加载过，尝试加载类</li><li>invoke-direct指令调用类的init构造函数方法执行对象的初始化</li></ol><h4 id="静态field-代码块和非静态field-代码块支持热部署吗？"><a href="#静态field-代码块和非静态field-代码块支持热部署吗？" class="headerlink" title="静态field/代码块和非静态field/代码块支持热部署吗？"></a>静态field/代码块和非静态field/代码块支持热部署吗？</h4><p>不支持<clint>方法的热部署，所以静态filed/代码块都不支持更改。</clint></p><p>对于非静态filed/代码块，热部署视为一个普通方法的变更，此时对于热部署没有影响。</p><h4 id="final-static域的编译是什么样的？"><a href="#final-static域的编译是什么样的？" class="headerlink" title="final static域的编译是什么样的？"></a>final static域的编译是什么样的？</h4><p><strong>final static的非引用类型并不是像static静态域一样被翻译到clinit方法中。</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public class DexFixDemo&#123;</span><br><span class="line">static Temp t1 = new Temp();</span><br><span class="line">final static Temp t2 = new Temp();</span><br><span class="line"></span><br><span class="line">final static String s1 = new String(&quot;heihei&quot;)l</span><br><span class="line">final static String s2 = &quot;haha&quot;;</span><br><span class="line"></span><br><span class="line">static int i1 = 1;</span><br><span class="line">final static int i2 = 2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上java文件转换为snail文件结构如下：</p><p><img src="https://note.youdao.com/yws/api/personal/file/WEBd684706583b05c1bffff55670cbf91ba?method=download&amp;shareKey=954664accf4fa1233f1103961f13f2f8" alt="snail文件结构"></p><p>我们可以看到 s2 = “haha”, i2 = 2,这两个并不是在clinit中赋值的。</p><p>通过查看dex文件结构，在类定义区看到</p><p><img src="https://note.youdao.com/yws/api/personal/file/WEBbd10638a6ebdd431b982e893228ec59c?method=download&amp;shareKey=95178b164654615aa60522c97a23b684" alt="dex类定义区"></p><p>所以得出以下结论：</p><ol><li>final static修饰的原始类型和String类型域（非引用类型），并不会翻译到clinit方法中，而是在类初始化执行initSFields方法中得到初始化赋值。</li><li>final static 修饰的引用类型，初始化仍然在clinit方法中。</li></ol><p>关于什么是smail文件，可以点此阅读，<a href="http://skyacer.github.io/2018/03/15/Smali%E6%B5%85%E6%9E%90%E5%8F%8Adex-java%E4%BA%92%E8%BD%AC/">smali浅析</a></p><h3 id="final-static-域优化原理"><a href="#final-static-域优化原理" class="headerlink" title="final static 域优化原理"></a>final static 域优化原理</h3><p>如果一个field是常量，通过final static优化只有原始类型和String类型域（非引用类型），<strong>如果是引用类型，实际上得不到任何优化。</strong></p><h4 id="final-static域初始化流程是什么样的？"><a href="#final-static域初始化流程是什么样的？" class="headerlink" title="final static域初始化流程是什么样的？"></a>final static域初始化流程是什么样的？</h4><p>const/4 -&gt; 操作数在dex中的位置就是在opcode后一个字节</p><h4 id="非final域的初始化流程是什么样的？"><a href="#非final域的初始化流程是什么样的？" class="headerlink" title="非final域的初始化流程是什么样的？"></a>非final域的初始化流程是什么样的？</h4><p>sget -&gt; dvmDexGetResolvedField -&gt; dvmResolveStaticField -&gt; dvmResolveClass -&gt; dvmGetStaticFieldInt(sfiled)</p><p>可见sget指令比const/4要复杂很多。</p><h4 id="为什么final-static引用类型没有得到优化？"><a href="#为什么final-static引用类型没有得到优化？" class="headerlink" title="为什么final static引用类型没有得到优化？"></a>为什么final static引用类型没有得到优化？</h4><p>因为不管是final，最后都是通过sget-object指令去获取该值。</p><h3 id="热部署对于final-static域的解决方案"><a href="#热部署对于final-static域的解决方案" class="headerlink" title="热部署对于final static域的解决方案"></a>热部署对于final static域的解决方案</h3><ul><li>修改final static 基本类型或者String类型域（非引用类型）域，由于编译器间引用到基本类型的地方被立即数替换，引用到String类型（非引用类型）的地方被常量池索引id替换，所以在热部署模式下，最终所有引用该final static域的方法都会被替换。实际上此时仍然可以走热部署。</li><li>修改final static引用类型域，是不允许的，因为这个field的初始化会被翻译到clinit方法中，所以此时没法走热部署。</li></ul><h2 id="哪些情况方法会被内联？"><a href="#哪些情况方法会被内联？" class="headerlink" title="哪些情况方法会被内联？"></a>哪些情况方法会被内联？</h2><ol><li>方法没有被其他任何地方引用到，毫无疑问，该方法会被内联掉。</li><li>方法足够简单，比如一个方法的实现就只有一行，该方法会被内联掉，那么任何调用该方法的地方都会被该方法的实现替换掉。</li><li>方法只被一个地方引用到，这个地方会被方法的实现替换掉。</li></ol><h2 id="混淆编译的过程是什么样的？"><a href="#混淆编译的过程是什么样的？" class="headerlink" title="混淆编译的过程是什么样的？"></a>混淆编译的过程是什么样的？</h2><p><img src="https://note.youdao.com/yws/api/personal/file/WEBe63e4e3ec814195a892f024501cbe134?method=download&amp;shareKey=9d67ecba60a5ead50987962705c6e7d0" alt="代码混淆"></p><h2 id="虚拟机对泛型是怎么处理的？"><a href="#虚拟机对泛型是怎么处理的？" class="headerlink" title="虚拟机对泛型是怎么处理的？"></a>虚拟机对泛型是怎么处理的？</h2><p><strong>虚拟机巧妙使用了桥方法的方式，解决了类型擦除和多态的冲突。</strong><br>通过bridge方法来重写父类方法。</p><p><img src="https://note.youdao.com/yws/api/personal/file/WEB77a5a0646dbcf09c96a4f4d1da96b5a3?method=download&amp;shareKey=71d1003ac6131c1e1d6b86ae3df0b720" alt="桥模式"></p><h2 id="jack工具链是什么？"><a href="#jack工具链是什么？" class="headerlink" title="jack工具链是什么？"></a>jack工具链是什么？</h2><p><img src="https://note.youdao.com/yws/api/personal/file/WEB73807b6621eac6d7424263b71fb99009?method=download&amp;shareKey=62d712969aa5238eea9fbf86986e6c33" alt=""></p><h2 id="热部署模式限制在哪？"><a href="#热部署模式限制在哪？" class="headerlink" title="热部署模式限制在哪？"></a>热部署模式限制在哪？</h2><p>不允许类结构变更以及不允许变更<clinit>方法，所以如果补丁发现这几种限制情况，那么只能走冷启动重启才能生效。</clinit></p><h2 id="QQ空间方案和Tinker方案有什么差异？"><a href="#QQ空间方案和Tinker方案有什么差异？" class="headerlink" title="QQ空间方案和Tinker方案有什么差异？"></a>QQ空间方案和Tinker方案有什么差异？</h2><p><img src="https://note.youdao.com/yws/api/personal/file/WEB908c8307401a73732757e4d664eda8a7?method=download&amp;shareKey=50d0fff07647ad9a031500455bee7d1f" alt=""></p><h2 id="类校验（dvmVerifyClass）和类优化（dvmOptimizeClass）有什么区别？"><a href="#类校验（dvmVerifyClass）和类优化（dvmOptimizeClass）有什么区别？" class="headerlink" title="类校验（dvmVerifyClass）和类优化（dvmOptimizeClass）有什么区别？"></a>类校验（dvmVerifyClass）和类优化（dvmOptimizeClass）有什么区别？</h2><p><img src="https://note.youdao.com/yws/api/personal/file/WEBeab708153e14bfb0f3dcf05fefabcc77?method=download&amp;shareKey=f684f6e9a5f4328ef6bc05a5d8525877" alt=""></p><h2 id="插桩是什么？有什么影响？"><a href="#插桩是什么？有什么影响？" class="headerlink" title="插桩是什么？有什么影响？"></a>插桩是什么？有什么影响？</h2><blockquote><p>插桩是指侵入dex打包流程，利用.class字节码修改技术，在所有.class文件的构造函数中引用这个帮助类，插桩由此而来。</p></blockquote><p>插桩会给类加载效率带来比较严重的影响，一个类的加载通常有三个阶段，dvmResolveClass -&gt; dvmLinkClass -&gt; d-vmlinitClass。</p><p>如果类没有被打上CLASS_ISPREVERIFIED/CLASS_ISOPTIMIZED标志，那么Verify和Optimize都会在类的初始阶段进行。如下图所示：</p><p><img src="https://note.youdao.com/yws/api/personal/file/WEB8e056ec53439569444345d2a6d4bfe62?method=download&amp;shareKey=7a4272072e462007bbc3c64705ad03fb" alt=""></p><p>虽然会有性能开销，但是每个类只会加载一次，由jdk1.2版本后虚拟机的<a href="http://skyacer.github.io/2018/05/06/Java%E8%99%9A%E6%8B%9F%E6%9C%BA%E2%80%94%E2%80%94%E5%8F%8C%E4%BA%B2%E5%A7%94%E6%B4%BE%E6%A8%A1%E5%9E%8B/">双亲委派模型</a>决定的，但是在刚启动时的白屏启动页会加载大量的类，此时影响还是比较大。</p><h2 id="QFix是怎么绕过类验证的？"><a href="#QFix是怎么绕过类验证的？" class="headerlink" title="QFix是怎么绕过类验证的？"></a>QFix是怎么绕过类验证的？</h2><p><img src="https://note.youdao.com/yws/api/personal/file/WEBdef42baa022012ffea1b008ef697bc82?method=download&amp;shareKey=8e08f6e6ff1a3701e3cb5e834637b0df" alt="QFix"></p><p>详细来说就是通过dlsym拿到该so库的dvmResolveClass/dvmFindLoadedClass函数指针，首先预加载引用类，这样dvmFindLoadedClass才不会为null，dvmFindLoadedClass执行结果得到ClassObject做为第一个参数执行dvmResolveClass(AnimRes, 2425, true)即可。</p><h2 id="Dalvik虚拟机加载一个压缩文件是什么过程？"><a href="#Dalvik虚拟机加载一个压缩文件是什么过程？" class="headerlink" title="Dalvik虚拟机加载一个压缩文件是什么过程？"></a>Dalvik虚拟机加载一个压缩文件是什么过程？</h2><p>Dalvik尝试加载一个压缩文件的时候，只会去把classes.dex加载到内存中。除了classes.dex之外的其他dex被直接忽略掉。</p><h2 id="Art虚拟机加载一个压缩文件是什么过程？"><a href="#Art虚拟机加载一个压缩文件是什么过程？" class="headerlink" title="Art虚拟机加载一个压缩文件是什么过程？"></a>Art虚拟机加载一个压缩文件是什么过程？</h2><p>Art虚拟机的方法调用链如下：<strong>DexFile_openDexFileNative -&gt; OpenDexFilesFromOat -&gt; LoadDexFiles</strong></p><p>在LoadDexFiles中，我们可以看出，虽然Art默认支持加载压缩文件中包含多个dex的情况， 优先加载primary dex这个classes.dex，虽然后续会加载其他dex，补丁类只需要放到classes.dex即可。后续出现在其它dex中的补丁类<strong>是不会被重复加载的</strong>。</p><h2 id="通过替换dex的方案思路是什么样的？"><a href="#通过替换dex的方案思路是什么样的？" class="headerlink" title="通过替换dex的方案思路是什么样的？"></a>通过替换dex的方案思路是什么样的？</h2><p>我们只要把补丁dex命名为classes.dex。原apk中的dex依次命名为classes(2,3,4…)dex就好了，然后一起打包为一个压缩文件。然后DexFile.loadDex得到DexFile对象，最后把该DexFile对象整个替换为旧的dexElements数组就可以了。</p><h2 id="Tinker和Sophix在合成dex时有什么区别？"><a href="#Tinker和Sophix在合成dex时有什么区别？" class="headerlink" title="Tinker和Sophix在合成dex时有什么区别？"></a>Tinker和Sophix在合成dex时有什么区别？</h2><p><img src="https://note.youdao.com/yws/api/personal/file/WEB38fe2b039574bf7f8533ec05274d1f42?method=download&amp;shareKey=229b0248f29871199010f9ddfc416a4e" alt=""></p><ul><li>补丁dex必须命名为classes.dex</li><li>loadDex 得到的DexFile完整替换掉dexElements数组而不是插入</li></ul><h2 id="在冷启动修复过程中遇到哪些性能问题？怎么解决的？"><a href="#在冷启动修复过程中遇到哪些性能问题？怎么解决的？" class="headerlink" title="在冷启动修复过程中遇到哪些性能问题？怎么解决的？"></a>在冷启动修复过程中遇到哪些性能问题？怎么解决的？</h2><p>在加载dex文件到native内存之前，如果dex不存在对应的odex，那么Dalvik下会执行dexopt，Art下会执行dexoat，最后得到的都是一个优化后的odex。<strong>虚拟机最后执行的都是odex而不是dex。</strong></p><p>如果dex足够大，那么dexopt(Dalvik)/dexoat(Art)是很耗时的。Dalvik稍微好一点在于只会load classes.dex(也就是补丁包)，而在Art下，load的是dex和apk的原dex合并的完整补丁包（Tinker方案），这样的dexoat非常耗时。</p><p>解决方式：<br>把loadDex当做一个事物来看，如果中途被打断，那么就删除odex文件，重启的时候如果发现存在odex文件，loadDex完之后，反射注入/替换dexElements数组，实现patch。如果不存在odex文件，重启另一个子线程loadDex，重启之后再生效。<br>对于补丁包的安全性，我们需要对补丁包进行签名校验与md5校验。</p><h2 id="怎么实现Dalvik和Art下共用一套补丁？"><a href="#怎么实现Dalvik和Art下共用一套补丁？" class="headerlink" title="怎么实现Dalvik和Art下共用一套补丁？"></a>怎么实现Dalvik和Art下共用一套补丁？</h2><ul><li>Dalvik下采用自行研发的全量DEX方案</li><li>Art下虚拟机已经支持多dex，只需要把补丁dex作为主dex即可</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Android热修复笔记&quot;&gt;&lt;a href=&quot;#Android热修复笔记&quot; class=&quot;headerlink&quot; title=&quot;Android热修复笔记&quot;&gt;&lt;/a&gt;Android热修复笔记&lt;/h1&gt;&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;
      
    
    </summary>
    
      <category term="Android" scheme="http://skyacer.github.io/categories/Android/"/>
    
    
      <category term="热修复" scheme="http://skyacer.github.io/tags/%E7%83%AD%E4%BF%AE%E5%A4%8D/"/>
    
  </entry>
  
  <entry>
    <title>Java虚拟机——双亲委派模型</title>
    <link href="http://skyacer.github.io/2018/05/06/Java%E8%99%9A%E6%8B%9F%E6%9C%BA%E2%80%94%E2%80%94%E5%8F%8C%E4%BA%B2%E5%A7%94%E6%B4%BE%E6%A8%A1%E5%9E%8B/"/>
    <id>http://skyacer.github.io/2018/05/06/Java虚拟机——双亲委派模型/</id>
    <published>2018-05-06T13:58:40.000Z</published>
    <updated>2018-05-06T13:59:18.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="双亲委派模型"><a href="#双亲委派模型" class="headerlink" title="双亲委派模型"></a>双亲委派模型</h1><div class="htmledit_views"><br>                <p><span style="font-size:18px;">说道双亲委派模型，就要从类加载器说起。。。。。。。。。。。</span></p><p></p><p style="margin-top:0px;margin-bottom:0px;padding-top:0px;padding-bottom:0px;font-family:Arial;line-height:26px;"><span style="font-size:18px;">Java虚拟机类加载过程是把Class类文件加载到内存，并对Class文件中的数据进行校验、转换解析和初始化，最终形成可以被虚拟机直接使用的java类型的过程。</span></p><p style="margin-top:0px;margin-bottom:0px;padding-top:0px;padding-bottom:0px;font-family:Arial;line-height:26px;"><span style="font-size:18px;">在加载阶段，java虚拟机需要完成以下3件事：</span></p><p style="margin-top:0px;margin-bottom:0px;padding-top:0px;padding-bottom:0px;font-family:Arial;line-height:26px;"><span style="font-size:18px;color:#cc66cc;">a.通过一个类的全限定名来获取定义此类的二进制字节流。</span></p><p style="margin-top:0px;margin-bottom:0px;padding-top:0px;padding-bottom:0px;font-family:Arial;line-height:26px;"><span style="font-size:18px;color:#cc66cc;">b.将定义类的二进制字节流所代表的静态存储结构转换为方法区的运行时数据结构。</span></p><p style="margin-top:0px;margin-bottom:0px;padding-top:0px;padding-bottom:0px;font-family:Arial;line-height:26px;"><span style="font-size:18px;color:#cc66cc;">c.在java堆中生成一个代表该类的java.lang.Class对象，作为方法区数据的访问入口。</span></p><span style="font-size:18px;">而类的加载过程是通过类加载器完成的。</span><p><span style="font-size:18px;"><br></span></p><p><span style="font-size:18px;"><span style="font-family:Arial;line-height:26px;">在Java中，任意一个类都需要由加载它的类加载器和这个类本身一同确定其在java虚拟机中的唯一性，即比较两个类是否相等，只有在这两个类是由同一个类加载器加载的前提之下才有意义，否则，即使这两个类来源于同一个Class类文件，只要加载它的类加载器不相同，那么这两个类必定不相等(这里的相等包括代表类的Class对象的equals()方法、isAssignableFrom()方法、isInstance()方法和instanceof关键字的结果)。</span><br></span></p><p><span style="font-family:Arial;line-height:26px;"><span style="font-size:18px;">看下面的例子：</span></span></p><div class="dp-highlighter bg_java"><div class="bar"><div class="tools"><b>[java]</b> <a href="#" class="ViewSource" title="view plain" onclick="dp.sh.Toolbar.Command('ViewSource',this);return false;">view plain</a><span data-mod="popu_168"> <a href="#" class="CopyToClipboard" title="copy" onclick="dp.sh.Toolbar.Command('CopyToClipboard',this);return false;">copy</a><div style="position: absolute; left: 190px; top: 763px; width: 16px; height: 16px; z-index: 99;"><embed id="ZeroClipboardMovie_1" src="https://csdnimg.cn/public/highlighter/ZeroClipboard.swf" loop="false" menu="false" quality="best" bgcolor="#ffffff" width="16" height="16" name="ZeroClipboardMovie_1" align="middle" allowscriptaccess="always" allowfullscreen="false" type="application/x-shockwave-flash" pluginspage="http://www.macromedia.com/go/getflashplayer" flashvars="id=1&amp;width=16&amp;height=16" wmode="transparent"></div><div style="position: absolute; left: 190px; top: 763px; width: 16px; height: 16px; z-index: 99;"><embed id="ZeroClipboardMovie_3" src="https://csdnimg.cn/public/highlighter/ZeroClipboard.swf" loop="false" menu="false" quality="best" bgcolor="#ffffff" width="16" height="16" name="ZeroClipboardMovie_3" align="middle" allowscriptaccess="always" allowfullscreen="false" type="application/x-shockwave-flash" pluginspage="http://www.macromedia.com/go/getflashplayer" flashvars="id=3&amp;width=16&amp;height=16" wmode="transparent"></div></span><span data-mod="popu_169"> <a href="#" class="PrintSource" title="print" onclick="dp.sh.Toolbar.Command('PrintSource',this);return false;">print</a></span><a href="#" class="About" title="?" onclick="dp.sh.Toolbar.Command('About',this);return false;">?</a></div></div><ol start="1" class="dp-j"><li class="alt"><span><span>&nbsp;&nbsp;</span></span></li></ol></div><pre class="java" name="code" style="display: none;"></pre><pre style="background-color:#2b2b2b;color:#a9b7c6;font-family:'Courier New';font-size:11.3pt;"><span style="color:#cc7832;">package </span>com.hfax.common.depository.front.test<span style="color:#cc7832;">;<br></span><span style="color:#cc7832;"><br></span><span style="color:#cc7832;">import </span>java.io.IOException<span style="color:#cc7832;">;<br></span><span style="color:#cc7832;">import </span>java.io.InputStream<span style="color:#cc7832;">;<br></span><span style="color:#cc7832;"><br></span><span style="color:#cc7832;"><br></span><span style="color:#cc7832;">public class </span>test2 {<br>    <span style="color:#cc7832;">public static void </span><span style="color:#ffc66d;">main</span>(String[] args)<span style="color:#cc7832;">throws </span>Exception{<br>        <span style="color:#808080;">//匿名内部类实现自定义类加载器<br></span><span style="color:#808080;">        </span><span style="color:#cc7832;">final </span>ClassLoader  myClassLoader = <span style="color:#cc7832;">new </span>ClassLoader(){<br>                <span style="color:#cc7832;">protected </span>Class&lt;?&gt; <span style="color:#ffc66d;">findClass</span>(String name)<span style="color:#cc7832;">throws </span>ClassNotFoundException {<br>                    <span style="color:#808080;">//获取类文件名<br></span><span style="color:#808080;">                    </span>String filename = name.substring(name.lastIndexOf(<span style="color:#6a8759;">“.”</span>) + <span style="color:#6897bb;">1</span>) + <span style="color:#6a8759;">“.class”</span><span style="color:#cc7832;">;<br></span><span style="color:#cc7832;">                    </span>InputStream in = getClass().getResourceAsStream(filename)<span style="color:#cc7832;">;<br></span><span style="color:#cc7832;">                    try </span>{<br>                        <span style="color:#cc7832;">byte</span>[] b = <span style="color:#cc7832;">new byte</span>[in.available()]<span style="color:#cc7832;">;<br></span><span style="color:#cc7832;">                        return </span>defineClass(name<span style="color:#cc7832;">, </span>b<span style="color:#cc7832;">, </span><span style="color:#6897bb;">0</span><span style="color:#cc7832;">, </span>b.<span style="color:#9876aa;">length</span>)<span style="color:#cc7832;">;<br></span><span style="color:#cc7832;">                    </span>} <span style="color:#cc7832;">catch </span>(IOException e) {<br>                        <span style="color:#cc7832;">throw new </span>ClassNotFoundException(name)<span style="color:#cc7832;">;<br></span><span style="color:#cc7832;">                    </span>}<br>                }<br>        }<span style="color:#cc7832;">;<br></span><span style="color:#cc7832;">        </span>Object obj = myClassLoader.loadClass(<span style="color:#6a8759;">“com.hfax.common.depository.front.test.test2”</span>).newInstance()<span style="color:#cc7832;">;<br></span><span style="color:#cc7832;">        </span>System.<span style="color:#9876aa;"><em>out</em></span>.println(obj.getClass())<span style="color:#cc7832;">;<br></span><span style="color:#cc7832;">        </span>System.<span style="color:#9876aa;"><em>out</em></span>.println(obj <span style="color:#cc7832;">instanceof </span>com.hfax.common.depository.front.test.test2)<span style="color:#cc7832;">;<br></span><span style="color:#cc7832;">    </span>}<br>}<br></pre><br><p></p><p style="margin-top:0px;margin-bottom:0px;padding-top:0px;padding-bottom:0px;font-family:Arial;line-height:26px;">输出结果如下：</p><p style="margin-top:0px;margin-bottom:0px;padding-top:0px;padding-bottom:0px;font-family:Arial;line-height:26px;">com.test.ClassLoaderTest</p><p style="margin-top:0px;margin-bottom:0px;padding-top:0px;padding-bottom:0px;font-family:Arial;line-height:26px;">false （<span style="color:#ff6666;">jdk1.2版本以后引入了双亲委派模型后，此时会返回true，想得到false结果的小伙伴可以用1.2以前的版本测试</span>）</p><p style="margin-top:0px;margin-bottom:0px;padding-top:0px;padding-bottom:0px;font-family:Arial;line-height:26px;">之所以instanceof会返回false，是因为com.test.ClassLoaderTest类默认使用Application ClassLoader加载，而obj是通过自定义类加载器加载的，类加载不相同，因此不相等。</p><br><p><span style="font-family:Arial;line-height:26px;"><span style="font-size:18px;">说到这里就轮到双亲委派模型出场了。</span></span></p><p><span style="font-family:Arial;line-height:26px;"><span style="font-size:18px;">先看双亲委派模型的经典体系统：</span></span></p><p style="text-align:center;"><span style="font-family:Arial;line-height:26px;"><span style="font-size:18px;"><img src="https://img-blog.csdn.net/20160102154038185" alt=""><br></span></span></p><p style="text-align:left;"><span style="font-family:Arial;line-height:26px;"><span style="font-size:18px;">做一个简单解释：</span></span></p><p style="text-align:left;"><span style="font-family:Arial;line-height:26px;"><span style="font-size:18px;"></span></span></p><p style="margin-top:0px;margin-bottom:0px;padding-top:0px;padding-bottom:0px;font-family:Arial;line-height:26px;">(1).BootStrap ClassLoader：启动类加载器，负责加载存放在%JAVA_HOME%\lib目录中的，或者通被-Xbootclasspath参数所指定的路径中的，并且被java虚拟机识别的(仅按照文件名识别，如rt.jar，名字不符合的类库，即使放在指定路径中也不会被加载)类库到虚拟机的内存中，启动类加载器无法被java程序直接引用。</p><p style="margin-top:0px;margin-bottom:0px;padding-top:0px;padding-bottom:0px;font-family:Arial;line-height:26px;">(2).Extension ClassLoader：扩展类加载器，由sun.misc.Launcher$ExtClassLoader实现，负责加载%JAVA_HOME%\lib\ext目录中的，或者被java.ext.dirs系统变量所指定的路径中的所有类库，开发者可以直接使用扩展类加载器。</p><p style="margin-top:0px;margin-bottom:0px;padding-top:0px;padding-bottom:0px;font-family:Arial;line-height:26px;">(3).Application ClassLoader：应用程序类加载器，由sun.misc.Launcher$AppClassLoader实现，负责加载用户类路径classpath上所指定的类库，是类加载器ClassLoader中的getSystemClassLoader()方法的返回值，开发者可以直接使用应用程序类加载器，如果程序中没有自定义过类加载器，该加载器就是程序中默认的类加载器。</p><br><p style="text-align:left;"><span style="font-family:Arial;line-height:26px;"><span style="font-size:18px;"><span style="color:#ff0000;">这里需要注意的是<span style="font-family:Arial;line-height:26px;">上述三个JDK提供的类加载器虽然是父子类加载器关系，但是没有使用继承，而是使用了组合关系。</span></span></span></span></p><p style="text-align:left;"><span style="font-family:Arial;line-height:26px;"><span style="font-family:Arial;line-height:26px;"><span style="font-size:18px;"></span></span></span></p><p style="margin-top:0px;margin-bottom:0px;padding-top:0px;padding-bottom:0px;font-family:Arial;line-height:26px;"><span style="color:#3366ff;">从JDK1.2开始，java虚拟机规范推荐开发者使用双亲委派模式(ParentsDelegation Model)进行类加载，其加载过程如下：</span></p><p style="margin-top:0px;margin-bottom:0px;padding-top:0px;padding-bottom:0px;font-family:Arial;line-height:26px;"><span style="color:#3366ff;">(1).如果一个类加载器收到了类加载请求，它首先不会自己去尝试加载这个类，而是把类加载请求委派给父类加载器去完成。</span></p><p style="margin-top:0px;margin-bottom:0px;padding-top:0px;padding-bottom:0px;font-family:Arial;line-height:26px;"><span style="color:#3366ff;">(2).每一层的类加载器都把类加载请求委派给父类加载器，直到所有的类加载请求都应该传递给顶层的启动类加载器。</span></p><p style="margin-top:0px;margin-bottom:0px;padding-top:0px;padding-bottom:0px;font-family:Arial;line-height:26px;"><span style="color:#3366ff;">(3).如果顶层的启动类加载器无法完成加载请求，子类加载器尝试去加载，如果连最初发起类加载请求的类加载器也无法完成加载请求时，将会抛出ClassNotFoundException，而不再调用其子类加载器去进行类加载。</span></p><span style="font-family:Arial;line-height:26px;"><span style="color:#3366ff;">双亲委派 模式的类加载机制的优点是java类它的类加载器一起具备了一种带优先级的层次关系，越是基础的类，越是被上层的类加载器进行加载，保证了java程序的稳定运行。双亲委派模式的实现：</span></span><br><p style="text-align:left;"><span style="font-family:Arial;line-height:26px;"><span style="font-family:Arial;line-height:26px;"><span style="font-family:Arial;line-height:26px;"><span style="font-size:18px;"></span></span></span></span></p><div class="dp-highlighter bg_java"><div class="bar"><div class="tools"><b>[java]</b> <a href="#" class="ViewSource" title="view plain" onclick="dp.sh.Toolbar.Command('ViewSource',this);return false;">view plain</a><span data-mod="popu_168"> <a href="#" class="CopyToClipboard" title="copy" onclick="dp.sh.Toolbar.Command('CopyToClipboard',this);return false;">copy</a><div style="position: absolute; left: 190px; top: 2676px; width: 16px; height: 16px; z-index: 99;"><embed id="ZeroClipboardMovie_2" src="https://csdnimg.cn/public/highlighter/ZeroClipboard.swf" loop="false" menu="false" quality="best" bgcolor="#ffffff" width="16" height="16" name="ZeroClipboardMovie_2" align="middle" allowscriptaccess="always" allowfullscreen="false" type="application/x-shockwave-flash" pluginspage="http://www.macromedia.com/go/getflashplayer" flashvars="id=2&amp;width=16&amp;height=16" wmode="transparent"></div><div style="position: absolute; left: 190px; top: 2676px; width: 16px; height: 16px; z-index: 99;"><embed id="ZeroClipboardMovie_4" src="https://csdnimg.cn/public/highlighter/ZeroClipboard.swf" loop="false" menu="false" quality="best" bgcolor="#ffffff" width="16" height="16" name="ZeroClipboardMovie_4" align="middle" allowscriptaccess="always" allowfullscreen="false" type="application/x-shockwave-flash" pluginspage="http://www.macromedia.com/go/getflashplayer" flashvars="id=4&amp;width=16&amp;height=16" wmode="transparent"></div></span><span data-mod="popu_169"> <a href="#" class="PrintSource" title="print" onclick="dp.sh.Toolbar.Command('PrintSource',this);return false;">print</a></span><a href="#" class="About" title="?" onclick="dp.sh.Toolbar.Command('About',this);return false;">?</a></div></div><ol start="1" class="dp-j"><li class="alt"><span><span>&nbsp;&nbsp;</span></span></li></ol></div><pre class="java" name="code" style="display: none;"></pre><pre style="background-color:#2b2b2b;color:#a9b7c6;font-family:'Courier New';font-size:11.3pt;"><span style="color:#cc7832;">protected synchronized </span>Class&lt;?&gt; <span style="color:#ffc66d;">loadClass</span>(String name<span style="color:#cc7832;">, </span>Boolean resolve) <span style="color:#cc7832;">throws </span>ClassNotFoundException{<br>    <span style="color:#808080;">//首先检查请求的类是否已经被加载过<br></span><span style="color:#808080;">    </span>Class c = findLoadedClass(name)<span style="color:#cc7832;">;<br></span><span style="color:#cc7832;">    if</span>(c == <span style="color:#cc7832;">null</span>){<br><br>        <span style="color:#cc7832;">try</span>{<br>            <span style="color:#cc7832;">if</span>(parent != <span style="color:#cc7832;">null</span>){<span style="color:#808080;">//委派父类加载器加载<br></span><span style="color:#808080;">                </span>c = parent.loadClass(name<span style="color:#cc7832;">, false</span>)<span style="color:#cc7832;">;<br></span><span style="color:#cc7832;">            </span>}<br>            <span style="color:#cc7832;">else</span>{<span style="color:#808080;">//委派启动类加载器加载<br></span><span style="color:#808080;">                </span>c = findBootstrapClassOrNull(name)<span style="color:#cc7832;">;<br></span><span style="color:#cc7832;">            </span>}<br>        }<span style="color:#cc7832;">catch</span>(ClassNotFoundException e){<br>            <span style="color:#808080;">//父类加载器无法完成类加载请求<br></span><span style="color:#808080;">        </span>}<br>        <span style="color:#cc7832;">if</span>(c == <span style="color:#cc7832;">null</span>){<span style="color:#808080;">//本身类加载器进行类加载<br></span><span style="color:#808080;">            </span>c = findClass(name)<span style="color:#cc7832;">;<br></span><span style="color:#cc7832;">        </span>}<br>    }<br>    <span style="color:#cc7832;">if</span>(resolve){<br>        resolveClass(c)<span style="color:#cc7832;">;<br></span><span style="color:#cc7832;">    </span>}<br>    <span style="color:#cc7832;">return </span>c<span style="color:#cc7832;">;<br></span>}</pre><br>通过双亲委派模型我们就能很好解决文章开始我们自定义的类加载器所出现的问题。<p></p><p style="text-align:left;"><span style="font-family:Arial;line-height:26px;"><span style="font-family:Arial;line-height:26px;"><span style="font-family:Arial;line-height:26px;"><span style="font-size:18px;color:#ff0000;">这里需要注意的是<span style="font-family:Arial;line-height:26px;">在JDK1.2之前，类加载尚未引入双亲委派模式，因此实现自定义类加载器时常常重写loadClass方法，提供双亲委派逻辑，从JDK1.2之后，双亲委派模式已经被引入到类加载体系中，自定义类加载器时不需要在自己写双亲委派的逻辑，因此不鼓励重写loadClass方法，而推荐重写findClass方法。</span></span></span></span></span></p>            </div>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;双亲委派模型&quot;&gt;&lt;a href=&quot;#双亲委派模型&quot; class=&quot;headerlink&quot; title=&quot;双亲委派模型&quot;&gt;&lt;/a&gt;双亲委派模型&lt;/h1&gt;&lt;div class=&quot;htmledit_views&quot;&gt;&lt;br&gt;                &lt;p&gt;&lt;span 
      
    
    </summary>
    
      <category term="基础知识" scheme="http://skyacer.github.io/categories/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    
    
      <category term="JAVA" scheme="http://skyacer.github.io/tags/JAVA/"/>
    
  </entry>
  
  <entry>
    <title>你想知道的HashMap</title>
    <link href="http://skyacer.github.io/2018/05/06/%E4%BD%A0%E6%83%B3%E7%9F%A5%E9%81%93%E7%9A%84HashMap/"/>
    <id>http://skyacer.github.io/2018/05/06/你想知道的HashMap/</id>
    <published>2018-05-06T08:06:59.000Z</published>
    <updated>2018-05-31T08:08:17.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="你想知道的HashMap，ConcurrentHashMap-锁机制"><a href="#你想知道的HashMap，ConcurrentHashMap-锁机制" class="headerlink" title="你想知道的HashMap，ConcurrentHashMap,锁机制"></a>你想知道的HashMap，ConcurrentHashMap,锁机制</h1><h2 id="为什么HashMap线程不安全？"><a href="#为什么HashMap线程不安全？" class="headerlink" title="为什么HashMap线程不安全？"></a>为什么HashMap线程不安全？</h2><ol><li>如果此时正好存在两个 put 的 key 发生了碰撞(根据 hash 值计算的 bucket 一样)，那么根据 HashMap 的实现，这两个 key 会添加到数组的同一个位置，这样最终就会发生其中一个线程的 put 的数据被覆盖。</li><li>如果多个线程同时检测到元素个数超过数组大小* loadFactor ，这样就会发生多个线程同时对 Node 数组进行扩容，都在重新计算元素位置以及复制数据，但是最终只有一个线程扩容后的数组会赋给 table，也就是说其他线程的都会丢失，并且各自线程 put 的数据也丢失。</li></ol><h2 id="HashMap工作原理是什么？"><a href="#HashMap工作原理是什么？" class="headerlink" title="HashMap工作原理是什么？"></a>HashMap工作原理是什么？</h2><p>通过hash的方法，通过put和get存储和获取对象。存储对象时，我们将K/V传给put方法时，它调用hashCode计算hash从而得到bucket位置，进一步存储，HashMap会根据当前bucket的占用情况自动调整容量(超过Load Facotr则resize为原来的2倍)。获取对象时，我们将K传给get，它调用hashCode计算hash从而得到bucket位置，并进一步调用equals()方法确定键值对。如果发生碰撞的时候，Hashmap通过链表将产生碰撞冲突的元素组织起来，在Java 8中，如果一个bucket中碰撞冲突的元素超过某个限制(默认是8)，则使用红黑树来替换链表，从而提高速度。</p><h2 id="HashMap的hash函数是怎么实现的？"><a href="#HashMap的hash函数是怎么实现的？" class="headerlink" title="HashMap的hash函数是怎么实现的？"></a>HashMap的hash函数是怎么实现的？</h2><p><img src="https://note.youdao.com/yws/api/personal/file/WEBb5a0f030f26093770b46ab0ce5441e12?method=download&amp;shareKey=9849ad8d9e67a5002373acadc1bcd37b" alt="hash过程"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">static final int hash(Object key) &#123;</span><br><span class="line">    int h;</span><br><span class="line">    return (key == null) ? 0 : (h = key.hashCode()) ^ (h &gt;&gt;&gt; 16);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="HashMap的Resize实现是什么？"><a href="#HashMap的Resize实现是什么？" class="headerlink" title="HashMap的Resize实现是什么？"></a>HashMap的Resize实现是什么？</h2><p>当put时，如果发现目前的bucket占用程度已经超过了Load Factor所希望的比例（默认是0.75），那么就会发生resize。在resize的过程，简单的说就是把bucket扩充为2倍，之后重新计算index，把节点再放到新的bucket中。resize的注释是这样描述的：</p><p><img src="https://note.youdao.com/yws/api/personal/file/WEB0bc80d064a1d7246a6b74d5ba08f2e74?method=download&amp;shareKey=dcc5a2b85ccd2b559a3453defb55dba9" alt=""></p><p>因此元素在重新计算hash之后，因为n变为2倍，那么n-1的mask范围在高位多1bit(红色)，因此新的index就会发生这样的变化：</p><p><img src="https://note.youdao.com/yws/api/personal/file/WEB286b40b60817b00ca67708af92bd6cdd?method=download&amp;shareKey=0412c14a50b377a1fd6ff6e8bdb717cb" alt=""></p><p>因此，我们在扩充HashMap的时候，不需要重新计算hash，只需要看看原来的hash值新增的那个bit是1还是0就好了，是0的话索引没变，是1的话索引变成“原索引+oldCap”。可以看看下图为16扩充为32的resize示意图：</p><p><img src="https://note.youdao.com/yws/api/personal/file/WEB04e8367bff6229238de7ab2abdb9ce4d?method=download&amp;shareKey=0edc15e5ec1d9c83ef2d1e911fb0cc00" alt=""></p><p>这个设计确实非常的巧妙，既省去了重新计算hash值的时间，而且同时，由于新增的1bit是0还是1可以认为是随机的，因此resize的过程，均匀的把之前的冲突的节点分散到新的bucket了。</p><p><strong>注意HashMap可存储的最大容量是有限的，最大为2的30次方。</strong></p><h2 id="重入锁是什么？"><a href="#重入锁是什么？" class="headerlink" title="重入锁是什么？"></a>重入锁是什么？</h2><p>当一个线程得到一个对象后，再次请求该对象锁时是可以再次得到该对象的锁的。</p><p>简而言之：自己可以再次获取自己的内部锁</p><p>在Java中，sychronized和ReetranLock都是可重入的。</p><p>例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">public class SynchronizedTest &#123;</span><br><span class="line">    public void method1() &#123;</span><br><span class="line">        synchronized (SynchronizedTest.class) &#123;</span><br><span class="line">            System.out.println(&quot;方法1获得ReentrantTest的锁运行了&quot;);</span><br><span class="line">            method2();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    public void method2() &#123;</span><br><span class="line">        synchronized (SynchronizedTest.class) &#123;</span><br><span class="line">            System.out.println(&quot;方法1里面调用的方法2重入锁,也正常运行了&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        new SynchronizedTest().method1();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面便是synchronized的重入锁特性，即调用method1()方法时，已经获得了锁，此时内部调用method2()方法时，由于本身已经具有该锁，所以可以再次获取。</p><p>ReentrantLock锁类似，代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">public class ReentrantLockTest &#123;</span><br><span class="line">    private Lock lock = new ReentrantLock();</span><br><span class="line">    public void method1() &#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        try &#123;</span><br><span class="line">            System.out.println(&quot;方法1获得ReentrantLock锁运行了&quot;);</span><br><span class="line">            method2();</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    public void method2() &#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        try &#123;</span><br><span class="line">            System.out.println(&quot;方法1里面调用的方法2重入ReentrantLock锁,也正常运行了&quot;);</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        new ReentrantLockTest().method1();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="公平锁是什么？"><a href="#公平锁是什么？" class="headerlink" title="公平锁是什么？"></a>公平锁是什么？</h2><p>CPU在调度线程的时候是在等待队列里随机挑选一个线程，由于这种随机性所以是无法保证线程先到先得的（synchronized控制的锁就是这种非公平锁）。但这样就会产生饥饿现象，即有些线程（优先级较低的线程）可能永远也无法获取CPU的执行权，优先级高的线程会不断的强制它的资源。那么如何解决饥饿问题呢，这就需要公平锁了。公平锁可以保证线程<strong>按照时间的先后顺序</strong>执行，避免饥饿现象的产生。但公平锁的效率比较低，因为要实现顺序执行，需要维护一个有序队列。</p><p>ReentrantLock同样支持公平锁，在构造函数中，传入true就是公平锁</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public ReentrantLock(boolean fair) &#123;</span><br><span class="line">        sync = fair ? new FairSync() : new NonfairSync();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="synchronized和ReentrantLock有什么区别呢？"><a href="#synchronized和ReentrantLock有什么区别呢？" class="headerlink" title="synchronized和ReentrantLock有什么区别呢？"></a>synchronized和ReentrantLock有什么区别呢？</h2><ol><li>Lock是一个接口，而synchronized是Java中的关键字，synchronized是内置的语言实现；</li><li>synchronized在发生异常时，会自动释放线程占有的锁，因此不会导致死锁现象发生；而Lock在发生异常时，如果没有主动通过unLock()去释放锁，则很可能造成死锁现象，因此使用Lock时需要在finally块中释放锁；</li><li>Lock可以让等待锁的线程响应中断，而synchronized却不行，使用synchronized时，等待的线程会一直等待下去，不能够响应中断；</li><li>通过Lock可以知道有没有成功获取锁，而synchronized却无法办到。</li><li>Lock可以提高多个线程进行读操作的效率。</li><li>synchronized就不是可中断锁，而Lock是可中断锁。</li><li>synchronized就是非公平锁，它无法保证等待的线程获取锁的顺序。ReentrantLock可以设置成公平锁。</li><li>ReentrantReadWriteLock是读写锁，synchronized不支持读写锁。</li><li>一个ReentrantLock对象可以同时绑定多个Condition对象，而在synchronized中，锁对象的wait()和notify()或notifyAll()方法可以实现一个隐含的条件，如果要和多余一个条件关联的时候，就不得不额外地添加一个锁，而ReentrantLock则无须这么做，只需要多次调用new Condition()方法即可。</li><li>在性能上来说，如果竞争资源不激烈，两者的性能是差不多的，而当竞争资源非常激烈时（即有大量线程同时竞争），此时ReentrantLock的性能要远远优于synchronized。</li><li>上述说的都是jdk1.5及以前，在jdk1.6之后，synchronized做了很多优化，包括锁消除，偏向锁等等，官方提倡优先考虑用synchronized来进行同步。</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;你想知道的HashMap，ConcurrentHashMap-锁机制&quot;&gt;&lt;a href=&quot;#你想知道的HashMap，ConcurrentHashMap-锁机制&quot; class=&quot;headerlink&quot; title=&quot;你想知道的HashMap，ConcurrentH
      
    
    </summary>
    
      <category term="JAVA" scheme="http://skyacer.github.io/categories/JAVA/"/>
    
    
      <category term="容器" scheme="http://skyacer.github.io/tags/%E5%AE%B9%E5%99%A8/"/>
    
  </entry>
  
  <entry>
    <title>HTTP浅析（二）HTTP结构</title>
    <link href="http://skyacer.github.io/2018/05/04/HTTP%E6%B5%85%E6%9E%90%EF%BC%88%E4%BA%8C%EF%BC%89HTTP%E7%BB%93%E6%9E%84/"/>
    <id>http://skyacer.github.io/2018/05/04/HTTP浅析（二）HTTP结构/</id>
    <published>2018-05-04T06:33:40.000Z</published>
    <updated>2018-05-04T06:34:24.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="HTTP浅析（二）HTTP结构"><a href="#HTTP浅析（二）HTTP结构" class="headerlink" title="HTTP浅析（二）HTTP结构"></a>HTTP浅析（二）HTTP结构</h1><blockquote><p>本篇主要介绍HTTP服务器、代理、缓存等</p></blockquote><h2 id="web服务器主流有哪几种？"><a href="#web服务器主流有哪几种？" class="headerlink" title="web服务器主流有哪几种？"></a>web服务器主流有哪几种？</h2><ul><li>免费的Apache软件占据了所有web服务器大约60%的市场</li><li>微软的Web服务器占据了另外30%</li><li>Sun的iPlanet占据了另外的3%</li></ul><p><strong>数据仅供参考</strong></p><h2 id="web服务器会做些什么？"><a href="#web服务器会做些什么？" class="headerlink" title="web服务器会做些什么？"></a>web服务器会做些什么？</h2><ol><li>建立连接——接受一个客户端连接，如果不希望与这个客户端连接，就将其关闭。</li><li>接收请求——从网络中读取一条HTTP请求报文</li><li>处理请求——对请求报文进行解释，并采取行动。</li><li>访问资源——访问报文中指定的资源。</li><li>构建资源——创建带有正确首部的HTTP响应报文。</li><li>发送响应——将响应回送给客户端</li><li>记录事物处理过程——将与已完成事物有关的内容记录在一个日志文件中。</li></ol><h2 id="代理和网关有什么区别？"><a href="#代理和网关有什么区别？" class="headerlink" title="代理和网关有什么区别？"></a>代理和网关有什么区别？</h2><p><img src="https://note.youdao.com/yws/api/personal/file/WEB53413a837c5da0d75510df33c6728a07?method=download&amp;shareKey=fc560d0b484a2350a1895cd1bc2ff918" alt="代理和网关的区别"></p><p>代理连接的是两个或多个使用相同协议的应用程序，而网关连接的是两个或者多个不同协议的端点。<strong>区别在于网关的前后协议不同</strong></p><h2 id="我们为什么要使用代理？"><a href="#我们为什么要使用代理？" class="headerlink" title="我们为什么要使用代理？"></a>我们为什么要使用代理？</h2><ul><li>儿童过滤器，可以利用过滤器代理来阻止儿童访问成人内容</li><li>文档访问控制，可以用代理服务器在大量Web服务器和Web资源之间实现统一的访问控制策略，创建审核跟踪机制。</li><li>安全防火墙，网络安全工程师会使用代理服务器来提高安全性。</li><li>Web缓存，代理缓存维护了常用文档的本地副本，将它们按需提供，减少缓慢且昂贵的因特网通信。</li><li>反向代理，代理可以假扮Web服务器。这些被称为替代物或者反向代理的代理接收发给Web服务器的真实请求，它们可以发起与其他服务器的通信，以便按需定位所请求的内容。<img src="https://note.youdao.com/yws/api/personal/file/WEB6203273834d2ab2ca34dc6925e688d16?method=download&amp;shareKey=be2b266753fa27bcb7c3bd3ea0305295" alt="反向代理"></li><li>内容路由器，代理服务器可以作为“内容路由器”使用，根据因特网流量状况以及内容类型将请求导向特定的Web服务器。</li><li>转码器，可以修改内容的主体格式。在这些数据表示法之间进行的透明转换被称为转码。</li></ul><h2 id="代理是如何获取流量的？"><a href="#代理是如何获取流量的？" class="headerlink" title="代理是如何获取流量的？"></a>代理是如何获取流量的？</h2><ul><li>修改客户端，支持手工和自动的代理配置，将客户端的HTTP请求有意地发送给代理，而不是原始服务器。</li><li>修改网络，网络基础设施在客户端不知情的情况，对其进行拦截，这种代理称为“拦截代理”。</li><li>修改DNS的命名空间，放在Web服务器的代理服务器——替代物，假扮服务器的host和ip地址，所有的请求就会发送给替代物，通过编辑DNS名称列表。</li><li>修改Web服务器，通过HTTP重定向命令，将HTTP请求重定向到代理上去。</li></ul><p><img src="https://note.youdao.com/yws/api/personal/file/WEBe669168e6c40e032e8eebfb03fa00399?method=download&amp;shareKey=019b8fac2e513182bca57a96d8fefbbc" alt="代理是如何获取流量"></p><h2 id="客户端发给代理的URL与发给服务器的URL有什么不同？"><a href="#客户端发给代理的URL与发给服务器的URL有什么不同？" class="headerlink" title="客户端发给代理的URL与发给服务器的URL有什么不同？"></a>客户端发给代理的URL与发给服务器的URL有什么不同？</h2><ol><li>没有设置客户端使用代理时，它会发送部分URI</li><li>设置客户端使用代理时，它会发送完整URI</li></ol><h2 id="Web缓存有哪些好处？"><a href="#Web缓存有哪些好处？" class="headerlink" title="Web缓存有哪些好处？"></a>Web缓存有哪些好处？</h2><ul><li>缓存减少了冗余的数据传输，节省了你的网络费用。</li><li>缓存缓解了网络瓶颈的问题。不需要更多的带宽就能够更快地加载页面。</li><li>缓存降低了对原始服务器的要求。服务器可以更快地响应，避免过载的出现。</li><li>缓存降低了距离时延，因为从较远的地方加载页面会更慢一些。</li><li>缓存在解决瞬间拥塞时显得很重要，类似场景比如突发的新闻事件，大量的人几乎同时搜索一个事件，过多的流量峰值可能会造成Web服务器瞬间瘫痪。</li></ul><h2 id="缓存分为哪两种？"><a href="#缓存分为哪两种？" class="headerlink" title="缓存分为哪两种？"></a>缓存分为哪两种？</h2><ul><li>缓存命中，直接取缓存数据。</li><li>缓存未命中，需要从原始服务器获取数据。</li></ul><h2 id="缓存再验证是什么？"><a href="#缓存再验证是什么？" class="headerlink" title="缓存再验证是什么？"></a>缓存再验证是什么？</h2><p>原始服务器的内容可能会发生变化，缓存需要时不时对其进行检测，看看保存的副本是否仍然是服务器的最新副本。“新鲜度检测”被称为HTTP再验证。</p><p><img src="https://note.youdao.com/yws/api/personal/file/WEB3d4f91be96f1c4293b99bb891dfd783e?method=download&amp;shareKey=cc7737dd187bdc1c61d54d81d335a877" alt="缓存再验证"></p><p>缓存再验证时，这种方式确实比和原始服务器核对要慢，因为没有从服务器中获取数据，又比未命中情况要快。</p><h2 id="缓存的命中率一般是多少？"><a href="#缓存的命中率一般是多少？" class="headerlink" title="缓存的命中率一般是多少？"></a>缓存的命中率一般是多少？</h2><p>都希望缓存命中率越高越好，实际上对于现在中等规模的缓存来说，40%已经很不错了，能够显著地提升性能，减少流量了。</p><h2 id="if-modified-since失败会怎么样？"><a href="#if-modified-since失败会怎么样？" class="headerlink" title="if-modified-since失败会怎么样？"></a>if-modified-since失败会怎么样？</h2><p><img src="https://note.youdao.com/yws/api/personal/file/WEB18a92614cfebb53440fd75c7af210d1a?method=download&amp;shareKey=949295f354ec7d9af6f2a7f98f12acf6" alt="if-modified-since失败"></p><h2 id="网关有什么用？"><a href="#网关有什么用？" class="headerlink" title="网关有什么用？"></a>网关有什么用？</h2><p>网关可以作为某种翻译器使用，网关是资源和应用程序之间的粘合剂。</p><p><img src="https://note.youdao.com/yws/api/personal/file/WEB8998a6d50acb662be32a0c2b6dbd4ccb?method=download&amp;shareKey=1a834af067bc263ad9dc026c265a0674" alt=""></p><h2 id="为什么SSL需要搭载HTTP进行传输？"><a href="#为什么SSL需要搭载HTTP进行传输？" class="headerlink" title="为什么SSL需要搭载HTTP进行传输？"></a>为什么SSL需要搭载HTTP进行传输？</h2><p><img src="https://note.youdao.com/yws/api/personal/file/WEB6b10bdf7dc7589c88d9815ca57e2c65a?method=download&amp;shareKey=01d6de53e06328f1422e6550ed536df5" alt=""></p><h2 id="HTTP在发展中存在哪些问题？"><a href="#HTTP在发展中存在哪些问题？" class="headerlink" title="HTTP在发展中存在哪些问题？"></a>HTTP在发展中存在哪些问题？</h2><ul><li>复杂性，HTTP相当复杂，而且特性之间是相互依存的，比如处理连接管理，报文处理等等。</li><li>可扩展性，HTTP很难实现增式扩展。很多传下来的HTTP都没有自助的功能性扩展，使协议的扩展无法兼容。</li><li>有些部分效率不高，其中很多低效特性会随着高时延，低吞吐量的无线访问技术而变得更加严重。</li><li>传输依赖性，HTTP对于底层替换TCP/IP有很大的依赖性，想要替换底层的传输协议并没有什么很好的办法。</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;HTTP浅析（二）HTTP结构&quot;&gt;&lt;a href=&quot;#HTTP浅析（二）HTTP结构&quot; class=&quot;headerlink&quot; title=&quot;HTTP浅析（二）HTTP结构&quot;&gt;&lt;/a&gt;HTTP浅析（二）HTTP结构&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;本篇主要介
      
    
    </summary>
    
      <category term="基础知识" scheme="http://skyacer.github.io/categories/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    
    
      <category term="网络" scheme="http://skyacer.github.io/tags/%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>《Android优化专题》——优化电池续航能力</title>
    <link href="http://skyacer.github.io/2018/04/24/%E3%80%8AAndroid%E4%BC%98%E5%8C%96%E4%B8%93%E9%A2%98%E3%80%8B%E2%80%94%E2%80%94%E4%BC%98%E5%8C%96%E7%94%B5%E6%B1%A0%E7%BB%AD%E8%88%AA%E8%83%BD%E5%8A%9B/"/>
    <id>http://skyacer.github.io/2018/04/24/《Android优化专题》——优化电池续航能力/</id>
    <published>2018-04-24T09:18:56.000Z</published>
    <updated>2018-04-24T09:22:00.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="《Android优化专题》——优化电池续航能力"><a href="#《Android优化专题》——优化电池续航能力" class="headerlink" title="《Android优化专题》——优化电池续航能力"></a>《Android优化专题》——优化电池续航能力</h1><h2 id="一、监测设备的电量和充电状态"><a href="#一、监测设备的电量和充电状态" class="headerlink" title="一、监测设备的电量和充电状态"></a>一、监测设备的电量和充电状态</h2><blockquote><p>在用户充电时，程序做任何操作都不会太受到电量影响，此时就适合做一些下载，刷新数据等耗电操作。</p></blockquote><h3 id="1-判断当前充电状态"><a href="#1-判断当前充电状态" class="headerlink" title="1. 判断当前充电状态"></a>1. 判断当前充电状态</h3><p>BatteryManager会广播Sticky intent，我们不需要注册BroadcastReiver，</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">IntentFilter ifilter = new IntentFilter(Intent.ACTION_BATTERY_CHANGED);</span><br><span class="line">Intent batteryStatus = context.registerReceiver(null, ifilter);</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">// Are we charging / charged?  </span><br><span class="line">int status = batteryStatus.getIntExtra(BatteryManager.EXTRA_STATUS, -1);</span><br><span class="line">boolean isCharging = status == BatteryManager.BATTERY_STATUS_CHARGING ||</span><br><span class="line">                     status == BatteryManager.BATTERY_STATUS_FULL;</span><br><span class="line"></span><br><span class="line">// How are we charging?  </span><br><span class="line">int chargePlug = battery.getIntExtra(BatteryManager.EXTRA_PLUGGED, -1);</span><br><span class="line">boolean usbCharge = chargePlug == BATTERY_PLUGGED_USB;</span><br><span class="line">boolean acCharge = chargePlug == BATTERY_PLUGGED_AC;</span><br></pre></td></tr></table></figure><p>通过判断设备此时是不是通过AC充电器，USB充电，不在充电状态三种情况来进行是否耗电操作，通常做法是，在使用AC充电时最大化后台更新操作，在使用USB充电时降低更新操作，不在充电状态时，最小化更新操作。</p><h3 id="2-监测充电状态的改变"><a href="#2-监测充电状态的改变" class="headerlink" title="2. 监测充电状态的改变"></a>2. 监测充电状态的改变</h3><p>充电状态随时改变，通过检查充电状态的改变，来改变App的某些行为。我们需要在Manifest文件里面注册一个监听来接收ACTION_POWER_CONNECTED and ACTION_POWER_DISCONNECTED的intent。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;receiver android:name=&quot;.PowerConnectionReceiver&quot;&gt;</span><br><span class="line">  &lt;intent-filter&gt;</span><br><span class="line">    &lt;action android:name=&quot;android.intent.action.ACTION_POWER_CONNECTED&quot;/&gt;</span><br><span class="line">    &lt;action android:name=&quot;android.intent.action.ACTION_POWER_DISCONNECTED&quot;/&gt;</span><br><span class="line">  &lt;/intent-filter&gt;</span><br><span class="line">&lt;/receiver&gt;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public class PowerConnectionReceiver extends BroadcastReceiver &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void onReceive(Context context, Intent intent) &#123;</span><br><span class="line">        int status = intent.getIntExtra(BatteryManager.EXTRA_STATUS, -1);</span><br><span class="line">        boolean isCharging = status == BatteryManager.BATTERY_STATUS_CHARGING ||</span><br><span class="line">                            status == BatteryManager.BATTERY_STATUS_FULL;</span><br><span class="line"></span><br><span class="line">        int chargePlug = intent.getIntExtra(BatteryManager.EXTRA_PLUGGED, -1);</span><br><span class="line">        boolean usbCharge = chargePlug == BATTERY_PLUGGED_USB;</span><br><span class="line">        boolean acCharge = chargePlug == BATTERY_PLUGGED_AC;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-判断当前电池电量"><a href="#3-判断当前电池电量" class="headerlink" title="3. 判断当前电池电量"></a>3. 判断当前电池电量</h3><p>对于一些情况，获取当前电量对于我们是否要进行某个级别的后台操作十分有意义。我们可以从获取电池状态的intent中提取电池电量和容量信息。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">int level = battery.getIntExtra(BatteryManager.EXTRA_LEVEL, -1);</span><br><span class="line">int scale = battery.getIntExtra(BatteryManager.EXTRA_SCALE, -1);</span><br><span class="line">float batteryPct = level / (float)scale;</span><br></pre></td></tr></table></figure><h3 id="4-检测电量的有效改变"><a href="#4-检测电量的有效改变" class="headerlink" title="4. 检测电量的有效改变"></a>4. 检测电量的有效改变</h3><p>检测电量的有效改变，包括电量进入低电量模式，充电后离开低电量模式，这两种状态的变更是值得我们关注的。我们仅仅需要监听ACTION_BATTERY_LOW与ACTION_BATTERY_OKAY.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;receiver android:name=&quot;.BatteryLevelReceiver&quot;&gt;</span><br><span class="line">&lt;intent-filter&gt;</span><br><span class="line">  &lt;action android:name=&quot;android.intent.action.ACTION_BATTERY_LOW&quot;/&gt;</span><br><span class="line">  &lt;action android:name=&quot;android.intent.action.ACTION_BATTERY_OKAY&quot;/&gt;</span><br><span class="line">  &lt;/intent-filter&gt;</span><br><span class="line">&lt;/receiver&gt;</span><br></pre></td></tr></table></figure><p>对于设备进入低电量模式我们要尤其注意，这个时候的任何更新、下载等操作是非常影响用户体验，尤其还有可能下载到一半设备就已经关机了。</p><h2 id="二、判断设备的停驻模式"><a href="#二、判断设备的停驻模式" class="headerlink" title="二、判断设备的停驻模式"></a>二、判断设备的停驻模式</h2><blockquote><p>Android设备有好几种停驻状态，为设备充电，包括车载模式，家庭模式，数字对战模拟模式。停驻状态与充电状态是非常密切相关联的。</p></blockquote><h3 id="1-判断当前停驻状态"><a href="#1-判断当前停驻状态" class="headerlink" title="1. 判断当前停驻状态"></a>1. 判断当前停驻状态</h3><p>停驻状态的广播内容是sticky intent，所以不需要注册广播</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">IntentFilter ifilter = new IntentFilter(Intent.ACTION_DOCK_EVENT);</span><br><span class="line">Intent dockStatus = context.registerReceiver(null, ifilter);</span><br><span class="line"></span><br><span class="line">int dockState = battery.getIntExtra(EXTRA_DOCK_STATE, -1);</span><br><span class="line">boolean isDocked = dockState != Intent.EXTRA_DOCK_STATE_UNDOCKED;</span><br></pre></td></tr></table></figure><h3 id="2-判断当前停驻类型"><a href="#2-判断当前停驻类型" class="headerlink" title="2. 判断当前停驻类型"></a>2. 判断当前停驻类型</h3><ul><li>Car</li><li>Desk</li><li>Low-End (Analog) Desk：API level 11开始才有</li><li>High-End (Digital) Desk：API level 11开始才有</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">boolean isCar = dockState == EXTRA_DOCK_STATE_CAR;</span><br><span class="line">boolean isDesk = dockState == EXTRA_DOCK_STATE_DESK ||</span><br><span class="line">                 dockState == EXTRA_DOCK_STATE_LE_DESK ||</span><br><span class="line">                 dockState == EXTRA_DOCK_STATE_HE_DESK;</span><br></pre></td></tr></table></figure><h3 id="3-监测停驻状态或者类型改变"><a href="#3-监测停驻状态或者类型改变" class="headerlink" title="3. 监测停驻状态或者类型改变"></a>3. 监测停驻状态或者类型改变</h3><p>只需要像下面一样注册监听器</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;action android:name=&quot;android.intent.action.ACTION_DOCK_EVENT&quot;/&gt;</span><br></pre></td></tr></table></figure><h2 id="三、判断并监测网络连接状态"><a href="#三、判断并监测网络连接状态" class="headerlink" title="三、判断并监测网络连接状态"></a>三、判断并监测网络连接状态</h2><blockquote><p>通过网络的连接状况改变，相应改变app的行为，减少无谓的操作，从而延长设备的续航能力。</p></blockquote><h3 id="1-判断当前是否有网络连接"><a href="#1-判断当前是否有网络连接" class="headerlink" title="1. 判断当前是否有网络连接"></a>1. 判断当前是否有网络连接</h3><p>检查是否有网络连接</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ConnectivityManager cm =</span><br><span class="line">        (ConnectivityManager)context.getSystemService(Context.CONNECTIVITY_SERVICE);</span><br><span class="line"></span><br><span class="line">NetworkInfo activeNetwork = cm.getActiveNetworkInfo();</span><br><span class="line">boolean isConnected = activeNetwork.isConnectedOrConnecting();</span><br></pre></td></tr></table></figure><h3 id="2-判断连接网络的类型"><a href="#2-判断连接网络的类型" class="headerlink" title="2. 判断连接网络的类型"></a>2. 判断连接网络的类型</h3><p>分为移动网络，WiMax，Wi-Fi，以太网等连接类型</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">boolean isWiFi = activeNetwork.getType() == ConnectivityManager.TYPE_WIFI;</span><br></pre></td></tr></table></figure><p>使用移动网络比WI-FI代价更大，多数情况下，移动网络下减少一些数据的获取操作，在有WIFI的情况下才开始。</p><h3 id="3-监测网络连接的切换"><a href="#3-监测网络连接的切换" class="headerlink" title="3. 监测网络连接的切换"></a>3. 监测网络连接的切换</h3><p>在manifest文件中注册一个带有action的Receiver</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;action android:name=&quot;android.net.conn.CONNECTIVITY_CHANGE&quot;/&gt;</span><br></pre></td></tr></table></figure><p>当然我们也没必要不间断地监听网络改变，我们只需要在完成某件任务时而进行监测即可。</p><h3 id="4-切换是否开启这些Receivers来提高效率"><a href="#4-切换是否开启这些Receivers来提高效率" class="headerlink" title="4. 切换是否开启这些Receivers来提高效率"></a>4. 切换是否开启这些Receivers来提高效率</h3><p>通过使用PackageManager来切换任何一个在mainfest定义好的组件开启状态，可以使用下面的方法来开启或者关闭任何一个broadcast receiver：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">ComponentName receiver = new ComponentName(context, myReceiver.class);</span><br><span class="line"></span><br><span class="line">PackageManager pm = context.getPackageManager();</span><br><span class="line"></span><br><span class="line">pm.setComponentEnabledSetting(receiver,</span><br><span class="line">        PackageManager.COMPONENT_ENABLED_STATE_ENABLED,</span><br><span class="line">        PackageManager.DONT_KILL_APP)</span><br></pre></td></tr></table></figure><p>如果判断到了网络连接已经断开，可以在这个时候关闭除了网络环境改变之外的所有Receivers</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;《Android优化专题》——优化电池续航能力&quot;&gt;&lt;a href=&quot;#《Android优化专题》——优化电池续航能力&quot; class=&quot;headerlink&quot; title=&quot;《Android优化专题》——优化电池续航能力&quot;&gt;&lt;/a&gt;《Android优化专题》——优化
      
    
    </summary>
    
      <category term="Android优化专题" scheme="http://skyacer.github.io/categories/Android%E4%BC%98%E5%8C%96%E4%B8%93%E9%A2%98/"/>
    
    
      <category term="电量" scheme="http://skyacer.github.io/tags/%E7%94%B5%E9%87%8F/"/>
    
  </entry>
  
  <entry>
    <title>RecyclerView源码解析</title>
    <link href="http://skyacer.github.io/2018/04/17/RecyclerView%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"/>
    <id>http://skyacer.github.io/2018/04/17/RecyclerView源码解析/</id>
    <published>2018-04-17T08:36:08.000Z</published>
    <updated>2018-04-17T08:37:43.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="RecyclerView源码解析"><a href="#RecyclerView源码解析" class="headerlink" title="RecyclerView源码解析"></a>RecyclerView源码解析</h1><h2 id="总体框架"><a href="#总体框架" class="headerlink" title="总体框架"></a>总体框架</h2><h3 id="内部调用流程"><a href="#内部调用流程" class="headerlink" title="内部调用流程"></a>内部调用流程</h3><p><img src="https://note.youdao.com/yws/api/personal/file/WEBaaa20f9284dc534d3be53ceb6e3683a3?method=download&amp;shareKey=ef2fca96c536d923ea6ab1b4a2183644" alt="内部调用流程"></p><h3 id="设计思路"><a href="#设计思路" class="headerlink" title="设计思路"></a>设计思路</h3><blockquote><p>RecyclerView官网给出的定义是: A flexible view for providing a limited window into a large data set. 也就是在限定的视图内展示大量的数据</p></blockquote><p><img src="https://note.youdao.com/yws/api/personal/file/WEB2f5e28793cca033bc119504bc4d7c41f?method=download&amp;shareKey=3e4e9fd97ff1e9f09ac0771d20e752f7" alt="适配器模式"></p><p>如上所示，RecyclerView表示只会和ViewHolder进行接触，Adapter的工作是将Data转换为RecyclerView认识的ViewHolder，因此RecyclerView就间接地认识Datas。</p><p>而RecyclerView仍然不想管理子view，于是交给了LayoutManager来帮助完成布局（桥接模式）。</p><p><img src="https://note.youdao.com/yws/api/personal/file/WEB8a059ab9a6a178b0ec3ee8b0ae019298?method=download&amp;shareKey=d78b65294897b8799bde0531c3256b98" alt="桥接模式"></p><p>但是LayoutManager这个大管家也有弱点，它只知道怎么将这一个个View布局在RecyclerView上，但是并不知道如何管理这些View，此时要有个回收期Recycler回收器做管理。当LayoutManager在需要View的时候向Recycler进行索取，当LayoutManager不需要View（试图滑出）的时候，就直接将废弃的View丢给Recycler。</p><p><img src="https://note.youdao.com/yws/api/personal/file/WEB6cde858d77096432bb502a1d3267e352?method=download&amp;shareKey=63d6b41952091f8b3af1e6e03a172647" alt="Recycler"></p><p>到了这里，看似一切都很完美，但是RecyclerView还想让子View变动的动画要优雅，所以通过观察者模式，引入了ItemAnimator(观察者模式)。</p><p><img src="https://note.youdao.com/yws/api/personal/file/WEBb2ff9d64047966e71e191d3c66fd88b6?method=download&amp;shareKey=a2c113f8a90134e437b95bf1d361f4ff" alt=""></p><h2 id="设计模式"><a href="#设计模式" class="headerlink" title="设计模式"></a>设计模式</h2><ul><li>通过桥接模式，使RecyclerView将布局方式独立成LayoutManager，实现对布局的定制化。</li><li>通过组合模式，使RecyclerView通过dispatchLayout对item View进行布局绘制。</li><li>通过适配器模式，ViewHolder将RecyclerView与ItemView联系起来，使得RecyclerView方便操作ItemView。</li><li>通过观察者模式，给ViewHolder注册观察者，当调用notifyDataSetChanged时，就能重新绘制。</li></ul><h2 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h2><h3 id="设计结构"><a href="#设计结构" class="headerlink" title="设计结构"></a>设计结构</h3><p><img src="https://note.youdao.com/yws/api/personal/file/WEBbb61dc925d026053c5d5fd14c7539edf?method=download&amp;shareKey=2790c3eb0a3f59f871c8d4541ef69ed4" alt="设计结构"></p><h3 id="类关系图"><a href="#类关系图" class="headerlink" title="类关系图"></a>类关系图</h3><p><img src="https://note.youdao.com/yws/api/personal/file/WEBa5cfb53836bc3c7fe1d4a11f8c2ffb29?method=download&amp;shareKey=2c2a4a7037d3c6580c1c9c0cca13502b" alt="类关系图"></p><ul><li>RecyclerViewDataObserver： 数据观察器</li><li>Recycler： View 循环复用系统，核心部件</li><li>SavedState： RecyclerView状态</li><li>AdapterHelper：适配器更新</li><li>ChildHelper：管理子View</li><li>ViewInfoStore：存储子VIEW的动画信息</li><li>Adapter：数据适配器</li><li>LayoutManager：负责子VIEW的布局，核心部件</li><li>ItemAnimator：Item动画</li><li>ViewFlinger：快速滑动管理</li><li>NestedScrollingChildHelper：管理子VIEW嵌套滑动</li></ul><h3 id="绘制详情"><a href="#绘制详情" class="headerlink" title="绘制详情"></a>绘制详情</h3><p>以我们平时使用RecyclerView的行为举例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">recyclerView = (RecyclerView) findViewById(R.id.recyclerView);  </span><br><span class="line">LinearLayoutManager layoutManager = new LinearLayoutManager(this);  </span><br><span class="line">//设置布局管理器  </span><br><span class="line">recyclerView.setLayoutManager(layoutManager);  </span><br><span class="line">//设置为垂直布局，这也是默认的  </span><br><span class="line">layoutManager.setOrientation(OrientationHelper. VERTICAL);  </span><br><span class="line">//设置Adapter  </span><br><span class="line">recyclerView.setAdapter( recycleAdapter);  </span><br><span class="line"> //设置分隔线  </span><br><span class="line">recyclerView.addItemDecoration( new DividerGridItemDecoration(this ));  </span><br><span class="line">//设置增加或删除条目的动画  </span><br><span class="line">recyclerView.setItemAnimator( new DefaultItemAnimator());</span><br></pre></td></tr></table></figure><h3 id="初始化整体流程图如下"><a href="#初始化整体流程图如下" class="headerlink" title="初始化整体流程图如下"></a>初始化整体流程图如下</h3><p><img src="https://note.youdao.com/yws/api/personal/file/WEBca3ee08fea0d2c88b4bb959fa6e7b37d?method=download&amp;shareKey=af0fae22f03cfb0ab37b8d889c3188e9" alt="流程图"></p><h3 id="RecyclerView-layout（setLayoutManager）流程是什么样的？"><a href="#RecyclerView-layout（setLayoutManager）流程是什么样的？" class="headerlink" title="RecyclerView layout（setLayoutManager）流程是什么样的？"></a>RecyclerView layout（setLayoutManager）流程是什么样的？</h3><p><img src="https://note.youdao.com/yws/api/personal/file/WEB749b77d77ef0b7b430abaa44ba51e739?method=download&amp;shareKey=9d46381b8409bcd6a7d8fa5408b124ed" alt="RecyclerView Layout流程"></p><h3 id="layout过程中onLayoutChildren是什么流程？"><a href="#layout过程中onLayoutChildren是什么流程？" class="headerlink" title="layout过程中onLayoutChildren是什么流程？"></a>layout过程中onLayoutChildren是什么流程？</h3><p><img src="https://note.youdao.com/yws/api/personal/file/WEB2408904753cd6aee9d430862d107cbd3?method=download&amp;shareKey=9a29c10d31ad325d5b1e81700cafb0b8" alt=""></p><ul><li>找到anchor点</li><li>根据anchor一直向前布局，直到充满anchor点前面的所有区域</li><li>根据anchor一直向后布局，直到填充满anchor点后面所有区域，以垂直布局来说明，mAnchorInfo为布局锚点信息，包含了子控件在Y轴上起始绘制偏移量(coordinate)，ItemView在Adapter中的索引信息(position)和布局方向(mLayoutFromEnd) ——指start、end方向。确定布局锚点，以此为起点向开始和结束方向填充ItemView。</li></ul><h3 id="setAdapter方法最终调用的流程？"><a href="#setAdapter方法最终调用的流程？" class="headerlink" title="setAdapter方法最终调用的流程？"></a>setAdapter方法最终调用的流程？</h3><ol><li>如果之前存在Adapter，先移除原来的，注销观察者，从RecyclerView Detached。</li><li>根据参数，决定是否清除原来的ViewHolder。</li><li>重置AdapterHelper，更新Adapter，注册观察者。</li></ol><h3 id="RecyclerView的滑动过程是什么样的？"><a href="#RecyclerView的滑动过程是什么样的？" class="headerlink" title="RecyclerView的滑动过程是什么样的？"></a>RecyclerView的滑动过程是什么样的？</h3><p><img src="https://note.youdao.com/yws/api/personal/file/WEB3b18149dec7c15370c35b6ae0b894575?method=download&amp;shareKey=187a8d1c6699f89ae7f64670b09f98cd" alt="滑动过程"></p><h3 id="缓存逻辑是什么样的？"><a href="#缓存逻辑是什么样的？" class="headerlink" title="缓存逻辑是什么样的？"></a>缓存逻辑是什么样的？</h3><p>总共分为两级缓存</p><ol><li>mCachedViews，先进先出的数据结构，将新的View存入mCachedViews，移除头元素，并将头元素放入mRecyclerPool</li><li>mRecyclerPool，可以多个ReyclerView共享，减少内存开销。</li></ol><h3 id="AdapterView与RecyclerView的区别？"><a href="#AdapterView与RecyclerView的区别？" class="headerlink" title="AdapterView与RecyclerView的区别？"></a>AdapterView与RecyclerView的区别？</h3><p><img src="https://note.youdao.com/yws/api/personal/file/WEB4edaacbfaf0b69b263ec9f0002627249?method=download&amp;shareKey=9f60f307584f038c0834883e96f764d5" alt="区别"></p><h3 id="RecyclerView中有哪些设计精巧的地方？"><a href="#RecyclerView中有哪些设计精巧的地方？" class="headerlink" title="RecyclerView中有哪些设计精巧的地方？"></a>RecyclerView中有哪些设计精巧的地方？</h3><h4 id="Bucket"><a href="#Bucket" class="headerlink" title="Bucket"></a>Bucket</h4><blockquote><p>用来表示不设上限的状态，Bucket是一个链表结构，当index大于64的时候，它便会去下一个Bucket寻找，Bucket不设上限的表示状态。</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">static class Bucket &#123;</span><br><span class="line">    final static int BITS_PER_WORD = Long.SIZE;</span><br><span class="line">    final static long LAST_BIT = 1L &lt;&lt; (Long.SIZE - 1);</span><br><span class="line">    long mData = 0;</span><br><span class="line">    Bucket next;</span><br><span class="line">    void set(int index) &#123;</span><br><span class="line">        if (index &gt;= BITS_PER_WORD) &#123;</span><br><span class="line">            ensureNext();</span><br><span class="line">            next.set(index - BITS_PER_WORD);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            mData |= 1L &lt;&lt; index;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Pools"><a href="#Pools" class="headerlink" title="Pools"></a>Pools</h4><p>相当于Messages的池的概念，通过Message.obtain()可以在很多情况下避免创建新的对象</p><ul><li>RecycleView将Item的增删改封装为UpdateOp类</li><li>ViewInfoStore类中的静态内部类infoRecord</li></ul><h2 id="使用RecyclerView有没有遇到不好用的地方？"><a href="#使用RecyclerView有没有遇到不好用的地方？" class="headerlink" title="使用RecyclerView有没有遇到不好用的地方？"></a>使用RecyclerView有没有遇到不好用的地方？</h2><p>RecyclerView也不是万能的，它的灵活性也是有一定限制的，比如我就遇到了一不是很好解决的问题：Recyler的缓存级别是一个Item的整个View，而我们没办法自定义缓存级别，这样说比较抽象，举个例子，我的某些Item的某个子View加载很耗时，所以我希望我在上下滑动的时候，Item的其它View是可以被回收利用的，但这个加载很耗时的View是不要重复使用的。即我希望用空间换取时间来获取滑动的流畅性。当然，这样的需求不常见，RecyclerView也不能很好的满足这一点。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;RecyclerView源码解析&quot;&gt;&lt;a href=&quot;#RecyclerView源码解析&quot; class=&quot;headerlink&quot; title=&quot;RecyclerView源码解析&quot;&gt;&lt;/a&gt;RecyclerView源码解析&lt;/h1&gt;&lt;h2 id=&quot;总体框架&quot;&gt;&lt;a 
      
    
    </summary>
    
      <category term="View" scheme="http://skyacer.github.io/categories/View/"/>
    
    
      <category term="源码解析" scheme="http://skyacer.github.io/tags/%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"/>
    
  </entry>
  
  <entry>
    <title>《Android优化专题》——音频播放</title>
    <link href="http://skyacer.github.io/2018/04/15/%E3%80%8AAndroid%E4%BC%98%E5%8C%96%E4%B8%93%E9%A2%98%E3%80%8B%E2%80%94%E2%80%94%E9%9F%B3%E9%A2%91%E6%92%AD%E6%94%BE/"/>
    <id>http://skyacer.github.io/2018/04/15/《Android优化专题》——音频播放/</id>
    <published>2018-04-15T07:37:51.000Z</published>
    <updated>2018-04-15T07:40:12.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="《Android优化专题》——音频播放"><a href="#《Android优化专题》——音频播放" class="headerlink" title="《Android优化专题》——音频播放"></a>《Android优化专题》——音频播放</h1><h2 id="一、控制app的音量与播放"><a href="#一、控制app的音量与播放" class="headerlink" title="一、控制app的音量与播放"></a>一、控制app的音量与播放</h2><h3 id="使用硬件音量键来控制音量"><a href="#使用硬件音量键来控制音量" class="headerlink" title="使用硬件音量键来控制音量"></a>使用硬件音量键来控制音量</h3><p>需要在Activity或者Fragment创建的时候就设置音量控制，这样确保不管App是否可见，音频控制功能都正常工作。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">setVolumeControlStream(AudioManager.STREAM_MUSIC);</span><br></pre></td></tr></table></figure><h3 id="使用硬件的播放控制按键来控制App的音频播放"><a href="#使用硬件的播放控制按键来控制App的音频播放" class="headerlink" title="使用硬件的播放控制按键来控制App的音频播放"></a>使用硬件的播放控制按键来控制App的音频播放</h3><p>无论用户通过手机或者线控耳机等按下哪些控制按钮，比如播放、暂停，系统都会广播一个带有ACTION_MEDIA_BUTTON的Intent。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;receiver android:name=&quot;.RemoteControlReceiver&quot;&gt;</span><br><span class="line">    &lt;intent-filter&gt;</span><br><span class="line">        &lt;action android:name=&quot;android.intent.action.MEDIA_BUTTON&quot; /&gt;</span><br><span class="line">    &lt;/intent-filter&gt;</span><br><span class="line">&lt;/receiver&gt;</span><br></pre></td></tr></table></figure><p>Receiver需要判断广播来自哪个按钮</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public class RemoteControlReceiver extends BroadcastReceiver &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void onReceive(Context context, Intent intent) &#123;</span><br><span class="line">        if (Intent.ACTION_MEDIA_BUTTON.equals(intent.getAction())) &#123;</span><br><span class="line">            KeyEvent event = (KeyEvent)intent.getParcelableExtra(Intent.EXTRA_KEY_EVENT);</span><br><span class="line">            if (KeyEvent.KEYCODE_MEDIA_PLAY == event.getKeyCode()) &#123;</span><br><span class="line">                // Handle key press.  </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="如何注册监听和取消监听"><a href="#如何注册监听和取消监听" class="headerlink" title="如何注册监听和取消监听"></a>如何注册监听和取消监听</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">AudioManager am = mContext.getSystemService(Context.AUDIO_SERVICE);</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">// Start listening for button presses</span><br><span class="line">am.registerMediaButtonEventReceiver(RemoteControlReceiver);</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">// Stop listening for button presses</span><br><span class="line">am.unregisterMediaButtonEventReceiver(RemoteControlReceiver);</span><br></pre></td></tr></table></figure><h2 id="二、管理音频焦点"><a href="#二、管理音频焦点" class="headerlink" title="二、管理音频焦点"></a>二、管理音频焦点</h2><h3 id="请求获取音频焦点"><a href="#请求获取音频焦点" class="headerlink" title="请求获取音频焦点"></a>请求获取音频焦点</h3><p>requestAudioFocus() 来获取到音频流焦点。</p><ul><li>短暂的焦点锁定：当期待播放一个短暂的音频时候（比如推送声音）</li><li>永久的焦点锁定：当计划播放可预期到的较长的音频时候（比如播放音乐）</li></ul><p>我们必须在开始播放前请求音频焦点，比如用户此时点击了播放按钮</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">AudioManager am = mContext.getSystemService(Context.AUDIO_SERVICE);</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">// Request audio focus for playback  </span><br><span class="line">int result = am.requestAudioFocus(afChangeListener,</span><br><span class="line">                                 // Use the music stream.  </span><br><span class="line">                                 AudioManager.STREAM_MUSIC,</span><br><span class="line">                                 // Request permanent focus.  </span><br><span class="line">                                 AudioManager.AUDIOFOCUS_GAIN);</span><br><span class="line"></span><br><span class="line">if (result == AudioManager.AUDIOFOCUS_REQUEST_GRANTED) &#123;</span><br><span class="line">    am.unregisterMediaButtonEventReceiver(RemoteControlReceiver);</span><br><span class="line">    // Start playback.  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>一旦结束播放，需要调用abandonAudioFocus()方法，通知系统说不再需要获取焦点并且取消注册AudioManager.OnAudioFocusChangeListener的焦点。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// Abandon audio focus when playback complete</span><br><span class="line">am.abandonAudioFocus(afChangeListener);</span><br></pre></td></tr></table></figure><p>当请求短暂音频焦点，我们可以选择是否开启”ducking”，Ducking机制可以允许音频间歇性短暂播放。可以让其他App继续播放，仅在短暂的时间内降低自己的音量。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">// Request audio focus for playback  </span><br><span class="line">int result = am.requestAudioFocus(afChangeListener,</span><br><span class="line">                             // Use the music stream.  </span><br><span class="line">                             AudioManager.STREAM_MUSIC,</span><br><span class="line">                             // Request permanent focus.  </span><br><span class="line">                             AudioManager.AUDIOFOCUS_GAIN_TRANSIENT_MAY_DUCK);</span><br><span class="line"></span><br><span class="line">if (result == AudioManager.AUDIOFOCUS_REQUEST_GRANTED) &#123;</span><br><span class="line">    // Start playback.  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="处理失去音频焦点"><a href="#处理失去音频焦点" class="headerlink" title="处理失去音频焦点"></a>处理失去音频焦点</h3><ul><li>失去短暂焦点：在这种情况下，暂停当前音频的播放或者降低音量，需要准备恢复播放在重新获取到焦点之后。</li><li>失去永久焦点：假设另一个程序开始播放音乐，此时我们的程序就应该彻底结束。停止播放，放弃自己的音频焦点。</li><li>Ducking：降低音量，让其余短暂声音突出，之后恢复原音量。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">OnAudioFocusChangeListener afChangeListener = new OnAudioFocusChangeListener() &#123;</span><br><span class="line">    public void onAudioFocusChange(int focusChange) &#123;</span><br><span class="line">        if (focusChange == AUDIOFOCUS_LOSS_TRANSIENT</span><br><span class="line">            // Pause playback  </span><br><span class="line">            //失去短暂焦点</span><br><span class="line">        &#125; else if (focusChange == AudioManager.AUDIOFOCUS_GAIN) &#123;</span><br><span class="line">            // Resume playback</span><br><span class="line">            //恢复焦点   </span><br><span class="line">        &#125; else if (focusChange==AUDIOFOCUS_LOSS_TRANSIENT_CAN_DUCK</span><br><span class="line">            // Lower the volume  </span><br><span class="line">        &#125; else if (focusChange == AudioManager.AUDIOFOCUS_LOSS) &#123;</span><br><span class="line">    am.unregisterMediaButtonEventReceiver(RemoteControlReceiver);</span><br><span class="line">            am.abandonAudioFocus(afChangeListener);</span><br><span class="line">            // Stop playback  </span><br><span class="line">            // 失去永久焦点</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="三、音频设备的相关问题"><a href="#三、音频设备的相关问题" class="headerlink" title="三、音频设备的相关问题"></a>三、音频设备的相关问题</h2><h3 id="检测目前正在使用的硬件设备"><a href="#检测目前正在使用的硬件设备" class="headerlink" title="检测目前正在使用的硬件设备"></a>检测目前正在使用的硬件设备</h3><p>可以使用AudioManager来查询某个音频是否输出到扬声器，有线耳机还是蓝牙上。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">if (isBluetoothA2dpOn()) &#123;</span><br><span class="line">    // Adjust output for Bluetooth.  </span><br><span class="line">&#125; else if (isSpeakerphoneOn()) &#123;</span><br><span class="line">    // Adjust output for Speakerphone.  </span><br><span class="line">&#125; else if (isWiredHeadsetOn()) &#123;</span><br><span class="line">    // Adjust output for headsets  </span><br><span class="line">&#125; else &#123;</span><br><span class="line">    // If audio plays and noone can hear it, is it still playing?  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="处理音频输出设备的改变"><a href="#处理音频输出设备的改变" class="headerlink" title="处理音频输出设备的改变"></a>处理音频输出设备的改变</h3><p>当耳机线被拔出，或者蓝牙耳机连接断开时，如果在播放音乐/视频，为了用户体验，避免突如其来的扬声器播放，我们通常做法是暂停此时正在播放的音乐/视频。</p><p>在这种情况下，系统会广播带有ACTION_AUDIO_BECOMING_NOISY的intent。我们只需要接受这种广播，对其进行处理即可。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">private class NoisyAudioStreamReceiver extends BroadcastReceiver &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void onReceive(Context context, Intent intent) &#123;</span><br><span class="line">        if (AudioManager.ACTION_AUDIO_BECOMING_NOISY.equals(intent.getAction())) &#123;</span><br><span class="line">            // Pause the playback  </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private IntentFilter intentFilter = new IntentFilter(AudioManager.ACTION_AUDIO_BECOMING_NOISY);</span><br><span class="line"></span><br><span class="line">private void startPlayback() &#123;</span><br><span class="line">    registerReceiver(myNoisyAudioStreamReceiver(), intentFilter);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private void stopPlayback() &#123;</span><br><span class="line">    unregisterReceiver(myNoisyAudioStreamReceiver);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;《Android优化专题》——音频播放&quot;&gt;&lt;a href=&quot;#《Android优化专题》——音频播放&quot; class=&quot;headerlink&quot; title=&quot;《Android优化专题》——音频播放&quot;&gt;&lt;/a&gt;《Android优化专题》——音频播放&lt;/h1&gt;&lt;h2 i
      
    
    </summary>
    
      <category term="Android优化" scheme="http://skyacer.github.io/categories/Android%E4%BC%98%E5%8C%96/"/>
    
    
      <category term="音频" scheme="http://skyacer.github.io/tags/%E9%9F%B3%E9%A2%91/"/>
    
  </entry>
  
  <entry>
    <title>JVM内存模型</title>
    <link href="http://skyacer.github.io/2018/04/12/JVM%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/"/>
    <id>http://skyacer.github.io/2018/04/12/JVM内存模型/</id>
    <published>2018-04-12T06:49:40.000Z</published>
    <updated>2018-04-12T06:50:58.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="JVM内存模型"><a href="#JVM内存模型" class="headerlink" title="JVM内存模型"></a>JVM内存模型</h1><h2 id="简单来说JVM内存模型是什么样的？"><a href="#简单来说JVM内存模型是什么样的？" class="headerlink" title="简单来说JVM内存模型是什么样的？"></a>简单来说JVM内存模型是什么样的？</h2><p><img src="https://note.youdao.com/yws/api/personal/file/WEB9b72e7ca84813b9d70d9e53b2337545f?method=download&amp;shareKey=c659a9b8ad449a74d3a92fd212f495e9" alt=""></p><h3 id="线程私有区："><a href="#线程私有区：" class="headerlink" title="线程私有区："></a>线程私有区：</h3><ul><li>程序计数器，记录正在执行的虚拟机字节码的地址；</li><li>虚拟机栈，方法执行的内存区，每个方法执行时在虚拟机栈中创建栈帧；</li><li>本地方法栈，虚拟机的Native方法执行的内存区；</li></ul><h3 id="线程共享区："><a href="#线程共享区：" class="headerlink" title="线程共享区："></a>线程共享区：</h3><ul><li>Java堆：对象分配内存的区域；</li><li>方法区：存放类信息、常量、静态变量、编译器编译后的代码等数据；<ul><li>常量池：存放编译器生成的字面量和符号引用，是方法区的一部分。 </li></ul></li></ul><h3 id="通常所说的Java堆和Java栈是指什么？"><a href="#通常所说的Java堆和Java栈是指什么？" class="headerlink" title="通常所说的Java堆和Java栈是指什么？"></a>通常所说的Java堆和Java栈是指什么？</h3><p>通常所说的Java堆指的是共享数据区的堆，Java栈指的是线程私有的虚拟机栈。</p><h2 id="JVM中更详细的内存模型是什么样的？"><a href="#JVM中更详细的内存模型是什么样的？" class="headerlink" title="JVM中更详细的内存模型是什么样的？"></a>JVM中更详细的内存模型是什么样的？</h2><p><img src="https://note.youdao.com/yws/api/personal/file/WEB73bae4dd3b8c5e8b481d92d6cb8a07d5?method=download&amp;shareKey=d9f8bfec8cb4b4af1862d0a6e86bdeea" alt="JVM更详细的内存模型"></p><h3 id="程序计数器"><a href="#程序计数器" class="headerlink" title="程序计数器"></a>程序计数器</h3><ol><li>每个线程都有计数器，是私有内存空间，该区域是整个内存中较小的一块。</li><li>当线程正在执行一个Java方法时，PC计数器记录的是正在执行的虚拟机字节码的地址。</li><li>当线程正在执行Native方法时，PC计数器则为空</li></ol><h3 id="虚拟机栈"><a href="#虚拟机栈" class="headerlink" title="虚拟机栈"></a>虚拟机栈</h3><blockquote><p>栈祯是用于支持虚拟机进行方法执行的数据结构，是属性运行时数据区的虚拟机的栈元素。</p></blockquote><ol><li>局部变量表，一组变量存储空间，容量以slot为最小单位。</li><li>操作栈（stack大小，编译器确定），操作栈元素的数据必须与字节码指令序列严格匹配。</li><li>动态连接，指向运行时常量池中该栈所属方法的引用，为了动态连接使用。<ul><li>前面的解析过程是静态解析</li><li>对于运行期转化为直接引用，动态解析。</li></ul></li><li>方法返回地址<ul><li>正常退出，执行引擎遇到方法返回的字节码，将返回值传递给调用者。</li><li>异常退出，遇到Exception，并且方法未捕获异常，不会有任何返回值。</li></ul></li><li>额外附加信息，由具体虚拟机实现。</li></ol><p><strong>异常（Exception）</strong></p><ul><li>StackOverFlowError：当线程请求栈深度超出虚拟机栈允许深度时抛出</li><li>OutOfMemoryError：当Java虚拟机动态扩展到无法申请足够内存时抛出</li></ul><h3 id="本地方法栈"><a href="#本地方法栈" class="headerlink" title="本地方法栈"></a>本地方法栈</h3><p>本地方法栈为虚拟机使用到的Native方法提供内存空间，而虚拟机栈则为Java方法提供内存空间。</p><h3 id="Java堆"><a href="#Java堆" class="headerlink" title="Java堆"></a>Java堆</h3><p>Java堆是虚拟机管理的最大一块内存，也是GC的主战场，存放的是几乎所有的对象实例和数组数据。</p><ul><li>从内存回收角度，Java堆被分为新生代和老年代；为了更快地回收内存。</li><li>从内存分配角度，Java堆可以划分出线程私有的分配缓冲区（Thread Local Allocation Buffer,TLAB），为了更快地分配内存。</li></ul><h3 id="对象实例结构是什么样的？"><a href="#对象实例结构是什么样的？" class="headerlink" title="对象实例结构是什么样的？"></a>对象实例结构是什么样的？</h3><p><img src="https://note.youdao.com/yws/api/personal/file/WEBe2af8709014a9b7dc3005005fda1ea82?method=download&amp;shareKey=14e5e6c91dc5864b718ec8d95003351e" alt="对象实例结构"></p><p>填充数据不一定存在，是为了字节对齐而存在的</p><p>此区域可以抛出OOM Error异常</p><h3 id="方法区"><a href="#方法区" class="headerlink" title="方法区"></a>方法区</h3><p>主要存放被虚拟机加载的类信息、常量、静态变量、编译器编译后的代码数据。</p><p>此区域可以抛出OOM Error异常</p><h3 id="运行时常量池"><a href="#运行时常量池" class="headerlink" title="运行时常量池"></a>运行时常量池</h3><p>属于方法区的一部分，用于存放编译器生成的各种字面量和符号引用。运行时常量池除了编译器产生的Class文件的常量池，还可以在运行期，将新的常量加入常量池，比如String的intern()方法。</p><ul><li>字面量：与Java语言层面的常量概念相近，包含文本字符串，声明为final的常量值等等。</li><li>符号引用：<ul><li>类和接口的全限定名</li><li>字段的名称和描述符</li><li>方法的名称和描述符 </li></ul></li></ul><p>此区域<strong>不会</strong>抛出OOM Error异常</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;JVM内存模型&quot;&gt;&lt;a href=&quot;#JVM内存模型&quot; class=&quot;headerlink&quot; title=&quot;JVM内存模型&quot;&gt;&lt;/a&gt;JVM内存模型&lt;/h1&gt;&lt;h2 id=&quot;简单来说JVM内存模型是什么样的？&quot;&gt;&lt;a href=&quot;#简单来说JVM内存模型是什么样的
      
    
    </summary>
    
      <category term="JVM" scheme="http://skyacer.github.io/categories/JVM/"/>
    
    
      <category term="基础知识" scheme="http://skyacer.github.io/tags/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    
  </entry>
  
</feed>
