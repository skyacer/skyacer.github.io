<!doctype html>



  


<html class="theme-next pisces use-motion">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>



<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />












  <link href="/vendors/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css"/>




  <link href="//fonts.googleapis.com/css?family=Lato:300,400,700,400italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">



<link href="/vendors/font-awesome/css/font-awesome.min.css?v=4.4.0" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=0.5.0" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="Hexo, NexT" />








  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=0.5.0" />






<meta name="description" content="Little And More.">
<meta property="og:type" content="website">
<meta property="og:title" content="SkyAcer&#39;s blog">
<meta property="og:url" content="http://skyacer.github.io/index.html">
<meta property="og:site_name" content="SkyAcer&#39;s blog">
<meta property="og:description" content="Little And More.">
<meta property="og:locale" content="zh-Hans">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="SkyAcer&#39;s blog">
<meta name="twitter:description" content="Little And More.">



<script type="text/javascript" id="hexo.configuration">
  var NexT = window.NexT || {};
  var CONFIG = {
    scheme: 'Pisces',
    sidebar: {"position":"left","display":"post"},
    fancybox: true,
    motion: true,
    duoshuo: {
      userId: 0,
      author: '博主'
    }
  };
</script>

  <title> SkyAcer's blog </title>
</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  








  
  
    
  

  <div class="container one-collumn sidebar-position-left 
   page-home 
 ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-meta ">
  

  <div class="custom-logo-site-title">
    <a href="/"  class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <span class="site-title">SkyAcer's blog</span>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>
  <p class="site-subtitle">Hacking,Thoughts.</p>
</div>

<div class="site-nav-toggle">
  <button>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
  </button>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-home fa-fw"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            
              <i class="menu-item-icon fa fa-archive fa-fw"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags" rel="section">
            
              <i class="menu-item-icon fa fa-tags fa-fw"></i> <br />
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-commonweal">
          <a href="/404.html" rel="section">
            
              <i class="menu-item-icon fa fa-heartbeat fa-fw"></i> <br />
            
            公益404
          </a>
        </li>
      

      
    </ul>
  

  
</nav>

 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2018/05/26/Android-View分发机制及解决滑动冲突方案/" itemprop="url">
                  Android View分发机制及解决滑动冲突方案
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2018-05-26T22:04:52+08:00" content="2018-05-26">
              2018-05-26
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/基础知识/" itemprop="url" rel="index">
                    <span itemprop="name">基础知识</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
          

          

          
          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <ul>
<li><ul>
<li><a href="#初探view事件">初探View事件</a></li>
<li><a href="#事件分发">事件分发</a><ul>
<li><a href="#理论知识">理论知识</a></li>
<li><a href="#实战讲解">实战讲解</a><ul>
<li><a href="#验证view的事件分发">验证View的事件分发</a></li>
<li><a href="#验证不消耗actiondown事件">验证不消耗ACTION_DOWN事件</a></li>
<li><a href="#验证-viewgroup事件拦截">验证 ViewGroup事件拦截</a></li>
</ul>
</li>
<li><a href="#源码分析viewgroup">源码分析ViewGroup</a><ul>
<li><a href="#activity的事件分发">Activity的事件分发</a></li>
<li><a href="#viewgroup的事件拦截">ViewGroup的事件拦截</a></li>
<li><a href="#viewgroup的事件分发">ViewGroup的事件分发</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#view的滑动冲突">View的滑动冲突</a><ul>
<li><a href="#外部拦截">外部拦截</a></li>
<li><a href="#内部拦截">内部拦截</a></li>
</ul>
</li>
<li><a href="#总结">总结</a></li>
</ul>
</li>
</ul>
<h2 id="初探View事件"><a href="#初探View事件" class="headerlink" title="初探View事件"></a>初探View事件</h2><p>前言View的事件分发和滑动冲突处理是老生常谈的知识了， 我们常说的View事件是指： 从手指亲密接触屏幕的那一刻到手指离开屏幕的这个过程，该事件序列以down事件为起点，move事件为过程，up事件为终点。<br>一次down-move-up这一个事件过程我们称为一个事件序列。所以我们今天研究的对象就是MotionEvent。</p>
<h2 id="事件分发"><a href="#事件分发" class="headerlink" title="事件分发"></a>事件分发</h2><h3 id="理论知识"><a href="#理论知识" class="headerlink" title="理论知识"></a>理论知识</h3><ul>
<li>public boolean dispatchTouchEvent(MotionEvent ev)<br>用来分发事件，即事件序列的大门，如果事件传递到当前View的<code>onTouchEvent</code>或者是子View的<code>dispatchTouchEvent</code>，即该方法被调用了。<br>return true: 表示消耗了当前事件，有可能是当前View的<code>onTouchEvent</code>或者是子View的<code>dispatchTouchEvent</code>消费了，事件终止，不再传递。<br>return false: 调用父ViewGroup或则Activity的<code>onTouchEvent</code>。 （不再往下传）。①另外如果不消耗ACTION_DOWN事件，那么down,move,up事件都与该View无关，交由父类处理(父类的<code>onTouchEvent</code>方法)<br>return super.dispatherTouchEvent: 则继续往下(子View)传递，或者是调用当前View的onTouchEvent方法;</li>
</ul>
<ul>
<li>public boolean onInterceptTouchEvent(MotionEvent ev)<br>在<code>dispatchTouchEvent</code>内部调用，顾名思义就是判断是否拦截某个事件。(注：ViewGroup才有的方法，View因为没有子View了，所以不需要也没有该方法)<br>return true: ViewGroup将该事件拦截，交给自己的<code>onTouchEvent</code>处理。②而且这一个事件序列（当前和其它事件）都只能由该ViewGroup处理，并且不会再调用该<code>onInterceptTouchEvent</code>方法去询问是否拦截。<br>return false: 继续传递给子元素的<code>dispatchTouchEvent</code>处理。<br>return super.dispatherTouchEvent: 事件默认不会被拦截。</li>
</ul>
<ul>
<li>public boolean onTouchEvent(MotionEvent ev)<br>在<code>dispatchTouchEvent</code>内部调用<br>return true: 事件消费，当前事件终止。<br>return false: 交给父View的<code>onTouchEvent</code>。<br>return super.dispatherTouchEvent: 默认处理事件的逻辑和返回 false 时相同。</li>
</ul>
<p>其实上面的关系可以用以下代码简单描述。</p>
<pre><code>public boolean dispatchTouchEvent(MotionEvent ev){
    boolean consume = false;//是否消费事件
    if(onInterceptTouchEvent(ev)){//是否拦截事件
        consume = onTouchEvent(ev);//拦截了，交给自己的View处理
    }else{
        consume = child.dispatchTouchEvent(ev);//不拦截，就交给子View处理
    }

    return consume;//true：消费事件，终止。false:交给父onTouchEvent处理。并不再往下传递当前事件。
}
</code></pre><p>有图有真相</p>
<p><img src="https://img-blog.csdn.net/20171121120051746?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcWlhbjUyMGFv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p>
<p>有点类似<a href="http://blog.csdn.net/qian520ao/article/details/73558275" title="optional title" target="_blank" rel="noopener">责任链设计模式</a></p>
<h3 id="实战讲解"><a href="#实战讲解" class="headerlink" title="实战讲解"></a>实战讲解</h3><h4 id="验证View的事件分发"><a href="#验证View的事件分发" class="headerlink" title="验证View的事件分发"></a>验证View的事件分发</h4><ul>
<li>创建CustomViewGroup继承FrameLayout</li>
<li>创建CustomView继承View</li>
</ul>
<p>xml</p>
<pre><code>&lt;FrameLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;
    xmlns:tools=&quot;http://schemas.android.com/tools&quot;
    android:layout_width=&quot;match_parent&quot;
    android:layout_height=&quot;match_parent&quot;
    tools:context=&quot;qdx.viewtouchevent.MainActivity&quot;&gt;

//最外层为activity（白色背景）
    &lt;qdx.viewtouchevent.CustomViewGroup
        android:layout_width=&quot;300dp&quot;
        android:layout_height=&quot;400dp&quot;
        android:layout_gravity=&quot;right&quot;
        android:background=&quot;#84bf96&quot;&gt;
//CustomViewGroup（绿色背景）包含CustomView（黄色背景）
        &lt;qdx.viewtouchevent.CustomView
            android:layout_width=&quot;150dp&quot;
            android:layout_height=&quot;300dp&quot;
            android:layout_gravity=&quot;right&quot;
            android:background=&quot;#f2eada&quot; /&gt;

    &lt;/qdx.viewtouchevent.CustomViewGroup&gt;

&lt;/FrameLayout&gt;
</code></pre><p><img src="https://img-blog.csdn.net/20170820190556008?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcWlhbjUyMGFv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="无事件处理者"></p>
<p>如上图所示，down事件由activity-&gt;ViewGroup-&gt;View，因为View并没有处理down事件，所以事件消费情况为false，并且最后由View-&gt;ViewGroup-&gt;activity传递。  </p>
<h4 id="验证不消耗ACTION-DOWN事件"><a href="#验证不消耗ACTION-DOWN事件" class="headerlink" title="验证不消耗ACTION_DOWN事件"></a>验证不消耗ACTION_DOWN事件</h4><p>我们再来验证①另外如果不消耗ACTION_DOWN事件，那么down,move,up事件系列都与该View无关，交由父类处理(父类的<code>onTouchEvent</code>方法)<br>根据上面文字描述，因为我们的<code>CustomViewGroup</code>和<code>CustomView</code>都没有去处理任何事件，即当前序列的所有事件都return false，所以我们也无法接收/处理其他事件(move,up)</p>
<p><img src="https://img-blog.csdn.net/20170820192518176?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcWlhbjUyMGFv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt=" 不消耗ACTION_DOWN事件"></p>
<p>我们再将customView设置为可点击状态，即消费touch事件。<code>setClickable(true);</code></p>
<p><img src="https://img-blog.csdn.net/20170820214522582?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcWlhbjUyMGFv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="子View消费touch事件"></p>
<h4 id="验证-ViewGroup事件拦截"><a href="#验证-ViewGroup事件拦截" class="headerlink" title="验证 ViewGroup事件拦截"></a>验证 ViewGroup事件拦截</h4><p>viewGroup将事件拦截后，②而且这一个事件序列（当前和其它事件）都只能由该ViewGroup处理，并且不会再调用该<code>onInterceptTouchEvent</code>方法去询问是否拦截。</p>
<p><img src="https://img-blog.csdn.net/20170820232415501?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcWlhbjUyMGFv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="View事件拦截"></p>
<p>通过上面的几个验证，我们越来越接近真相，用通俗的话来解释就是：</p>
<blockquote>
<p>老板发现BUG解决，一开始是由上级往下级问话。（<a href="http://blog.csdn.net/qian520ao/article/details/73558275" title="optional title" target="_blank" rel="noopener">类似责任链设计模式</a>）</p>
<p>例如突然间出现了BUG，老板问小组A有没有空处理一下BUG(即分发ACTION_DOWN)，小组A说没时间(return false)，那么老板就不会把这个序列的BUG（ACTION_MOVE和ACTION_UP）交给小组A。如果再次出现BUG，老板还会再次询问小组A。①</p>
<p>如果你举手揽了这个BUG（即拦截），那么这一事件的BUG都交由你解决，并且相同序列的BUG老板不会问话，直接找你处理。②</p>
</blockquote>
<h3 id="源码分析ViewGroup"><a href="#源码分析ViewGroup" class="headerlink" title="源码分析ViewGroup"></a>源码分析ViewGroup</h3><p>源码分析这一块主要还是基于《Android开发艺术探索》这本书的引导和理解做出的总结。PS：这本书性价比很高，涵盖知识面广。</p>
<h4 id="Activity的事件分发"><a href="#Activity的事件分发" class="headerlink" title="Activity的事件分发"></a>Activity的事件分发</h4><p>Activity的事件分发还关系到View的绘制和加载机制，等待下一篇来更详细认识这个知识点。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">public boolean dispatchTouchEvent(MotionEvent ev) &#123;</span><br><span class="line">    if (ev.getAction() == MotionEvent.ACTION_DOWN) &#123;</span><br><span class="line">        onUserInteraction();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    //最终获取到顶级View(ViewGroup)分发事件</span><br><span class="line">    //（getWindow().getDecorView().findViewById(android.R.id.Content)）.getChildAt(0)</span><br><span class="line">    if (getWindow().superDispatchTouchEvent(ev)) &#123;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    //如果所有的View都没有处理事件，则由Activity亲自出马</span><br><span class="line">    return onTouchEvent(ev);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="ViewGroup的事件拦截"><a href="#ViewGroup的事件拦截" class="headerlink" title="ViewGroup的事件拦截"></a>ViewGroup的事件拦截</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">            public boolean dispatchTouchEvent(MotionEvent ev) &#123;</span><br><span class="line">            ......</span><br><span class="line"></span><br><span class="line">            final int action = ev.getAction();</span><br><span class="line">            final int actionMasked = action &amp; MotionEvent.ACTION_MASK;</span><br><span class="line"></span><br><span class="line">            if (actionMasked == MotionEvent.ACTION_DOWN) &#123;</span><br><span class="line">                cancelAndClearTouchTargets(ev);</span><br><span class="line"></span><br><span class="line">                //清除FLAG_DISALLOW_INTERCEPT，并且设置mFirstTouchTarget为null</span><br><span class="line">                resetTouchState()&#123;</span><br><span class="line">                    if(mFirstTouchTarget!=null)&#123;mFirstTouchTarget==null;&#125;</span><br><span class="line">                    mGroupFlags &amp;= ~FLAG_DISALLOW_INTERCEPT;</span><br><span class="line">                    ......</span><br><span class="line">                &#125;;</span><br><span class="line">            &#125;</span><br><span class="line">            final boolean intercepted;//ViewGroup是否拦截事件</span><br><span class="line"></span><br><span class="line">            //mFirstTouchTarget是ViewGroup中处理事件(return true)的子View</span><br><span class="line">            //如果没有子View处理则mFirstTouchTarget=null,ViewGroup自己处理</span><br><span class="line">            if (actionMasked == MotionEvent.ACTION_DOWN|| mFirstTouchTarget != null) &#123;</span><br><span class="line">                final boolean disallowIntercept = (mGroupFlags &amp; FLAG_DISALLOW_INTERCEPT) != 0;</span><br><span class="line">                if (!disallowIntercept) &#123;</span><br><span class="line">                    intercepted = onInterceptTouchEvent(ev);//onInterceptTouchEvent</span><br><span class="line">                    ev.setAction(action);</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    intercepted = false;</span><br><span class="line"></span><br><span class="line">                    //如果子类设置requestDisallowInterceptTouchEvent（true）</span><br><span class="line">                    //ViewGroup将无法拦截MotionEvent.ACTION_DOWN以外的事件</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                intercepted = true;</span><br><span class="line"></span><br><span class="line">                //actionMasked != MotionEvent.ACTION_DOWN并且没有子View处理事件，则将事件拦截</span><br><span class="line">                //并且不会再调用onInterceptTouchEvent询问是否拦截</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            ......</span><br><span class="line">            ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们将上面的结论再次写下来，方便对照。<br>①另外如果不消耗ACTION_DOWN事件，那么down,move,up事件都与该View无关，交由父类处理(父类的<code>onTouchEvent</code>方法)（dispatchTouchEvent）<br>②而且这一个事件序列（当前和其它事件）都只能由该ViewGroup处理，并且不会再调用该<code>onInterceptTouchEvent</code>方法去询问是否拦截。（onInterceptTouchEvent return true）</p>
<ul>
<li>首先我们分析上面第21行代码： ViewGroup在两种情况下会拦截事件（ACTION_DOWN || mFirstTouchTarget != null）所以反过来也就是说 I : 当ACTION_MOVE和ACTION_UP事件到来时，如果没有子元素处理事件（mFirstTouchTarget==null），则ViewGroup的onInterceptTouchEvent不会再被调用，而且同一序列中的其它事件都会默认交给它处理（第34行 intercepted=true）；与上面所说的①②呼应。</li>
<li>紧接着22行： ViewGroup<code>disallowIntercept</code>（不拦截）的判定是<code>FLAG_DISALLOW_INTERCEPT</code>标记位，这个标记是通过子View<code>requestDisallowInterceptTouchEvent</code>方法设置的。所以我们可以得出这么一个结论II : 当子View处理了ACTION_DOWN事件(mFirstTouchTarget =该子View)，而且设置了FLAG_DISALLOW_INTERCEPT标记位，那么ViewGroup将无法拦截除了ACTION_DOWN以外的其它事件。（在11行代码ACTION_DOWN时清除了FLAG_DISALLOW_INTERCEPT标记位，所以ViewGroup无论如何都可以选择是否拦截处理ACTION_DOWN）</li>
</ul>
<p>上面变着花样的又一次验证了①②个知识点，不得不说read the fuck source code让我们可以找到一个处理滑动冲突的方法：子View处理DOWN事件并且设置<code>FLAG_DISALLOW_INTERCEPT</code>标记位，就可以不让ViewGroup拦截DOWN以外的事件。</p>
<h4 id="ViewGroup的事件分发"><a href="#ViewGroup的事件分发" class="headerlink" title="ViewGroup的事件分发"></a>ViewGroup的事件分发</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line">    public boolean dispatchTouchEvent(MotionEvent ev) &#123;</span><br><span class="line">    final View[] children = mChildren;</span><br><span class="line">    </span><br><span class="line">    for (int i = childrenCount - 1; i &gt;= 0; i--) &#123;</span><br><span class="line">        final int childIndex = getAndVerifyPreorderedIndex(childrenCount, i, customOrder);</span><br><span class="line">        final View child = getAndVerifyPreorderedView(preorderedList, children, childIndex);</span><br><span class="line">    </span><br><span class="line">        ......</span><br><span class="line">    </span><br><span class="line">        if (!canViewReceivePointerEvents(child) || !isTransformedTouchPointInView(x, y, child, null)) </span><br><span class="line">        &#123;</span><br><span class="line">            ev.setTargetAccessibilityFocus(false);</span><br><span class="line">            //如果子View没有播放动画，而且点击事件的坐标在子View的区域内，继续下面的判断</span><br><span class="line">            continue;</span><br><span class="line">        &#125;</span><br><span class="line">        //判断是否有子View处理了事件</span><br><span class="line">        newTouchTarget = getTouchTarget(child);</span><br><span class="line">    </span><br><span class="line">        if (newTouchTarget != null) &#123;</span><br><span class="line">            //如果已经有子View处理了事件，即mFirstTouchTarget!=null，终止循环。</span><br><span class="line">            newTouchTarget.pointerIdBits |= idBitsToAssign;</span><br><span class="line">            break;</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">        if (dispatchTransformedTouchEvent(ev, false, child, idBitsToAssign)) &#123;</span><br><span class="line">            //点击dispatchTransformedTouchEvent代码发现其执行方法实际为</span><br><span class="line">            //return child.dispatchTouchEvent(event); （因为child!=null）</span><br><span class="line">            //所以如果有子View处理了事件，我们就进行下一步：赋值</span><br><span class="line">    </span><br><span class="line">            ......</span><br><span class="line">    </span><br><span class="line">            newTouchTarget = addTouchTarget(child, idBitsToAssign);</span><br><span class="line">            //addTouchTarget方法里完成了对mFirstTouchTarget的赋值</span><br><span class="line">            alreadyDispatchedToNewTouchTarget = true;</span><br><span class="line">    </span><br><span class="line">            break;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line">private TouchTarget addTouchTarget(@NonNull View child, int pointerIdBits) &#123;</span><br><span class="line">    final TouchTarget target = TouchTarget.obtain(child, pointerIdBits);</span><br><span class="line">    target.next = mFirstTouchTarget;</span><br><span class="line">    mFirstTouchTarget = target;</span><br><span class="line">    return target;</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line">private boolean dispatchTransformedTouchEvent(MotionEvent event, boolean cancel,</span><br><span class="line">        View child, int desiredPointerIdBits) &#123;</span><br><span class="line">        ......</span><br><span class="line">    </span><br><span class="line">        if (child == null) &#123;</span><br><span class="line">        //如果没有子View处理事件，就自己处理</span><br><span class="line">            handled = super.dispatchTouchEvent(event);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">       //有子View，调用子View的dispatchTouchEvent方法</span><br><span class="line">            handled = child.dispatchTouchEvent(event);</span><br><span class="line">    </span><br><span class="line">        ......</span><br><span class="line">    </span><br><span class="line">        return handled;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面为ViewGroup对事件的分发，主要有2点</p>
<ol>
<li>如果有子View，则调用子View的dispatchTouchEvent方法判断是否处理了事件，如果处理了便赋值mFirstTouchTarget，赋值成功则跳出循环。</li>
<li>ViewGroup的事件分发最终还是调用View的<code>dispatchTouchEvent</code>方法，具体如上代码所述。</li>
</ol>
<p>至此View的事件分发机制已经演练完毕，如果事件分发机制理解深入的话，那么处理滑动冲突便是手到擒来了。</p>
<h2 id="View的滑动冲突"><a href="#View的滑动冲突" class="headerlink" title="View的滑动冲突"></a>View的滑动冲突</h2><p>关于View的滑动冲突我们就开门见山吧，因为上述的事件分发已经有足够的理论知识了，我们可以单刀赴会了。</p>
<p><img src="https://img-blog.csdn.net/20170822233424600?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcWlhbjUyMGFv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p>
<p><img src="https://img-blog.csdn.net/20170822232321861?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcWlhbjUyMGFv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="View的滑动冲突"></p>
<p>针对上图，这个是比较普遍的滑动冲突事件，我们先拿它来开刀。</p>
<p>好记性不如烂笔头，我们再次把结论搬到战场上<br>①另外如果不消耗ACTION_DOWN事件，那么down,move,up事件都与该View无关，交由父类处理(父类的<code>onTouchEvent</code>方法)（dispatchTouchEvent）<br>②而且这一个事件序列（当前和其它事件）都只能由该ViewGroup处理，并且不会再调用该<code>onInterceptTouchEvent</code>方法去询问是否拦截。（onInterceptTouchEvent return true）</p>
<p>I : 当ACTION_MOVE和ACTION_UP事件到来时，如果没有子元素处理事件（mFirstTouchTarget==null），则ViewGroup的onInterceptTouchEvent不会再被调用，而且同一序列中的其它事件都会默认交给它处理（第34行 intercepted=true）；</p>
<h3 id="外部拦截"><a href="#外部拦截" class="headerlink" title="外部拦截"></a>外部拦截</h3><p>外部拦截顾名思义就是由父ViewGroup对事件拦截处理（所以重写<code>onInterceptTouchEvent</code>方法即可），子View只能眼巴巴的处理父View“吃剩”的事件。主要有以下几点。</p>
<ul>
<li>父类不能拦截ACTION_DOWN，也就是说必须返回false，根据上述①②和 I 可得。</li>
<li>父类在ACTION_MOVE的时候根据需求，判断是否拦截。</li>
<li>ACTION_UP事件建议返回false或者<code>super.onInterceptTouchEvent</code>，因为如果已经拦截的话，那么并不会调用<code>onInterceptTouchEvent</code>方法再次询问。如果不拦截，而且返回true，子View可能就无法触发onClick等相关事件。</li>
</ul>
<p>ViewGroup ： 需要重写<code>onInterceptTouchEvent</code>，判断是否拦截即可。<br>但是有一种情况：用户正在水平滑动（事件已拦截给ViewGroup），但是水平滑动停止前用户再进行竖直滑动，下面代码我用<code>isSolve</code>进行简单的处理。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">private boolean isIntercept;</span><br><span class="line">private boolean isSolve;//是否完成了拦截判断，如果决定拦截，那么同系列事件就不能设置为不拦截</span><br><span class="line">    </span><br><span class="line">@Override</span><br><span class="line">public boolean onInterceptTouchEvent(MotionEvent ev) &#123;</span><br><span class="line">    switch (ev.getAction()) &#123;</span><br><span class="line">        case MotionEvent.ACTION_DOWN:</span><br><span class="line">            mPointGapF.x = ev.getX();</span><br><span class="line">            mPointGapF.y = ev.getY();</span><br><span class="line">            return false;//down的时候拦截后，就只能交给自己处理了</span><br><span class="line">    </span><br><span class="line">        case MotionEvent.ACTION_MOVE:</span><br><span class="line">            if (!isSolve) &#123;//是否已经决定拦截/不拦截？</span><br><span class="line">                isIntercept = (Math.abs(ev.getX() - mPointGapF.x) &gt; Math.abs(ev.getY() - mPointGapF.y)*2);//如果是左右滑动，且水平角度小于30°，就拦截</span><br><span class="line">                isSolve = true;</span><br><span class="line">            &#125;</span><br><span class="line">            return isIntercept;//如果是左右滑动，就拦截</span><br><span class="line">    &#125;</span><br><span class="line">    return super.onInterceptTouchEvent(ev);</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line">@Override</span><br><span class="line">public boolean onTouchEvent(MotionEvent ev) &#123;</span><br><span class="line">    switch (ev.getAction()) &#123;</span><br><span class="line">        case MotionEvent.ACTION_MOVE:</span><br><span class="line">            scrollBy((int) (mPointGapF.x - ev.getX()), 0);</span><br><span class="line">    </span><br><span class="line">            mPointGapF.x = ev.getX();</span><br><span class="line">            mPointGapF.y = ev.getY();</span><br><span class="line">            break;</span><br><span class="line">    &#125;</span><br><span class="line">    return super.onTouchEvent(ev);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>子View ： 和子View没有多大关系，只需要处理自身的移动操作即可。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">public boolean onTouchEvent(MotionEvent ev) &#123;</span><br><span class="line">        switch (ev.getAction()) &#123;</span><br><span class="line">            case MotionEvent.ACTION_DOWN:</span><br><span class="line">                mPointGapF.x = ev.getX();</span><br><span class="line">                mPointGapF.y = ev.getY();</span><br><span class="line">                break;</span><br><span class="line">            case MotionEvent.ACTION_MOVE:</span><br><span class="line">                scrollBy(0, (int) (mPointGapF.y - ev.getY()));</span><br><span class="line">                mPointGapF.x = ev.getX();</span><br><span class="line">                mPointGapF.y = ev.getY();</span><br><span class="line">                break;</span><br><span class="line">        &#125;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p><img src="https://img-blog.csdn.net/20170823135102485?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcWlhbjUyMGFv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="外部拦截冲突"></p>
<p><img src="https://img-blog.csdn.net/20170823134034862?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcWlhbjUyMGFv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="外部拦截冲突"></p>
<h3 id="内部拦截"><a href="#内部拦截" class="headerlink" title="内部拦截"></a>内部拦截</h3><p>II : 当子View处理了ACTION_DOWN事件(mFirstTouchTarget =该子View)，而且设置了FLAG_DISALLOW_INTERCEPT标记位，那么ViewGroup将无法拦截除了ACTION_DOWN以外的其它事件。</p>
<p>ViewGroup ： 只需在<code>onInterceptTouchEvent</code>MotionEvent.ACTION_DOWN时候不拦截，其他时候都需要拦截，否则父类的<code>onTouchEvent</code>就不能处理任何事件了。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">public boolean onInterceptTouchEvent(MotionEvent ev) &#123;</span><br><span class="line">    switch (ev.getAction()) &#123;</span><br><span class="line">        case MotionEvent.ACTION_DOWN:</span><br><span class="line">            return false;//down的时候拦截后，就只能交给自己处理了</span><br><span class="line">    &#125;</span><br><span class="line">    return true;//如果不拦截，父类的onTouchEvent方法就无事件可以处理。</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line">@Override</span><br><span class="line">public boolean onTouchEvent(MotionEvent ev) &#123;</span><br><span class="line">    switch (ev.getAction()) &#123;</span><br><span class="line">        case MotionEvent.ACTION_MOVE:</span><br><span class="line">            scrollBy((int) (mPointGapF.x - ev.getX()), 0);</span><br><span class="line">    </span><br><span class="line">            mPointGapF.x = ev.getX();</span><br><span class="line">            mPointGapF.y = ev.getY();</span><br><span class="line">            break;</span><br><span class="line">    &#125;</span><br><span class="line">    return super.onTouchEvent(ev);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>子View ： 需要在ACTION_DOWN事件设置getParent().requestDisallowInterceptTouchEvent(true)，并且在ACTION_MOVE的时候通过判断是否禁止父类的拦截。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">private boolean isSolve;</span><br><span class="line">private boolean isIntercept;</span><br><span class="line">    </span><br><span class="line">@Override</span><br><span class="line">public boolean dispatchTouchEvent(MotionEvent ev) &#123;</span><br><span class="line">    switch (ev.getAction()) &#123;</span><br><span class="line">        case MotionEvent.ACTION_DOWN:</span><br><span class="line">            isIntercept = false;</span><br><span class="line">            isSolve = false;</span><br><span class="line">            mPointGapF.x = ev.getX();</span><br><span class="line">            mPointGapF.y = ev.getY();</span><br><span class="line">            getParent().requestDisallowInterceptTouchEvent(true);</span><br><span class="line">            break;</span><br><span class="line">    </span><br><span class="line">        case MotionEvent.ACTION_MOVE:</span><br><span class="line">            if (!isSolve) &#123;</span><br><span class="line">                isSolve = true;</span><br><span class="line">                isIntercept = (Math.abs(ev.getX() - mPointGapF.x) &lt; Math.abs(ev.getY() - mPointGapF.y) * 2);</span><br><span class="line">                getParent().requestDisallowInterceptTouchEvent(isIntercept);</span><br><span class="line">            &#125;</span><br><span class="line">            break;</span><br><span class="line">    &#125;</span><br><span class="line">    return super.dispatchTouchEvent(ev);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最终的效果图和外部拦截的效果一致，这里就不再次贴出来了。  </p>
<h2 id="一图看懂分发机制"><a href="#一图看懂分发机制" class="headerlink" title="一图看懂分发机制"></a>一图看懂分发机制</h2><p> <img src="https://note.youdao.com/yws/api/personal/file/WEBe578b38e326c625af6d4bf41d73cd0c6?method=download&amp;shareKey=fc0868e4d6f2132ec5353a4a77e46a5a" alt="一图看懂分发机制"></p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>通过理论和实战，更清晰的了解了事件的分发机制，从而这些理论知识使得我们更有效的处理滑动冲突事件，所以以后只要再遇见滑动冲突事件，再次巩固View的事件分发，万变不离其宗，定能手到擒来解决这一问题！</p>

          
        
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2018/05/23/《Android优化专题》——-优化下载效率/" itemprop="url">
                  《Android优化专题》—— 优化下载效率
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2018-05-23T20:35:28+08:00" content="2018-05-23">
              2018-05-23
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/Android优化专题/" itemprop="url" rel="index">
                    <span itemprop="name">Android优化专题</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
          

          

          
          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="《Android优化专题》——-优化下载效率"><a href="#《Android优化专题》——-优化下载效率" class="headerlink" title="《Android优化专题》—— 优化下载效率"></a>《Android优化专题》—— 优化下载效率</h1><h2 id="一、用有效率的网络访问方式来优化下载"><a href="#一、用有效率的网络访问方式来优化下载" class="headerlink" title="一、用有效率的网络访问方式来优化下载"></a>一、用有效率的网络访问方式来优化下载</h2><h3 id="1-无线电状态机"><a href="#1-无线电状态机" class="headerlink" title="1.无线电状态机"></a>1.无线电状态机</h3><ul>
<li>Full power：当无线连接被激活的时候，允许设备以最大的传输速率进行操作。</li>
<li>Low power：相对Full power来说，算是一种中间状态，差不多50%的传输速率。</li>
<li>Standby：最低的状态，没有数据连接需要传输。</li>
</ul>
<p>典型的3G无线电波状态机图示：</p>
<p><img src="https://note.youdao.com/yws/api/personal/file/WEB67e9adfaac62ea0736d6f24b4cc0f165?method=download&amp;shareKey=dc3ce6fbd2dec3ee1b1fd82ae1605f1f" alt=""></p>
<h3 id="2-apps如何影响无线状态机"><a href="#2-apps如何影响无线状态机" class="headerlink" title="2. apps如何影响无线状态机"></a>2. apps如何影响无线状态机</h3><h4 id="创建新连接"><a href="#创建新连接" class="headerlink" title="创建新连接"></a>创建新连接</h4><p>每次创建一个网络连接，无线电波就会切换到full power状态（这也是为什么降低连接数可以更省电量以及省流量的原因），结束之后会有一个附加的5s时间切换到low power，再之后会经过12s进入到low energy状态，每次数据传输的会话都会引起无线电波持续消耗大概20s的能量。</p>
<h4 id="传输bundle（序列化）与unbundled（未序列化）数据差别"><a href="#传输bundle（序列化）与unbundled（未序列化）数据差别" class="headerlink" title="传输bundle（序列化）与unbundled（未序列化）数据差别"></a>传输bundle（序列化）与unbundled（未序列化）数据差别</h4><p><img src="https://note.youdao.com/yws/api/personal/file/WEB7ab6e5aa0af3cc84fbf0e5e5bde4be5e?method=download&amp;shareKey=1e98b1be3b6eb2e4299ee7522bdffeb5" alt=""></p>
<p>一个app传递1秒钟的unbundled data会使得无线电波持续活动18秒【18=1秒的传输数据+5秒过渡时间回到low power+12秒过渡时间回到standby】。因此每一分钟，它会消耗18秒high power的电量，42秒的low power的电量。</p>
<p>如果每分钟app会传输bundle的data持续3秒的话，其中会使得无线电波持续在high power状态仅仅8秒钟，在low power状态仅仅12秒钟。 上面第二种传输bundle data的例子，可以看到减少了大量的电量消耗。</p>
<h3 id="3-预取数据"><a href="#3-预取数据" class="headerlink" title="3. 预取数据"></a>3. 预取数据</h3><blockquote>
<p>预取数据是一种减少独立数据传输会话数量的有效方法。在单次操作的时候，通过一次连接，在最大能力下，根据给出的时间下载到所有的数据。</p>
</blockquote>
<p>对于预取，取太多，不仅用户可能根本用不到那么多，而且还耗费了电量和流量。取太少，达不到预取的效果。</p>
<p>如何控制预取的大小？</p>
<p>这需要根据正在下载的数据大小与可能被用到的数据量来决定。一个基于上面状态机情况的比较大概的建议是：对于数据来说，大概有50%的机会可能用在当前用户的会话中，那么我们可以预取大约6秒(大约1-2Mb)，这大概使得潜在可能要用的数据量与可能已经下载好的数据量相一致。</p>
<p>通常来说，预取1-5Mb会比较好，这种情况下，我们仅仅只需要每隔2-5分钟开始另一段下载。根据这个原理，大数据的下载，比如视频文件，应该每隔2-5秒开始另一段下载，这样能有效的预取到下面几分钟内的数据进行预览。</p>
<h3 id="4-批量传输与连接"><a href="#4-批量传输与连接" class="headerlink" title="4. 批量传输与连接"></a>4. 批量传输与连接</h3><p>每次初始化一个连接（与需要传输的数据量无关），有可能导致无线电波持续花费20s的电量。</p>
<p>对于数据进行bundle操作，并且创建一个序列可以使得大量数据集中进行发送，这样可以使得无线电波的激活时间尽可能的少，同事减少大部分的电量花费。</p>
<h3 id="5-减少连接次数"><a href="#5-减少连接次数" class="headerlink" title="5. 减少连接次数"></a>5. 减少连接次数</h3><p>重用之前存在的网络连接比重新创建一个连接是更有效率的。当可以用一个GET请求解决的情况下，不要同时创建多个网络连接。</p>
<p>可以在一个连接要关闭时，不要立即关闭，而是在timeout之前关闭。</p>
<p>使用HttpUrlConnection，而不是HttpClient，前者做了response cache</p>
<h3 id="6-使用DDMS（Dalvik-Debug-Monitor-Server）网络通信工具来检测网络使用情况"><a href="#6-使用DDMS（Dalvik-Debug-Monitor-Server）网络通信工具来检测网络使用情况" class="headerlink" title="6. 使用DDMS（Dalvik Debug Monitor Server）网络通信工具来检测网络使用情况"></a>6. 使用DDMS（Dalvik Debug Monitor Server）网络通信工具来检测网络使用情况</h3><p><img src="https://note.youdao.com/yws/api/personal/file/WEB6200ba40b6d05b617272f233ce870afc?method=download&amp;shareKey=dbfc00a9fc45b3d02971ddadca2c65d4" alt=""></p>
<p>通过监测数据传输的频率和每次传输的数据量，可以看出哪些地方可以进行优化。类似于图中短小钉子形状的地方，可以和附近位置的请求进行merge操作。</p>
<p>Traffic Status API可以使用TrafficStats.setThreadStatsTag()的方法标记数据传输发生在某个Thread里面。可以手动使用tagSocket()进行标记或者untagSocket()来取消标记。</p>
<h2 id="二、调整更新的频率"><a href="#二、调整更新的频率" class="headerlink" title="二、调整更新的频率"></a>二、调整更新的频率</h2><h3 id="1-使用C2DM作为轮询方式之一"><a href="#1-使用C2DM作为轮询方式之一" class="headerlink" title="1.使用C2DM作为轮询方式之一"></a>1.使用C2DM作为轮询方式之一</h3><blockquote>
<p>C2DM是一个用来从server到特定app传输数据的轻量级机制。使用C2DM，server会在某个app有需要获取新数据的时候通知app有这个消息。</p>
</blockquote>
<p>但中国大陆的Google框架通常会被移除，使得C2DM没法在中国大陆的App上使用。</p>
<p>可参考各大厂商的推送定制。</p>
<h3 id="2-通过不定时的重复提醒和指数退避来优化轮询操作"><a href="#2-通过不定时的重复提醒和指数退避来优化轮询操作" class="headerlink" title="2.通过不定时的重复提醒和指数退避来优化轮询操作"></a>2.通过不定时的重复提醒和指数退避来优化轮询操作</h3><p>如果必须要使用轮询机制，可以考虑以下几个方面的优化：</p>
<ol>
<li>如果多个提醒都安排在某个小的时间段内，考虑把这多个操作在一个无线电状态下操作完。</li>
<li>使用Alarm时，设置的提醒类型为非wake类型（对于非紧急通知消息时，避免在屏幕熄灭状态下，将设备唤醒），减少电量的损耗。</li>
<li>在app上一次更新操作之后还未被使用的情况下，使用指数退避算法（exponential back-off algorithm）来减少更新频率。</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">private void retryIn(long interval) &#123;</span><br><span class="line">  boolean success = attemptTransfer();</span><br><span class="line"></span><br><span class="line">  if (!success) &#123;</span><br><span class="line">    retryIn(interval*2 &lt; MAX_RETRY_INTERVAL ?</span><br><span class="line">            interval*2 : MAX_RETRY_INTERVAL);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="二进制退避算法"><a href="#二进制退避算法" class="headerlink" title="二进制退避算法"></a>二进制退避算法</h4><ol>
<li>确定基本退避时间，一般为端到端的往返时间为2t，2t也成为冲突窗口或争用期。</li>
<li>定义参数k，k与冲突次数有关，规定k不能超过10，k=Min[冲突次数，10]。在冲突次数大于10，小于16时，k不再增大，一直取值为10。</li>
<li>从离散的整数集合[0,1,2，……，(2k-1)]中随机的取出一个数r，等待的时延为r倍的基本退避时间，等于r x 2t。r的取值范围与冲突次数k有关，r可选的随机取值为2k个、这也是称为二进制退避算法的起因。</li>
<li>当冲突次数大于10以后，都是从0—210-1个2t中随机选择一个作为等待时间。</li>
<li>当冲突次数超过16次后，发送失败，丢弃传输的帧，发送错误报告。</li>
</ol>
<h2 id="三、使用缓存来避免重复下载"><a href="#三、使用缓存来避免重复下载" class="headerlink" title="三、使用缓存来避免重复下载"></a>三、使用缓存来避免重复下载</h2><blockquote>
<p>减少下载的最基本方法是仅仅下载你想要的数据，通过类似上次更新时间来制定查询数据的条件。在下载图片时，server尽量减少图片的大小，比如对图片进行剪裁等处理。</p>
</blockquote>
<h3 id="1-缓存到本地"><a href="#1-缓存到本地" class="headerlink" title="1. 缓存到本地"></a>1. 缓存到本地</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">long currentTime = System.currentTimeMillis());</span><br><span class="line"></span><br><span class="line">HttpURLConnection conn = (HttpURLConnection) url.openConnection();</span><br><span class="line"></span><br><span class="line">long expires = conn.getHeaderFieldDate(&quot;Expires&quot;, currentTime);</span><br><span class="line">long lastModified = conn.getHeaderFieldDate(&quot;Last-Modified&quot;, currentTime);</span><br><span class="line"></span><br><span class="line">setDataExpirationDate(expires);</span><br><span class="line"></span><br><span class="line">if (lastModified &lt; lastUpdateTime) &#123;</span><br><span class="line">  // Skip update  </span><br><span class="line">&#125; else &#123;</span><br><span class="line">  // Parse update  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以使用下面的方法获取External缓存目录：目录是Android/data/data/com.xxx.xxx/cache</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Context.getExternalCacheDir();</span><br></pre></td></tr></table></figure>
<p>获取内部缓存的方法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Context.getCache()</span><br></pre></td></tr></table></figure>
<p>这里注意不要随便在sdcard下创建目录存放缓存，因为这个文件夹不会随着程序的卸载而删除。既影响用户体验，又会把一些不想让用户知道的数据泄露出去。</p>
<h3 id="2-使用HttpUrlConnect-Response缓存"><a href="#2-使用HttpUrlConnect-Response缓存" class="headerlink" title="2. 使用HttpUrlConnect Response缓存"></a>2. 使用HttpUrlConnect Response缓存</h3><p>我们可以通过反射机制开启HTTP response cache</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">private void enableHttpResponseCache() &#123;</span><br><span class="line">  try &#123;</span><br><span class="line">    long httpCacheSize = 10 * 1024 * 1024; // 10 MiB  </span><br><span class="line">    File httpCacheDir = new File(getCacheDir(), &quot;http&quot;);</span><br><span class="line">    Class.forName(&quot;android.net.http.HttpResponseCache&quot;)</span><br><span class="line">         .getMethod(&quot;install&quot;, File.class, long.class)</span><br><span class="line">         .invoke(null, httpCacheDir, httpCacheSize);</span><br><span class="line">  &#125; catch (Exception httpResponseCacheNotAvailable) &#123;</span><br><span class="line">    Log.d(TAG, &quot;HTTP response cache is unavailable.&quot;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>也可以在onCreate中加入以下代码开启</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">protected void onCreate(Bundle savedInstanceState) &#123;</span><br><span class="line">     ...</span><br><span class="line"></span><br><span class="line">     try &#123;</span><br><span class="line">         File httpCacheDir = new File(context.getCacheDir(), &quot;http&quot;);</span><br><span class="line">         long httpCacheSize = 10 * 1024 * 1024; // 10 MiB</span><br><span class="line">         HttpResponseCache.install(httpCacheDir, httpCacheSize);</span><br><span class="line">     &#125; catch (IOException e) &#123;</span><br><span class="line">         Log.i(TAG, &quot;HTTP response cache installation failed:&quot; + e);</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> protected void onStop() &#123;</span><br><span class="line">     ...</span><br><span class="line"></span><br><span class="line">     HttpResponseCache cache = HttpResponseCache.getInstalled();</span><br><span class="line">     if (cache != null) &#123;</span><br><span class="line">         cache.flush();</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<p>以上代码会在Android4.0以上开启response code，所有cache中的HTTP请求都可以直接在本地存储中响应，就不需要开启一个新的网络连接。被cache起来的response可以被server确保没有过期，这样减少了带宽。</p>
<h2 id="四、根据网络类型来切换下载模式"><a href="#四、根据网络类型来切换下载模式" class="headerlink" title="四、根据网络类型来切换下载模式"></a>四、根据网络类型来切换下载模式</h2><blockquote>
<p>WIFI要比无线电波消耗的电量要少很多，而且对于无线电波而言（3G,2G,LTE等）也存在不同电量的区别。</p>
</blockquote>
<h3 id="1-尽量WIFI"><a href="#1-尽量WIFI" class="headerlink" title="1. 尽量WIFI"></a>1. 尽量WIFI</h3><p>我们尽量要在连接WIFI的时候进行下载，更新数据等操作。</p>
<h3 id="2-尽量使用更大的带宽下载更多的数据，而不是经常去下载"><a href="#2-尽量使用更大的带宽下载更多的数据，而不是经常去下载" class="headerlink" title="2. 尽量使用更大的带宽下载更多的数据，而不是经常去下载"></a>2. 尽量使用更大的带宽下载更多的数据，而不是经常去下载</h3><p>相对更宽的带宽会有更长的状态切换时间（从full power过渡到standby有更长一段时间的延迟），过渡时间的电量通常是固定的，每次传输会话过程中尽量一次性把事情做完，而不是断断续续请求就更有效率了。</p>
<p>如果LTE无线电的带宽与电量消耗都是3G无线电的2倍，我们应该在每次会话的时候都下载4倍于3G的数据量，或者是差不多10Mb</p>
<p>我们可以根据connectivity manager来判断当前激活的无线电波，根据结果来做prefetch。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">ConnectivityManager cm =</span><br><span class="line"> (ConnectivityManager)getSystemService(Context.CONNECTIVITY_SERVICE);</span><br><span class="line"></span><br><span class="line">TelephonyManager tm =</span><br><span class="line">  (TelephonyManager)getSystemService(Context.TELEPHONY_SERVICE);</span><br><span class="line"></span><br><span class="line">NetworkInfo activeNetwork = cm.getActiveNetworkInfo();</span><br><span class="line"></span><br><span class="line">int PrefetchCacheSize = DEFAULT_PREFETCH_CACHE;</span><br><span class="line"></span><br><span class="line">switch (activeNetwork.getType()) &#123;</span><br><span class="line">  case (ConnectivityManager.TYPE_WIFI):</span><br><span class="line">    PrefetchCacheSize = MAX_PREFETCH_CACHE; break;</span><br><span class="line">  case (ConnectivityManager.TYPE_MOBILE): &#123;</span><br><span class="line">    switch (tm.getNetworkType()) &#123;</span><br><span class="line">      case (TelephonyManager.NETWORK_TYPE_LTE |</span><br><span class="line">            TelephonyManager.NETWORK_TYPE_HSPAP):</span><br><span class="line">        PrefetchCacheSize *= 4;</span><br><span class="line">        break;</span><br><span class="line">      case (TelephonyManager.NETWORK_TYPE_EDGE |</span><br><span class="line">            TelephonyManager.NETWORK_TYPE_GPRS):</span><br><span class="line">        PrefetchCacheSize /= 2;</span><br><span class="line">        break;</span><br><span class="line">      default: break;</span><br><span class="line">    &#125;</span><br><span class="line">    break;</span><br><span class="line">  &#125;</span><br><span class="line">  default: break;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
          
        
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2018/05/06/Java虚拟机——双亲委派模型/" itemprop="url">
                  Java虚拟机——双亲委派模型
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2018-05-06T21:58:40+08:00" content="2018-05-06">
              2018-05-06
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/基础知识/" itemprop="url" rel="index">
                    <span itemprop="name">基础知识</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
          

          

          
          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="双亲委派模型"><a href="#双亲委派模型" class="headerlink" title="双亲委派模型"></a>双亲委派模型</h1><div class="htmledit_views"><br>                <p><span style="font-size:18px;">说道双亲委派模型，就要从类加载器说起。。。。。。。。。。。</span></p><p></p><p style="margin-top:0px;margin-bottom:0px;padding-top:0px;padding-bottom:0px;font-family:Arial;line-height:26px;"><span style="font-size:18px;">Java虚拟机类加载过程是把Class类文件加载到内存，并对Class文件中的数据进行校验、转换解析和初始化，最终形成可以被虚拟机直接使用的java类型的过程。</span></p><p style="margin-top:0px;margin-bottom:0px;padding-top:0px;padding-bottom:0px;font-family:Arial;line-height:26px;"><span style="font-size:18px;">在加载阶段，java虚拟机需要完成以下3件事：</span></p><p style="margin-top:0px;margin-bottom:0px;padding-top:0px;padding-bottom:0px;font-family:Arial;line-height:26px;"><span style="font-size:18px;color:#cc66cc;">a.通过一个类的全限定名来获取定义此类的二进制字节流。</span></p><p style="margin-top:0px;margin-bottom:0px;padding-top:0px;padding-bottom:0px;font-family:Arial;line-height:26px;"><span style="font-size:18px;color:#cc66cc;">b.将定义类的二进制字节流所代表的静态存储结构转换为方法区的运行时数据结构。</span></p><p style="margin-top:0px;margin-bottom:0px;padding-top:0px;padding-bottom:0px;font-family:Arial;line-height:26px;"><span style="font-size:18px;color:#cc66cc;">c.在java堆中生成一个代表该类的java.lang.Class对象，作为方法区数据的访问入口。</span></p><span style="font-size:18px;">而类的加载过程是通过类加载器完成的。</span><p><span style="font-size:18px;"><br></span></p><p><span style="font-size:18px;"><span style="font-family:Arial;line-height:26px;">在Java中，任意一个类都需要由加载它的类加载器和这个类本身一同确定其在java虚拟机中的唯一性，即比较两个类是否相等，只有在这两个类是由同一个类加载器加载的前提之下才有意义，否则，即使这两个类来源于同一个Class类文件，只要加载它的类加载器不相同，那么这两个类必定不相等(这里的相等包括代表类的Class对象的equals()方法、isAssignableFrom()方法、isInstance()方法和instanceof关键字的结果)。</span><br></span></p><p><span style="font-family:Arial;line-height:26px;"><span style="font-size:18px;">看下面的例子：</span></span></p><div class="dp-highlighter bg_java"><div class="bar"><div class="tools"><b>[java]</b> <a href="#" class="ViewSource" title="view plain" onclick="dp.sh.Toolbar.Command('ViewSource',this);return false;">view plain</a><span data-mod="popu_168"> <a href="#" class="CopyToClipboard" title="copy" onclick="dp.sh.Toolbar.Command('CopyToClipboard',this);return false;">copy</a><div style="position: absolute; left: 190px; top: 763px; width: 16px; height: 16px; z-index: 99;"><embed id="ZeroClipboardMovie_1" src="https://csdnimg.cn/public/highlighter/ZeroClipboard.swf" loop="false" menu="false" quality="best" bgcolor="#ffffff" width="16" height="16" name="ZeroClipboardMovie_1" align="middle" allowscriptaccess="always" allowfullscreen="false" type="application/x-shockwave-flash" pluginspage="http://www.macromedia.com/go/getflashplayer" flashvars="id=1&amp;width=16&amp;height=16" wmode="transparent"></div><div style="position: absolute; left: 190px; top: 763px; width: 16px; height: 16px; z-index: 99;"><embed id="ZeroClipboardMovie_3" src="https://csdnimg.cn/public/highlighter/ZeroClipboard.swf" loop="false" menu="false" quality="best" bgcolor="#ffffff" width="16" height="16" name="ZeroClipboardMovie_3" align="middle" allowscriptaccess="always" allowfullscreen="false" type="application/x-shockwave-flash" pluginspage="http://www.macromedia.com/go/getflashplayer" flashvars="id=3&amp;width=16&amp;height=16" wmode="transparent"></div></span><span data-mod="popu_169"> <a href="#" class="PrintSource" title="print" onclick="dp.sh.Toolbar.Command('PrintSource',this);return false;">print</a></span><a href="#" class="About" title="?" onclick="dp.sh.Toolbar.Command('About',this);return false;">?</a></div></div><ol start="1" class="dp-j"><li class="alt"><span><span>&nbsp;&nbsp;</span></span></li></ol></div><pre class="java" name="code" style="display: none;"></pre><pre style="background-color:#2b2b2b;color:#a9b7c6;font-family:'Courier New';font-size:11.3pt;"><span style="color:#cc7832;">package </span>com.hfax.common.depository.front.test<span style="color:#cc7832;">;<br></span><span style="color:#cc7832;"><br></span><span style="color:#cc7832;">import </span>java.io.IOException<span style="color:#cc7832;">;<br></span><span style="color:#cc7832;">import </span>java.io.InputStream<span style="color:#cc7832;">;<br></span><span style="color:#cc7832;"><br></span><span style="color:#cc7832;"><br></span><span style="color:#cc7832;">public class </span>test2 {<br>    <span style="color:#cc7832;">public static void </span><span style="color:#ffc66d;">main</span>(String[] args)<span style="color:#cc7832;">throws </span>Exception{<br>        <span style="color:#808080;">//匿名内部类实现自定义类加载器<br></span><span style="color:#808080;">        </span><span style="color:#cc7832;">final </span>ClassLoader  myClassLoader = <span style="color:#cc7832;">new </span>ClassLoader(){<br>                <span style="color:#cc7832;">protected </span>Class&lt;?&gt; <span style="color:#ffc66d;">findClass</span>(String name)<span style="color:#cc7832;">throws </span>ClassNotFoundException {<br>                    <span style="color:#808080;">//获取类文件名<br></span><span style="color:#808080;">                    </span>String filename = name.substring(name.lastIndexOf(<span style="color:#6a8759;">“.”</span>) + <span style="color:#6897bb;">1</span>) + <span style="color:#6a8759;">“.class”</span><span style="color:#cc7832;">;<br></span><span style="color:#cc7832;">                    </span>InputStream in = getClass().getResourceAsStream(filename)<span style="color:#cc7832;">;<br></span><span style="color:#cc7832;">                    try </span>{<br>                        <span style="color:#cc7832;">byte</span>[] b = <span style="color:#cc7832;">new byte</span>[in.available()]<span style="color:#cc7832;">;<br></span><span style="color:#cc7832;">                        return </span>defineClass(name<span style="color:#cc7832;">, </span>b<span style="color:#cc7832;">, </span><span style="color:#6897bb;">0</span><span style="color:#cc7832;">, </span>b.<span style="color:#9876aa;">length</span>)<span style="color:#cc7832;">;<br></span><span style="color:#cc7832;">                    </span>} <span style="color:#cc7832;">catch </span>(IOException e) {<br>                        <span style="color:#cc7832;">throw new </span>ClassNotFoundException(name)<span style="color:#cc7832;">;<br></span><span style="color:#cc7832;">                    </span>}<br>                }<br>        }<span style="color:#cc7832;">;<br></span><span style="color:#cc7832;">        </span>Object obj = myClassLoader.loadClass(<span style="color:#6a8759;">“com.hfax.common.depository.front.test.test2”</span>).newInstance()<span style="color:#cc7832;">;<br></span><span style="color:#cc7832;">        </span>System.<span style="color:#9876aa;"><em>out</em></span>.println(obj.getClass())<span style="color:#cc7832;">;<br></span><span style="color:#cc7832;">        </span>System.<span style="color:#9876aa;"><em>out</em></span>.println(obj <span style="color:#cc7832;">instanceof </span>com.hfax.common.depository.front.test.test2)<span style="color:#cc7832;">;<br></span><span style="color:#cc7832;">    </span>}<br>}<br></pre><br><p></p><p style="margin-top:0px;margin-bottom:0px;padding-top:0px;padding-bottom:0px;font-family:Arial;line-height:26px;">输出结果如下：</p><p style="margin-top:0px;margin-bottom:0px;padding-top:0px;padding-bottom:0px;font-family:Arial;line-height:26px;">com.test.ClassLoaderTest</p><p style="margin-top:0px;margin-bottom:0px;padding-top:0px;padding-bottom:0px;font-family:Arial;line-height:26px;">false （<span style="color:#ff6666;">jdk1.2版本以后引入了双亲委派模型后，此时会返回true，想得到false结果的小伙伴可以用1.2以前的版本测试</span>）</p><p style="margin-top:0px;margin-bottom:0px;padding-top:0px;padding-bottom:0px;font-family:Arial;line-height:26px;">之所以instanceof会返回false，是因为com.test.ClassLoaderTest类默认使用Application ClassLoader加载，而obj是通过自定义类加载器加载的，类加载不相同，因此不相等。</p><br><p><span style="font-family:Arial;line-height:26px;"><span style="font-size:18px;">说到这里就轮到双亲委派模型出场了。</span></span></p><p><span style="font-family:Arial;line-height:26px;"><span style="font-size:18px;">先看双亲委派模型的经典体系统：</span></span></p><p style="text-align:center;"><span style="font-family:Arial;line-height:26px;"><span style="font-size:18px;"><img src="https://img-blog.csdn.net/20160102154038185" alt=""><br></span></span></p><p style="text-align:left;"><span style="font-family:Arial;line-height:26px;"><span style="font-size:18px;">做一个简单解释：</span></span></p><p style="text-align:left;"><span style="font-family:Arial;line-height:26px;"><span style="font-size:18px;"></span></span></p><p style="margin-top:0px;margin-bottom:0px;padding-top:0px;padding-bottom:0px;font-family:Arial;line-height:26px;">(1).BootStrap ClassLoader：启动类加载器，负责加载存放在%JAVA_HOME%\lib目录中的，或者通被-Xbootclasspath参数所指定的路径中的，并且被java虚拟机识别的(仅按照文件名识别，如rt.jar，名字不符合的类库，即使放在指定路径中也不会被加载)类库到虚拟机的内存中，启动类加载器无法被java程序直接引用。</p><p style="margin-top:0px;margin-bottom:0px;padding-top:0px;padding-bottom:0px;font-family:Arial;line-height:26px;">(2).Extension ClassLoader：扩展类加载器，由sun.misc.Launcher$ExtClassLoader实现，负责加载%JAVA_HOME%\lib\ext目录中的，或者被java.ext.dirs系统变量所指定的路径中的所有类库，开发者可以直接使用扩展类加载器。</p><p style="margin-top:0px;margin-bottom:0px;padding-top:0px;padding-bottom:0px;font-family:Arial;line-height:26px;">(3).Application ClassLoader：应用程序类加载器，由sun.misc.Launcher$AppClassLoader实现，负责加载用户类路径classpath上所指定的类库，是类加载器ClassLoader中的getSystemClassLoader()方法的返回值，开发者可以直接使用应用程序类加载器，如果程序中没有自定义过类加载器，该加载器就是程序中默认的类加载器。</p><br><p style="text-align:left;"><span style="font-family:Arial;line-height:26px;"><span style="font-size:18px;"><span style="color:#ff0000;">这里需要注意的是<span style="font-family:Arial;line-height:26px;">上述三个JDK提供的类加载器虽然是父子类加载器关系，但是没有使用继承，而是使用了组合关系。</span></span></span></span></p><p style="text-align:left;"><span style="font-family:Arial;line-height:26px;"><span style="font-family:Arial;line-height:26px;"><span style="font-size:18px;"></span></span></span></p><p style="margin-top:0px;margin-bottom:0px;padding-top:0px;padding-bottom:0px;font-family:Arial;line-height:26px;"><span style="color:#3366ff;">从JDK1.2开始，java虚拟机规范推荐开发者使用双亲委派模式(ParentsDelegation Model)进行类加载，其加载过程如下：</span></p><p style="margin-top:0px;margin-bottom:0px;padding-top:0px;padding-bottom:0px;font-family:Arial;line-height:26px;"><span style="color:#3366ff;">(1).如果一个类加载器收到了类加载请求，它首先不会自己去尝试加载这个类，而是把类加载请求委派给父类加载器去完成。</span></p><p style="margin-top:0px;margin-bottom:0px;padding-top:0px;padding-bottom:0px;font-family:Arial;line-height:26px;"><span style="color:#3366ff;">(2).每一层的类加载器都把类加载请求委派给父类加载器，直到所有的类加载请求都应该传递给顶层的启动类加载器。</span></p><p style="margin-top:0px;margin-bottom:0px;padding-top:0px;padding-bottom:0px;font-family:Arial;line-height:26px;"><span style="color:#3366ff;">(3).如果顶层的启动类加载器无法完成加载请求，子类加载器尝试去加载，如果连最初发起类加载请求的类加载器也无法完成加载请求时，将会抛出ClassNotFoundException，而不再调用其子类加载器去进行类加载。</span></p><span style="font-family:Arial;line-height:26px;"><span style="color:#3366ff;">双亲委派 模式的类加载机制的优点是java类它的类加载器一起具备了一种带优先级的层次关系，越是基础的类，越是被上层的类加载器进行加载，保证了java程序的稳定运行。双亲委派模式的实现：</span></span><br><p style="text-align:left;"><span style="font-family:Arial;line-height:26px;"><span style="font-family:Arial;line-height:26px;"><span style="font-family:Arial;line-height:26px;"><span style="font-size:18px;"></span></span></span></span></p><div class="dp-highlighter bg_java"><div class="bar"><div class="tools"><b>[java]</b> <a href="#" class="ViewSource" title="view plain" onclick="dp.sh.Toolbar.Command('ViewSource',this);return false;">view plain</a><span data-mod="popu_168"> <a href="#" class="CopyToClipboard" title="copy" onclick="dp.sh.Toolbar.Command('CopyToClipboard',this);return false;">copy</a><div style="position: absolute; left: 190px; top: 2676px; width: 16px; height: 16px; z-index: 99;"><embed id="ZeroClipboardMovie_2" src="https://csdnimg.cn/public/highlighter/ZeroClipboard.swf" loop="false" menu="false" quality="best" bgcolor="#ffffff" width="16" height="16" name="ZeroClipboardMovie_2" align="middle" allowscriptaccess="always" allowfullscreen="false" type="application/x-shockwave-flash" pluginspage="http://www.macromedia.com/go/getflashplayer" flashvars="id=2&amp;width=16&amp;height=16" wmode="transparent"></div><div style="position: absolute; left: 190px; top: 2676px; width: 16px; height: 16px; z-index: 99;"><embed id="ZeroClipboardMovie_4" src="https://csdnimg.cn/public/highlighter/ZeroClipboard.swf" loop="false" menu="false" quality="best" bgcolor="#ffffff" width="16" height="16" name="ZeroClipboardMovie_4" align="middle" allowscriptaccess="always" allowfullscreen="false" type="application/x-shockwave-flash" pluginspage="http://www.macromedia.com/go/getflashplayer" flashvars="id=4&amp;width=16&amp;height=16" wmode="transparent"></div></span><span data-mod="popu_169"> <a href="#" class="PrintSource" title="print" onclick="dp.sh.Toolbar.Command('PrintSource',this);return false;">print</a></span><a href="#" class="About" title="?" onclick="dp.sh.Toolbar.Command('About',this);return false;">?</a></div></div><ol start="1" class="dp-j"><li class="alt"><span><span>&nbsp;&nbsp;</span></span></li></ol></div><pre class="java" name="code" style="display: none;"></pre><pre style="background-color:#2b2b2b;color:#a9b7c6;font-family:'Courier New';font-size:11.3pt;"><span style="color:#cc7832;">protected synchronized </span>Class&lt;?&gt; <span style="color:#ffc66d;">loadClass</span>(String name<span style="color:#cc7832;">, </span>Boolean resolve) <span style="color:#cc7832;">throws </span>ClassNotFoundException{<br>    <span style="color:#808080;">//首先检查请求的类是否已经被加载过<br></span><span style="color:#808080;">    </span>Class c = findLoadedClass(name)<span style="color:#cc7832;">;<br></span><span style="color:#cc7832;">    if</span>(c == <span style="color:#cc7832;">null</span>){<br><br>        <span style="color:#cc7832;">try</span>{<br>            <span style="color:#cc7832;">if</span>(parent != <span style="color:#cc7832;">null</span>){<span style="color:#808080;">//委派父类加载器加载<br></span><span style="color:#808080;">                </span>c = parent.loadClass(name<span style="color:#cc7832;">, false</span>)<span style="color:#cc7832;">;<br></span><span style="color:#cc7832;">            </span>}<br>            <span style="color:#cc7832;">else</span>{<span style="color:#808080;">//委派启动类加载器加载<br></span><span style="color:#808080;">                </span>c = findBootstrapClassOrNull(name)<span style="color:#cc7832;">;<br></span><span style="color:#cc7832;">            </span>}<br>        }<span style="color:#cc7832;">catch</span>(ClassNotFoundException e){<br>            <span style="color:#808080;">//父类加载器无法完成类加载请求<br></span><span style="color:#808080;">        </span>}<br>        <span style="color:#cc7832;">if</span>(c == <span style="color:#cc7832;">null</span>){<span style="color:#808080;">//本身类加载器进行类加载<br></span><span style="color:#808080;">            </span>c = findClass(name)<span style="color:#cc7832;">;<br></span><span style="color:#cc7832;">        </span>}<br>    }<br>    <span style="color:#cc7832;">if</span>(resolve){<br>        resolveClass(c)<span style="color:#cc7832;">;<br></span><span style="color:#cc7832;">    </span>}<br>    <span style="color:#cc7832;">return </span>c<span style="color:#cc7832;">;<br></span>}</pre><br>通过双亲委派模型我们就能很好解决文章开始我们自定义的类加载器所出现的问题。<p></p><p style="text-align:left;"><span style="font-family:Arial;line-height:26px;"><span style="font-family:Arial;line-height:26px;"><span style="font-family:Arial;line-height:26px;"><span style="font-size:18px;color:#ff0000;">这里需要注意的是<span style="font-family:Arial;line-height:26px;">在JDK1.2之前，类加载尚未引入双亲委派模式，因此实现自定义类加载器时常常重写loadClass方法，提供双亲委派逻辑，从JDK1.2之后，双亲委派模式已经被引入到类加载体系中，自定义类加载器时不需要在自己写双亲委派的逻辑，因此不鼓励重写loadClass方法，而推荐重写findClass方法。</span></span></span></span></span></p>            </div>
          
        
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2018/05/04/HTTP浅析（二）HTTP结构/" itemprop="url">
                  HTTP浅析（二）HTTP结构
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2018-05-04T14:33:40+08:00" content="2018-05-04">
              2018-05-04
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/基础知识/" itemprop="url" rel="index">
                    <span itemprop="name">基础知识</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
          

          

          
          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="HTTP浅析（二）HTTP结构"><a href="#HTTP浅析（二）HTTP结构" class="headerlink" title="HTTP浅析（二）HTTP结构"></a>HTTP浅析（二）HTTP结构</h1><blockquote>
<p>本篇主要介绍HTTP服务器、代理、缓存等</p>
</blockquote>
<h2 id="web服务器主流有哪几种？"><a href="#web服务器主流有哪几种？" class="headerlink" title="web服务器主流有哪几种？"></a>web服务器主流有哪几种？</h2><ul>
<li>免费的Apache软件占据了所有web服务器大约60%的市场</li>
<li>微软的Web服务器占据了另外30%</li>
<li>Sun的iPlanet占据了另外的3%</li>
</ul>
<p><strong>数据仅供参考</strong></p>
<h2 id="web服务器会做些什么？"><a href="#web服务器会做些什么？" class="headerlink" title="web服务器会做些什么？"></a>web服务器会做些什么？</h2><ol>
<li>建立连接——接受一个客户端连接，如果不希望与这个客户端连接，就将其关闭。</li>
<li>接收请求——从网络中读取一条HTTP请求报文</li>
<li>处理请求——对请求报文进行解释，并采取行动。</li>
<li>访问资源——访问报文中指定的资源。</li>
<li>构建资源——创建带有正确首部的HTTP响应报文。</li>
<li>发送响应——将响应回送给客户端</li>
<li>记录事物处理过程——将与已完成事物有关的内容记录在一个日志文件中。</li>
</ol>
<h2 id="代理和网关有什么区别？"><a href="#代理和网关有什么区别？" class="headerlink" title="代理和网关有什么区别？"></a>代理和网关有什么区别？</h2><p><img src="https://note.youdao.com/yws/api/personal/file/WEB53413a837c5da0d75510df33c6728a07?method=download&amp;shareKey=fc560d0b484a2350a1895cd1bc2ff918" alt="代理和网关的区别"></p>
<p>代理连接的是两个或多个使用相同协议的应用程序，而网关连接的是两个或者多个不同协议的端点。<strong>区别在于网关的前后协议不同</strong></p>
<h2 id="我们为什么要使用代理？"><a href="#我们为什么要使用代理？" class="headerlink" title="我们为什么要使用代理？"></a>我们为什么要使用代理？</h2><ul>
<li>儿童过滤器，可以利用过滤器代理来阻止儿童访问成人内容</li>
<li>文档访问控制，可以用代理服务器在大量Web服务器和Web资源之间实现统一的访问控制策略，创建审核跟踪机制。</li>
<li>安全防火墙，网络安全工程师会使用代理服务器来提高安全性。</li>
<li>Web缓存，代理缓存维护了常用文档的本地副本，将它们按需提供，减少缓慢且昂贵的因特网通信。</li>
<li>反向代理，代理可以假扮Web服务器。这些被称为替代物或者反向代理的代理接收发给Web服务器的真实请求，它们可以发起与其他服务器的通信，以便按需定位所请求的内容。<img src="https://note.youdao.com/yws/api/personal/file/WEB6203273834d2ab2ca34dc6925e688d16?method=download&amp;shareKey=be2b266753fa27bcb7c3bd3ea0305295" alt="反向代理"></li>
<li>内容路由器，代理服务器可以作为“内容路由器”使用，根据因特网流量状况以及内容类型将请求导向特定的Web服务器。</li>
<li>转码器，可以修改内容的主体格式。在这些数据表示法之间进行的透明转换被称为转码。</li>
</ul>
<h2 id="代理是如何获取流量的？"><a href="#代理是如何获取流量的？" class="headerlink" title="代理是如何获取流量的？"></a>代理是如何获取流量的？</h2><ul>
<li>修改客户端，支持手工和自动的代理配置，将客户端的HTTP请求有意地发送给代理，而不是原始服务器。</li>
<li>修改网络，网络基础设施在客户端不知情的情况，对其进行拦截，这种代理称为“拦截代理”。</li>
<li>修改DNS的命名空间，放在Web服务器的代理服务器——替代物，假扮服务器的host和ip地址，所有的请求就会发送给替代物，通过编辑DNS名称列表。</li>
<li>修改Web服务器，通过HTTP重定向命令，将HTTP请求重定向到代理上去。</li>
</ul>
<p><img src="https://note.youdao.com/yws/api/personal/file/WEBe669168e6c40e032e8eebfb03fa00399?method=download&amp;shareKey=019b8fac2e513182bca57a96d8fefbbc" alt="代理是如何获取流量"></p>
<h2 id="客户端发给代理的URL与发给服务器的URL有什么不同？"><a href="#客户端发给代理的URL与发给服务器的URL有什么不同？" class="headerlink" title="客户端发给代理的URL与发给服务器的URL有什么不同？"></a>客户端发给代理的URL与发给服务器的URL有什么不同？</h2><ol>
<li>没有设置客户端使用代理时，它会发送部分URI</li>
<li>设置客户端使用代理时，它会发送完整URI</li>
</ol>
<h2 id="Web缓存有哪些好处？"><a href="#Web缓存有哪些好处？" class="headerlink" title="Web缓存有哪些好处？"></a>Web缓存有哪些好处？</h2><ul>
<li>缓存减少了冗余的数据传输，节省了你的网络费用。</li>
<li>缓存缓解了网络瓶颈的问题。不需要更多的带宽就能够更快地加载页面。</li>
<li>缓存降低了对原始服务器的要求。服务器可以更快地响应，避免过载的出现。</li>
<li>缓存降低了距离时延，因为从较远的地方加载页面会更慢一些。</li>
<li>缓存在解决瞬间拥塞时显得很重要，类似场景比如突发的新闻事件，大量的人几乎同时搜索一个事件，过多的流量峰值可能会造成Web服务器瞬间瘫痪。</li>
</ul>
<h2 id="缓存分为哪两种？"><a href="#缓存分为哪两种？" class="headerlink" title="缓存分为哪两种？"></a>缓存分为哪两种？</h2><ul>
<li>缓存命中，直接取缓存数据。</li>
<li>缓存未命中，需要从原始服务器获取数据。</li>
</ul>
<h2 id="缓存再验证是什么？"><a href="#缓存再验证是什么？" class="headerlink" title="缓存再验证是什么？"></a>缓存再验证是什么？</h2><p>原始服务器的内容可能会发生变化，缓存需要时不时对其进行检测，看看保存的副本是否仍然是服务器的最新副本。“新鲜度检测”被称为HTTP再验证。</p>
<p><img src="https://note.youdao.com/yws/api/personal/file/WEB3d4f91be96f1c4293b99bb891dfd783e?method=download&amp;shareKey=cc7737dd187bdc1c61d54d81d335a877" alt="缓存再验证"></p>
<p>缓存再验证时，这种方式确实比和原始服务器核对要慢，因为没有从服务器中获取数据，又比未命中情况要快。</p>
<h2 id="缓存的命中率一般是多少？"><a href="#缓存的命中率一般是多少？" class="headerlink" title="缓存的命中率一般是多少？"></a>缓存的命中率一般是多少？</h2><p>都希望缓存命中率越高越好，实际上对于现在中等规模的缓存来说，40%已经很不错了，能够显著地提升性能，减少流量了。</p>
<h2 id="if-modified-since失败会怎么样？"><a href="#if-modified-since失败会怎么样？" class="headerlink" title="if-modified-since失败会怎么样？"></a>if-modified-since失败会怎么样？</h2><p><img src="https://note.youdao.com/yws/api/personal/file/WEB18a92614cfebb53440fd75c7af210d1a?method=download&amp;shareKey=949295f354ec7d9af6f2a7f98f12acf6" alt="if-modified-since失败"></p>
<h2 id="网关有什么用？"><a href="#网关有什么用？" class="headerlink" title="网关有什么用？"></a>网关有什么用？</h2><p>网关可以作为某种翻译器使用，网关是资源和应用程序之间的粘合剂。</p>
<p><img src="https://note.youdao.com/yws/api/personal/file/WEB8998a6d50acb662be32a0c2b6dbd4ccb?method=download&amp;shareKey=1a834af067bc263ad9dc026c265a0674" alt=""></p>
<h2 id="为什么SSL需要搭载HTTP进行传输？"><a href="#为什么SSL需要搭载HTTP进行传输？" class="headerlink" title="为什么SSL需要搭载HTTP进行传输？"></a>为什么SSL需要搭载HTTP进行传输？</h2><p><img src="https://note.youdao.com/yws/api/personal/file/WEB6b10bdf7dc7589c88d9815ca57e2c65a?method=download&amp;shareKey=01d6de53e06328f1422e6550ed536df5" alt=""></p>
<h2 id="HTTP在发展中存在哪些问题？"><a href="#HTTP在发展中存在哪些问题？" class="headerlink" title="HTTP在发展中存在哪些问题？"></a>HTTP在发展中存在哪些问题？</h2><ul>
<li>复杂性，HTTP相当复杂，而且特性之间是相互依存的，比如处理连接管理，报文处理等等。</li>
<li>可扩展性，HTTP很难实现增式扩展。很多传下来的HTTP都没有自助的功能性扩展，使协议的扩展无法兼容。</li>
<li>有些部分效率不高，其中很多低效特性会随着高时延，低吞吐量的无线访问技术而变得更加严重。</li>
<li>传输依赖性，HTTP对于底层替换TCP/IP有很大的依赖性，想要替换底层的传输协议并没有什么很好的办法。</li>
</ul>

          
        
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2018/04/24/《Android优化专题》——优化电池续航能力/" itemprop="url">
                  《Android优化专题》——优化电池续航能力
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2018-04-24T17:18:56+08:00" content="2018-04-24">
              2018-04-24
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/Android优化专题/" itemprop="url" rel="index">
                    <span itemprop="name">Android优化专题</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
          

          

          
          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="《Android优化专题》——优化电池续航能力"><a href="#《Android优化专题》——优化电池续航能力" class="headerlink" title="《Android优化专题》——优化电池续航能力"></a>《Android优化专题》——优化电池续航能力</h1><h2 id="一、监测设备的电量和充电状态"><a href="#一、监测设备的电量和充电状态" class="headerlink" title="一、监测设备的电量和充电状态"></a>一、监测设备的电量和充电状态</h2><blockquote>
<p>在用户充电时，程序做任何操作都不会太受到电量影响，此时就适合做一些下载，刷新数据等耗电操作。</p>
</blockquote>
<h3 id="1-判断当前充电状态"><a href="#1-判断当前充电状态" class="headerlink" title="1. 判断当前充电状态"></a>1. 判断当前充电状态</h3><p>BatteryManager会广播Sticky intent，我们不需要注册BroadcastReiver，</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">IntentFilter ifilter = new IntentFilter(Intent.ACTION_BATTERY_CHANGED);</span><br><span class="line">Intent batteryStatus = context.registerReceiver(null, ifilter);</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">// Are we charging / charged?  </span><br><span class="line">int status = batteryStatus.getIntExtra(BatteryManager.EXTRA_STATUS, -1);</span><br><span class="line">boolean isCharging = status == BatteryManager.BATTERY_STATUS_CHARGING ||</span><br><span class="line">                     status == BatteryManager.BATTERY_STATUS_FULL;</span><br><span class="line"></span><br><span class="line">// How are we charging?  </span><br><span class="line">int chargePlug = battery.getIntExtra(BatteryManager.EXTRA_PLUGGED, -1);</span><br><span class="line">boolean usbCharge = chargePlug == BATTERY_PLUGGED_USB;</span><br><span class="line">boolean acCharge = chargePlug == BATTERY_PLUGGED_AC;</span><br></pre></td></tr></table></figure>
<p>通过判断设备此时是不是通过AC充电器，USB充电，不在充电状态三种情况来进行是否耗电操作，通常做法是，在使用AC充电时最大化后台更新操作，在使用USB充电时降低更新操作，不在充电状态时，最小化更新操作。</p>
<h3 id="2-监测充电状态的改变"><a href="#2-监测充电状态的改变" class="headerlink" title="2. 监测充电状态的改变"></a>2. 监测充电状态的改变</h3><p>充电状态随时改变，通过检查充电状态的改变，来改变App的某些行为。我们需要在Manifest文件里面注册一个监听来接收ACTION_POWER_CONNECTED and ACTION_POWER_DISCONNECTED的intent。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;receiver android:name=&quot;.PowerConnectionReceiver&quot;&gt;</span><br><span class="line">  &lt;intent-filter&gt;</span><br><span class="line">    &lt;action android:name=&quot;android.intent.action.ACTION_POWER_CONNECTED&quot;/&gt;</span><br><span class="line">    &lt;action android:name=&quot;android.intent.action.ACTION_POWER_DISCONNECTED&quot;/&gt;</span><br><span class="line">  &lt;/intent-filter&gt;</span><br><span class="line">&lt;/receiver&gt;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public class PowerConnectionReceiver extends BroadcastReceiver &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void onReceive(Context context, Intent intent) &#123;</span><br><span class="line">        int status = intent.getIntExtra(BatteryManager.EXTRA_STATUS, -1);</span><br><span class="line">        boolean isCharging = status == BatteryManager.BATTERY_STATUS_CHARGING ||</span><br><span class="line">                            status == BatteryManager.BATTERY_STATUS_FULL;</span><br><span class="line"></span><br><span class="line">        int chargePlug = intent.getIntExtra(BatteryManager.EXTRA_PLUGGED, -1);</span><br><span class="line">        boolean usbCharge = chargePlug == BATTERY_PLUGGED_USB;</span><br><span class="line">        boolean acCharge = chargePlug == BATTERY_PLUGGED_AC;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="3-判断当前电池电量"><a href="#3-判断当前电池电量" class="headerlink" title="3. 判断当前电池电量"></a>3. 判断当前电池电量</h3><p>对于一些情况，获取当前电量对于我们是否要进行某个级别的后台操作十分有意义。我们可以从获取电池状态的intent中提取电池电量和容量信息。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">int level = battery.getIntExtra(BatteryManager.EXTRA_LEVEL, -1);</span><br><span class="line">int scale = battery.getIntExtra(BatteryManager.EXTRA_SCALE, -1);</span><br><span class="line">float batteryPct = level / (float)scale;</span><br></pre></td></tr></table></figure>
<h3 id="4-检测电量的有效改变"><a href="#4-检测电量的有效改变" class="headerlink" title="4. 检测电量的有效改变"></a>4. 检测电量的有效改变</h3><p>检测电量的有效改变，包括电量进入低电量模式，充电后离开低电量模式，这两种状态的变更是值得我们关注的。我们仅仅需要监听ACTION_BATTERY_LOW与ACTION_BATTERY_OKAY.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;receiver android:name=&quot;.BatteryLevelReceiver&quot;&gt;</span><br><span class="line">&lt;intent-filter&gt;</span><br><span class="line">  &lt;action android:name=&quot;android.intent.action.ACTION_BATTERY_LOW&quot;/&gt;</span><br><span class="line">  &lt;action android:name=&quot;android.intent.action.ACTION_BATTERY_OKAY&quot;/&gt;</span><br><span class="line">  &lt;/intent-filter&gt;</span><br><span class="line">&lt;/receiver&gt;</span><br></pre></td></tr></table></figure>
<p>对于设备进入低电量模式我们要尤其注意，这个时候的任何更新、下载等操作是非常影响用户体验，尤其还有可能下载到一半设备就已经关机了。</p>
<h2 id="二、判断设备的停驻模式"><a href="#二、判断设备的停驻模式" class="headerlink" title="二、判断设备的停驻模式"></a>二、判断设备的停驻模式</h2><blockquote>
<p>Android设备有好几种停驻状态，为设备充电，包括车载模式，家庭模式，数字对战模拟模式。停驻状态与充电状态是非常密切相关联的。</p>
</blockquote>
<h3 id="1-判断当前停驻状态"><a href="#1-判断当前停驻状态" class="headerlink" title="1. 判断当前停驻状态"></a>1. 判断当前停驻状态</h3><p>停驻状态的广播内容是sticky intent，所以不需要注册广播</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">IntentFilter ifilter = new IntentFilter(Intent.ACTION_DOCK_EVENT);</span><br><span class="line">Intent dockStatus = context.registerReceiver(null, ifilter);</span><br><span class="line"></span><br><span class="line">int dockState = battery.getIntExtra(EXTRA_DOCK_STATE, -1);</span><br><span class="line">boolean isDocked = dockState != Intent.EXTRA_DOCK_STATE_UNDOCKED;</span><br></pre></td></tr></table></figure>
<h3 id="2-判断当前停驻类型"><a href="#2-判断当前停驻类型" class="headerlink" title="2. 判断当前停驻类型"></a>2. 判断当前停驻类型</h3><ul>
<li>Car</li>
<li>Desk</li>
<li>Low-End (Analog) Desk：API level 11开始才有</li>
<li>High-End (Digital) Desk：API level 11开始才有</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">boolean isCar = dockState == EXTRA_DOCK_STATE_CAR;</span><br><span class="line">boolean isDesk = dockState == EXTRA_DOCK_STATE_DESK ||</span><br><span class="line">                 dockState == EXTRA_DOCK_STATE_LE_DESK ||</span><br><span class="line">                 dockState == EXTRA_DOCK_STATE_HE_DESK;</span><br></pre></td></tr></table></figure>
<h3 id="3-监测停驻状态或者类型改变"><a href="#3-监测停驻状态或者类型改变" class="headerlink" title="3. 监测停驻状态或者类型改变"></a>3. 监测停驻状态或者类型改变</h3><p>只需要像下面一样注册监听器</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;action android:name=&quot;android.intent.action.ACTION_DOCK_EVENT&quot;/&gt;</span><br></pre></td></tr></table></figure>
<h2 id="三、判断并监测网络连接状态"><a href="#三、判断并监测网络连接状态" class="headerlink" title="三、判断并监测网络连接状态"></a>三、判断并监测网络连接状态</h2><blockquote>
<p>通过网络的连接状况改变，相应改变app的行为，减少无谓的操作，从而延长设备的续航能力。</p>
</blockquote>
<h3 id="1-判断当前是否有网络连接"><a href="#1-判断当前是否有网络连接" class="headerlink" title="1. 判断当前是否有网络连接"></a>1. 判断当前是否有网络连接</h3><p>检查是否有网络连接</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ConnectivityManager cm =</span><br><span class="line">        (ConnectivityManager)context.getSystemService(Context.CONNECTIVITY_SERVICE);</span><br><span class="line"></span><br><span class="line">NetworkInfo activeNetwork = cm.getActiveNetworkInfo();</span><br><span class="line">boolean isConnected = activeNetwork.isConnectedOrConnecting();</span><br></pre></td></tr></table></figure>
<h3 id="2-判断连接网络的类型"><a href="#2-判断连接网络的类型" class="headerlink" title="2. 判断连接网络的类型"></a>2. 判断连接网络的类型</h3><p>分为移动网络，WiMax，Wi-Fi，以太网等连接类型</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">boolean isWiFi = activeNetwork.getType() == ConnectivityManager.TYPE_WIFI;</span><br></pre></td></tr></table></figure>
<p>使用移动网络比WI-FI代价更大，多数情况下，移动网络下减少一些数据的获取操作，在有WIFI的情况下才开始。</p>
<h3 id="3-监测网络连接的切换"><a href="#3-监测网络连接的切换" class="headerlink" title="3. 监测网络连接的切换"></a>3. 监测网络连接的切换</h3><p>在manifest文件中注册一个带有action的Receiver</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;action android:name=&quot;android.net.conn.CONNECTIVITY_CHANGE&quot;/&gt;</span><br></pre></td></tr></table></figure>
<p>当然我们也没必要不间断地监听网络改变，我们只需要在完成某件任务时而进行监测即可。</p>
<h3 id="4-切换是否开启这些Receivers来提高效率"><a href="#4-切换是否开启这些Receivers来提高效率" class="headerlink" title="4. 切换是否开启这些Receivers来提高效率"></a>4. 切换是否开启这些Receivers来提高效率</h3><p>通过使用PackageManager来切换任何一个在mainfest定义好的组件开启状态，可以使用下面的方法来开启或者关闭任何一个broadcast receiver：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">ComponentName receiver = new ComponentName(context, myReceiver.class);</span><br><span class="line"></span><br><span class="line">PackageManager pm = context.getPackageManager();</span><br><span class="line"></span><br><span class="line">pm.setComponentEnabledSetting(receiver,</span><br><span class="line">        PackageManager.COMPONENT_ENABLED_STATE_ENABLED,</span><br><span class="line">        PackageManager.DONT_KILL_APP)</span><br></pre></td></tr></table></figure>
<p>如果判断到了网络连接已经断开，可以在这个时候关闭除了网络环境改变之外的所有Receivers</p>

          
        
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
  </section>

  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><span class="space">&hellip;</span><a class="page-number" href="/page/6/">6</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      

      <section class="site-overview sidebar-panel  sidebar-panel-active ">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="/images/avatar.jpg"
               alt="SkyAcer" />
          <p class="site-author-name" itemprop="name">SkyAcer</p>
          <p class="site-description motion-element" itemprop="description">Little And More.</p>
        </div>
        <nav class="site-state motion-element">
          <div class="site-state-item site-state-posts">
            <a href="/archives">
              <span class="site-state-item-count">30</span>
              <span class="site-state-item-name">日志</span>
            </a>
          </div>
          
          
            <div class="site-state-item site-state-categories">
              
                <span class="site-state-item-count">17</span>
                <span class="site-state-item-name">分类</span>
              
            </div>
          

          
            <div class="site-state-item site-state-tags">
              <a href="/tags">
                <span class="site-state-item-count">18</span>
                <span class="site-state-item-name">标签</span>
              </a>
            </div>
          

        </nav>

        

        <div class="links-of-author motion-element">
          
        </div>

        
        

        <div class="links-of-author motion-element">
          
        </div>

      </section>

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy; 
  <span itemprop="copyrightYear">2018</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">SkyAcer</span>
</div>

<div class="powered-by">
  由 <a class="theme-link" href="http://hexo.io">Hexo</a> 强力驱动
</div>

<div class="theme-info">
  主题 -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Pisces
  </a>
</div>



      </div>
    </footer>

    <div class="back-to-top">
      <i class="fa fa-arrow-up"></i>
    </div>
  </div>

  


  




<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>


  <script type="text/javascript" src="/vendors/jquery/index.js?v=2.1.3"></script>

  <script type="text/javascript" src="/vendors/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  <script type="text/javascript" src="/vendors/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  <script type="text/javascript" src="/vendors/velocity/velocity.min.js"></script>

  <script type="text/javascript" src="/vendors/velocity/velocity.ui.min.js"></script>

  <script type="text/javascript" src="/vendors/fancybox/source/jquery.fancybox.pack.js"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=0.5.0"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=0.5.0"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=0.5.0"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=0.5.0"></script>



  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=0.5.0"></script>



  



  



  
  
  

  


</body>
</html>
