<!doctype html>



  


<html class="theme-next pisces use-motion">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>



<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />












  <link href="/vendors/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css"/>




  <link href="//fonts.googleapis.com/css?family=Lato:300,400,700,400italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">



<link href="/vendors/font-awesome/css/font-awesome.min.css?v=4.4.0" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=0.5.0" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="Hexo, NexT" />








  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=0.5.0" />






<meta name="description" content="Little And More.">
<meta property="og:type" content="website">
<meta property="og:title" content="SkyAcer&#39;s blog">
<meta property="og:url" content="http://skyacer.github.io/page/2/index.html">
<meta property="og:site_name" content="SkyAcer&#39;s blog">
<meta property="og:description" content="Little And More.">
<meta property="og:locale" content="zh-Hans">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="SkyAcer&#39;s blog">
<meta name="twitter:description" content="Little And More.">



<script type="text/javascript" id="hexo.configuration">
  var NexT = window.NexT || {};
  var CONFIG = {
    scheme: 'Pisces',
    sidebar: {"position":"left","display":"post"},
    fancybox: true,
    motion: true,
    duoshuo: {
      userId: 0,
      author: '博主'
    }
  };
</script>

  <title> SkyAcer's blog </title>
</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  








  
  
    
  

  <div class="container one-collumn sidebar-position-left 
   page-home 
 ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-meta ">
  

  <div class="custom-logo-site-title">
    <a href="/"  class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <span class="site-title">SkyAcer's blog</span>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>
  <p class="site-subtitle">Hacking,Thoughts.</p>
</div>

<div class="site-nav-toggle">
  <button>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
  </button>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-home fa-fw"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            
              <i class="menu-item-icon fa fa-archive fa-fw"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags" rel="section">
            
              <i class="menu-item-icon fa fa-tags fa-fw"></i> <br />
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-commonweal">
          <a href="/404.html" rel="section">
            
              <i class="menu-item-icon fa fa-heartbeat fa-fw"></i> <br />
            
            公益404
          </a>
        </li>
      

      
    </ul>
  

  
</nav>

 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2018/04/12/JVM内存模型/" itemprop="url">
                  JVM内存模型
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2018-04-12T14:49:40+08:00" content="2018-04-12">
              2018-04-12
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/JVM/" itemprop="url" rel="index">
                    <span itemprop="name">JVM</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
          

          

          
          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="JVM内存模型"><a href="#JVM内存模型" class="headerlink" title="JVM内存模型"></a>JVM内存模型</h1><h2 id="简单来说JVM内存模型是什么样的？"><a href="#简单来说JVM内存模型是什么样的？" class="headerlink" title="简单来说JVM内存模型是什么样的？"></a>简单来说JVM内存模型是什么样的？</h2><p><img src="https://note.youdao.com/yws/api/personal/file/WEB9b72e7ca84813b9d70d9e53b2337545f?method=download&amp;shareKey=c659a9b8ad449a74d3a92fd212f495e9" alt=""></p>
<h3 id="线程私有区："><a href="#线程私有区：" class="headerlink" title="线程私有区："></a>线程私有区：</h3><ul>
<li>程序计数器，记录正在执行的虚拟机字节码的地址；</li>
<li>虚拟机栈，方法执行的内存区，每个方法执行时在虚拟机栈中创建栈帧；</li>
<li>本地方法栈，虚拟机的Native方法执行的内存区；</li>
</ul>
<h3 id="线程共享区："><a href="#线程共享区：" class="headerlink" title="线程共享区："></a>线程共享区：</h3><ul>
<li>Java堆：对象分配内存的区域；</li>
<li>方法区：存放类信息、常量、静态变量、编译器编译后的代码等数据；<ul>
<li>常量池：存放编译器生成的字面量和符号引用，是方法区的一部分。 </li>
</ul>
</li>
</ul>
<h3 id="通常所说的Java堆和Java栈是指什么？"><a href="#通常所说的Java堆和Java栈是指什么？" class="headerlink" title="通常所说的Java堆和Java栈是指什么？"></a>通常所说的Java堆和Java栈是指什么？</h3><p>通常所说的Java堆指的是共享数据区的堆，Java栈指的是线程私有的虚拟机栈。</p>
<h2 id="JVM中更详细的内存模型是什么样的？"><a href="#JVM中更详细的内存模型是什么样的？" class="headerlink" title="JVM中更详细的内存模型是什么样的？"></a>JVM中更详细的内存模型是什么样的？</h2><p><img src="https://note.youdao.com/yws/api/personal/file/WEB73bae4dd3b8c5e8b481d92d6cb8a07d5?method=download&amp;shareKey=d9f8bfec8cb4b4af1862d0a6e86bdeea" alt="JVM更详细的内存模型"></p>
<h3 id="程序计数器"><a href="#程序计数器" class="headerlink" title="程序计数器"></a>程序计数器</h3><ol>
<li>每个线程都有计数器，是私有内存空间，该区域是整个内存中较小的一块。</li>
<li>当线程正在执行一个Java方法时，PC计数器记录的是正在执行的虚拟机字节码的地址。</li>
<li>当线程正在执行Native方法时，PC计数器则为空</li>
</ol>
<h3 id="虚拟机栈"><a href="#虚拟机栈" class="headerlink" title="虚拟机栈"></a>虚拟机栈</h3><blockquote>
<p>栈祯是用于支持虚拟机进行方法执行的数据结构，是属性运行时数据区的虚拟机的栈元素。</p>
</blockquote>
<ol>
<li>局部变量表，一组变量存储空间，容量以slot为最小单位。</li>
<li>操作栈（stack大小，编译器确定），操作栈元素的数据必须与字节码指令序列严格匹配。</li>
<li>动态连接，指向运行时常量池中该栈所属方法的引用，为了动态连接使用。<ul>
<li>前面的解析过程是静态解析</li>
<li>对于运行期转化为直接引用，动态解析。</li>
</ul>
</li>
<li>方法返回地址<ul>
<li>正常退出，执行引擎遇到方法返回的字节码，将返回值传递给调用者。</li>
<li>异常退出，遇到Exception，并且方法未捕获异常，不会有任何返回值。</li>
</ul>
</li>
<li>额外附加信息，由具体虚拟机实现。</li>
</ol>
<p><strong>异常（Exception）</strong></p>
<ul>
<li>StackOverFlowError：当线程请求栈深度超出虚拟机栈允许深度时抛出</li>
<li>OutOfMemoryError：当Java虚拟机动态扩展到无法申请足够内存时抛出</li>
</ul>
<h3 id="本地方法栈"><a href="#本地方法栈" class="headerlink" title="本地方法栈"></a>本地方法栈</h3><p>本地方法栈为虚拟机使用到的Native方法提供内存空间，而虚拟机栈则为Java方法提供内存空间。</p>
<h3 id="Java堆"><a href="#Java堆" class="headerlink" title="Java堆"></a>Java堆</h3><p>Java堆是虚拟机管理的最大一块内存，也是GC的主战场，存放的是几乎所有的对象实例和数组数据。</p>
<ul>
<li>从内存回收角度，Java堆被分为新生代和老年代；为了更快地回收内存。</li>
<li>从内存分配角度，Java堆可以划分出线程私有的分配缓冲区（Thread Local Allocation Buffer,TLAB），为了更快地分配内存。</li>
</ul>
<h3 id="对象实例结构是什么样的？"><a href="#对象实例结构是什么样的？" class="headerlink" title="对象实例结构是什么样的？"></a>对象实例结构是什么样的？</h3><p><img src="https://note.youdao.com/yws/api/personal/file/WEBe2af8709014a9b7dc3005005fda1ea82?method=download&amp;shareKey=14e5e6c91dc5864b718ec8d95003351e" alt="对象实例结构"></p>
<p>填充数据不一定存在，是为了字节对齐而存在的</p>
<p>此区域可以抛出OOM Error异常</p>
<h3 id="方法区"><a href="#方法区" class="headerlink" title="方法区"></a>方法区</h3><p>主要存放被虚拟机加载的类信息、常量、静态变量、编译器编译后的代码数据。</p>
<p>此区域可以抛出OOM Error异常</p>
<h3 id="运行时常量池"><a href="#运行时常量池" class="headerlink" title="运行时常量池"></a>运行时常量池</h3><p>属于方法区的一部分，用于存放编译器生成的各种字面量和符号引用。运行时常量池除了编译器产生的Class文件的常量池，还可以在运行期，将新的常量加入常量池，比如String的intern()方法。</p>
<ul>
<li>字面量：与Java语言层面的常量概念相近，包含文本字符串，声明为final的常量值等等。</li>
<li>符号引用：<ul>
<li>类和接口的全限定名</li>
<li>字段的名称和描述符</li>
<li>方法的名称和描述符 </li>
</ul>
</li>
</ul>
<p>此区域<strong>不会</strong>抛出OOM Error异常</p>

          
        
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2018/04/11/Android窗口管理分析（一）——View是如何绘制到屏幕上的/" itemprop="url">
                  Android窗口管理分析（一）——View是如何绘制到屏幕上的
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2018-04-11T15:42:02+08:00" content="2018-04-11">
              2018-04-11
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/framework/" itemprop="url" rel="index">
                    <span itemprop="name">framework</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
          

          

          
          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="Android窗口管理分析（一）——View是如何绘制到屏幕上的"><a href="#Android窗口管理分析（一）——View是如何绘制到屏幕上的" class="headerlink" title="Android窗口管理分析（一）——View是如何绘制到屏幕上的"></a>Android窗口管理分析（一）——View是如何绘制到屏幕上的</h1><blockquote>
<p>窗口管理涉及到的模块很多，除了WindowManagerService还包括SurfaceFlinger服务、Linux的共享内存及tmpfs文件系统、Binder通信、InputManagerService、VSYNC同步技术等。</p>
</blockquote>
<h2 id="View的窗口管理分为哪些部分？"><a href="#View的窗口管理分为哪些部分？" class="headerlink" title="View的窗口管理分为哪些部分？"></a>View的窗口管理分为哪些部分？</h2><p><img src="https://note.youdao.com/yws/api/personal/file/WEBdb44b5849365c6f181d3c424dc60e1ab?method=download&amp;shareKey=30075989c77b1a06262ff679ef2ed252" alt="窗口管理"></p>
<h2 id="WMS是负责View绘制的吗？"><a href="#WMS是负责View绘制的吗？" class="headerlink" title="WMS是负责View绘制的吗？"></a>WMS是负责View绘制的吗？</h2><p><strong>WMS的作用是窗口管理，不负责View的绘制，真正完成图像绘制的是SurfaceFlinger服务</strong></p>
<p>WMS（WindowManagerService）是负责Android的窗口的管理，比如窗口的添加、移除、调整顺序等等。至于图像的绘制和合成都不是WMS管理的范畴。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">TextView mview=new TextView(context);</span><br><span class="line">    ...&lt;!--设置颜色 样式--&gt;</span><br><span class="line">    WindowManager mWindowManager = (WindowManager) getSystemService(Context.WINDOW_SERVICE);</span><br><span class="line">    WindowManager.LayoutParams wmParams = new WindowManager.LayoutParams();</span><br><span class="line">    wmParams.type = WindowManager.LayoutParams.TYPE_TOAST;</span><br><span class="line">    wmParams.format = PixelFormat.RGBA_8888;</span><br><span class="line">    wmParams.width = 800;</span><br><span class="line">    wmParams.height = 800;</span><br><span class="line">    mWindowManager.addView(mview, wmParams);</span><br></pre></td></tr></table></figure>
<ol>
<li>在利用WindowManager.addView添加窗口之前，TextView的onDraw不会被调用，也就是说View必须被添加到窗口中，才会被绘制。换句话说，<strong>只有申请了依附窗口，View才会有可以绘制的目标内存。</strong></li>
<li>在添加窗口的时候，除了WMS自己进行注册整理，还需要向SurfaceFlinger服务申请一块Surface画布，对应的是一块内存。</li>
<li>只有这块内存申请成功之后，APP才会有绘画的目标，这块内存是APP和SurfaceFlinger服务端共享的，省去了绘图资源的拷贝。</li>
</ol>
<p><img src="https://note.youdao.com/yws/api/personal/file/WEB552342f685a75dfac6192a6898c70c21?method=download&amp;shareKey=9b0c041e0aa0a537614211820967f4ce" alt="Android绘图原理"></p>
<p><strong>可以看到App通过unLockCanvasAndPost直接和SurfaceFlinger通信进行重绘的。WMS只负责窗口的管理，不负责绘制。</strong></p>
<h2 id="窗口分组是什么样的？"><a href="#窗口分组是什么样的？" class="headerlink" title="窗口分组是什么样的？"></a>窗口分组是什么样的？</h2><p>Android中的窗口主要分为三种：</p>
<ol>
<li>系统窗口——Toast</li>
<li>应用窗口——Dialog、Activity。不过Dialog必须依附Activity才能存在</li>
<li>子窗口——PopupWindow，必须依附其他窗口，依附的窗口只能是1，2而不能是3</li>
</ol>
<p><img src="https://note.youdao.com/yws/api/personal/file/WEB98371b5048dfa8b7fe0142093823d404?method=download&amp;shareKey=fba43e8d94e0d2b4d30cb2f10704f573" alt="窗口组织形式"></p>
<p>WMS不仅只是管理窗口，还负责窗口动画，Touch事件等等。</p>
<h2 id="View绘制的内存分配是什么机制？"><a href="#View绘制的内存分配是什么机制？" class="headerlink" title="View绘制的内存分配是什么机制？"></a>View绘制的内存分配是什么机制？</h2><p>每个Activity看做一个图层，对应一块Surface，Surface绘图表面对应的内存是SurfaceFlinger申请的，内存是APP与SurfaceFlinger间进程共享的，所以APP和SurfaceFlinger的通信基于<strong>共享内存</strong>实现的。</p>
<h2 id="共享内存的具体实现是什么样的？"><a href="#共享内存的具体实现是什么样的？" class="headerlink" title="共享内存的具体实现是什么样的？"></a>共享内存的具体实现是什么样的？</h2><p>共享内存是基于MAP+tmpfs文件系统实现，可以理解为SF为APP申请一块内存，然后通过binder将内存相关的信息传递给APP，APP端在这块内存中绘制内容，绘制完毕后通知SF图层混排，再由SF将数据渲染到屏幕上，这么做的目的主要考虑图像内存比较大，用socket,binder方式传递效率上无法满足要求。</p>
<p><img src="https://note.youdao.com/yws/api/personal/file/WEBe00aaff15eaf1ac892950c9e4c6fd4b4?method=download&amp;shareKey=e57fbd76b670782fb8bb85869ec2d0d3" alt="共享内存具体实现"></p>
<ol>
<li>SurfaceFlinger服务属于系统服务，主要用于将APP绘制完毕的数据渲染到屏幕上。</li>
<li>各应用的View的绘制都需要经过SurfaceFlinger服务。</li>
<li>WindowManagerService：WMS控制Surface画布的添加和次序，动画还有触摸事件。</li>
<li>每个App进程负责相应图层的绘制。</li>
<li>App与SurfaceFlinger通信是通过匿名内存来实现的。</li>
</ol>

          
        
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2018/04/04/HTTP浅析（一）HTTP报文/" itemprop="url">
                  HTTP解析（一）HTTP报文
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2018-04-04T17:27:32+08:00" content="2018-04-04">
              2018-04-04
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/基础知识/" itemprop="url" rel="index">
                    <span itemprop="name">基础知识</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
          

          

          
          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="HTTP浅析（一）HTTP报文"><a href="#HTTP浅析（一）HTTP报文" class="headerlink" title="HTTP浅析（一）HTTP报文"></a>HTTP浅析（一）HTTP报文</h1><p><img src="https://note.youdao.com/yws/api/personal/file/WEB0dbed166d932eb00e22bccb5438230eb?method=download&amp;shareKey=a5ed5c1fbdc8496b9839ba3fe967c133" alt="HTTP报文"></p>
<ol>
<li>起始行</li>
<li>首部</li>
<li>主体（非必须）</li>
</ol>
<h3 id="结构图"><a href="#结构图" class="headerlink" title="结构图"></a>结构图</h3><p><img src="https://note.youdao.com/yws/api/personal/file/WEB6daa85ab664df6f242e6a0ab5c031aad?method=download&amp;shareKey=b82f6a53c791a919eec21bb7e03b778f" alt="HTTP报文结构图"></p>
<h2 id="连接管理"><a href="#连接管理" class="headerlink" title="连接管理"></a>连接管理</h2><h3 id="从浏览器键入地址到连接结束的过程是什么？"><a href="#从浏览器键入地址到连接结束的过程是什么？" class="headerlink" title="从浏览器键入地址到连接结束的过程是什么？"></a>从浏览器键入地址到连接结束的过程是什么？</h3><p><img src="https://note.youdao.com/yws/api/personal/file/WEB2e66135edc8807da9a26b82c7f6fe49b?method=download&amp;shareKey=5d42e46fb1f35a721f6700404182fe78" alt="连接过程"></p>
<p>TCP为HTTP提供一条可靠的比特传输管道，从TCP连接一端填入的字节会从另一端以原有的顺序、正确地传送出来。</p>
<h3 id="HTTP和HTTPS的区别？"><a href="#HTTP和HTTPS的区别？" class="headerlink" title="HTTP和HTTPS的区别？"></a>HTTP和HTTPS的区别？</h3><p><img src="https://note.youdao.com/yws/api/personal/file/WEB014ec3806a6ade023937cf16362f8e2b?method=download&amp;shareKey=ca78563f5a64ea7de698304d2d9c723b" alt=""></p>
<h3 id="TCP连接持续不断地进行"><a href="#TCP连接持续不断地进行" class="headerlink" title="TCP连接持续不断地进行"></a>TCP连接持续不断地进行</h3><p>TCP连接根据四个值来识别</p>
<ol>
<li>源IP地址</li>
<li>源端口号</li>
<li>目的IP地址</li>
<li>目的端口号</li>
</ol>
<p>这四个值唯一确定了一条连接，任意一条不相同的连接必然这四个值不会完全相同。</p>
<h3 id="TCP结构是什么？"><a href="#TCP结构是什么？" class="headerlink" title="TCP结构是什么？"></a>TCP结构是什么？</h3><p><img src="https://note.youdao.com/yws/api/personal/file/WEB8979962c8f98c373c80f33dc1f6677f9?method=download&amp;shareKey=2015d94639e71cf59dd0f696da882912" alt="TCP结构图"></p>
<h3 id="如何用Socket实现HTTP事务？"><a href="#如何用Socket实现HTTP事务？" class="headerlink" title="如何用Socket实现HTTP事务？"></a>如何用Socket实现HTTP事务？</h3><p><img src="https://note.youdao.com/yws/api/personal/file/WEB3c1d56f9ec210ee4b1c20bcb9ad638af?method=download&amp;shareKey=8ee5d2c611ab91d812316957645e29df" alt="如何用Socket实现HTTP事务"></p>
<h3 id="TCP客户端和服务器如何通过Socket通信？"><a href="#TCP客户端和服务器如何通过Socket通信？" class="headerlink" title="TCP客户端和服务器如何通过Socket通信？"></a>TCP客户端和服务器如何通过Socket通信？</h3><p><img src="https://note.youdao.com/yws/api/personal/file/WEB3c1d56f9ec210ee4b1c20bcb9ad638af?method=download&amp;shareKey=8ee5d2c611ab91d812316957645e29df" alt="通过Socket通信"></p>
<h3 id="HTTP事务的时延有哪些原因？"><a href="#HTTP事务的时延有哪些原因？" class="headerlink" title="HTTP事务的时延有哪些原因？"></a>HTTP事务的时延有哪些原因？</h3><p>由于和建立TCP连接相比，事务处理时间是很短的，除非在处理很复杂的动态资源，否则HTTP的时延就是由TCP网络时延导致的。</p>
<ol>
<li>如果最近没有对URI中的主机名访问，通过DNS解析系统要转换IP需要花费数十秒。</li>
<li>TCP每次连接都需要三次握手，这个值最多一两秒，但是连接多的话会累加上去（非HTTP2.0的情况）</li>
<li>一旦连接建立，读取请求报文，传输请求报文，处理请求报文都需要时间。</li>
<li>回送HTTP相应也需要时间。</li>
</ol>
<h3 id="我们应该从哪些方面来提升TCP的性能？"><a href="#我们应该从哪些方面来提升TCP的性能？" class="headerlink" title="我们应该从哪些方面来提升TCP的性能？"></a>我们应该从哪些方面来提升TCP的性能？</h3><ol>
<li>TCP连接建立握手</li>
<li>TCP慢启动拥塞控制</li>
<li>数据聚集的Nagle算法</li>
<li>用于捎带确认的TCP延迟确认算法</li>
<li>TIME_WAIT时延和端口耗尽</li>
</ol>
<h3 id="什么是TCP的延迟确认机制？"><a href="#什么是TCP的延迟确认机制？" class="headerlink" title="什么是TCP的延迟确认机制？"></a>什么是TCP的延迟确认机制？</h3><p>由于因特网无法确保可靠的分组传输（因特网路由器超负荷的话，可以随意丢弃分组，所以TCP实现了自己的确认机制来确保数据的成功传输）</p>
<p><img src="https://note.youdao.com/yws/api/personal/file/WEB661a339d12a31ad81a5ba68c79fb6b34?method=download&amp;shareKey=70f21e7cbb55c0ed891869e621837eb4" alt="TCP延迟确认"></p>
<h3 id="什么是TCP慢启动？"><a href="#什么是TCP慢启动？" class="headerlink" title="什么是TCP慢启动？"></a>什么是TCP慢启动？</h3><p>TCP面对大量的数据，不会一次性将所有分组都发出去，TCP会随着时间进行自我“调谐”，起初会限制连接的最大速度。如果成功则会逐渐加大传输速度，简单来说：</p>
<p>发送一个分组 -&gt; 确认发送成功 -&gt; 具备一次性发送两个分组的权限 -&gt; 发送两个分组 -&gt; 以此类推</p>
<h3 id="什么是Nagle算法和TCP-NODELAY？"><a href="#什么是Nagle算法和TCP-NODELAY？" class="headerlink" title="什么是Nagle算法和TCP_NODELAY？"></a>什么是Nagle算法和TCP_NODELAY？</h3><p>由于每个TCP段都会有40个字节的标记和首部无法省略，所以在发送频繁的小数据请求时，这40个多余的字节带来的性能问题就会变得严重。</p>
<p>Nagle算法试图在发送一个分组前，将大量的TCP数据绑定在一起，以提高网络效率。</p>
<p>仅适合频繁的小数据请求</p>
<p>缺点：可能会因为无法填满一个分组，导致一直等待永远不会到来的数据而产生延迟</p>
<h3 id="什么是TIME-WAIT累积与端口耗尽？"><a href="#什么是TIME-WAIT累积与端口耗尽？" class="headerlink" title="什么是TIME_WAIT累积与端口耗尽？"></a>什么是TIME_WAIT累积与端口耗尽？</h3><p>在TCP关闭后，在内存中会维持一个小的控制块，用来记录最近这个关闭的IP地址和端口号，通常会存在一段时间，通常是所顾忌的最大分段试用期的两倍（2MSL,通常为两分钟），确保分组被复制且插入了具有相同连接值（源/目的IP地址和端口号），这样会破坏TCP数据。</p>
<p><img src="https://note.youdao.com/yws/api/personal/file/WEBb568c12c17e19e314530750afc6690e9?method=download&amp;shareKey=ca31faf73759d96177949f489e139282" alt="TIME_WAIT"></p>
<p>但是这种情况下有可能产生问题，原因是因为可用端口数是有限的，也就是假如可用端口是60000个，那么如果2MSL两分钟，则连接率不能高于 60000 / 120 = 500个/秒。</p>
<p>另外要注意大量打开连接或控制块的情况下，有些操作系统的速度会严重减缓。</p>
<h3 id="从哪些方面来提升HTTP性能？"><a href="#从哪些方面来提升HTTP性能？" class="headerlink" title="从哪些方面来提升HTTP性能？"></a>从哪些方面来提升HTTP性能？</h3><ul>
<li>并行连接</li>
<li>持久连接</li>
<li>管道化连接</li>
<li>复用连接</li>
</ul>
<h3 id="并行连接有什么优点和限制？"><a href="#并行连接有什么优点和限制？" class="headerlink" title="并行连接有什么优点和限制？"></a>并行连接有什么优点和限制？</h3><p><strong>并行连接不一定更快，但会让人“感觉上”更快</strong>，因为如果客户端的网络带宽较小时，大部分的时间其实是用来传输数据的，，如果此时一个连接就足以把带宽占满反倒并行连接会消耗很多内存资源，在效率上也没有什么提升，得不偿失。</p>
<p>一般浏览器把并行连接数限定在较小的值，通常是4个。</p>
<h3 id="持久连接是什么？与并行连接相比有什么好处？"><a href="#持久连接是什么？与并行连接相比有什么好处？" class="headerlink" title="持久连接是什么？与并行连接相比有什么好处？"></a>持久连接是什么？与并行连接相比有什么好处？</h3><p>在HTTP/1.1协议中，支持HTTP设备在事物处理结束之后将TCP保持打开状态，以便之后的复用。</p>
<p>好处是既可以避免缓慢的连接建立，也就是三次握手阶段，还可以避免慢启动的拥塞适应阶段，以便更快速地进行数据传输。</p>
<h3 id="Keep-Alive首部在哑代理中会出现什么问题？"><a href="#Keep-Alive首部在哑代理中会出现什么问题？" class="headerlink" title="Keep-Alive首部在哑代理中会出现什么问题？"></a>Keep-Alive首部在哑代理中会出现什么问题？</h3><p><strong>会出现仅有第一个请求有效，其余请求都被代理忽略，从而导致客户端一直loading而得不到返回结果。</strong></p>
<p>原因如下：</p>
<p><img src="https://note.youdao.com/yws/api/personal/file/WEBcbe56b9b9f29b37c71cd540e81ad8125?method=download&amp;shareKey=b8b0d5fb2b422811f9cb17743b6de858" alt="Keep-Alive"></p>
<p>主要原因就是逐跳首部被哑代理当成了端到端首部进行传输。</p>
<h3 id="什么是端到端首部？什么是逐跳首部？"><a href="#什么是端到端首部？什么是逐跳首部？" class="headerlink" title="什么是端到端首部？什么是逐跳首部？"></a>什么是端到端首部？什么是逐跳首部？</h3><ul>
<li><p>端到端首部（End-to-end Header）分在此类别中的首部会转发给请求/响应对应的最终接受目标，且必须保存在由缓存生成的响应中，另外规定它必须被转发。</p>
</li>
<li><p>逐跳首部（Hop-by-hop Header）分在此类别中的首部只对单次转发有效，会因通过缓存或代理而不再转发。所有的Connection首部都是不能被转发的，例如Connection/Keep-Alive/Proxy-Authenticate/Proxy-Authorization/Trailer/TE/Transfer-Encoding/Upgrade</p>
</li>
</ul>
<h3 id="有什么办法可以解决Keep-Alive在哑代理的问题？"><a href="#有什么办法可以解决Keep-Alive在哑代理的问题？" class="headerlink" title="有什么办法可以解决Keep-Alive在哑代理的问题？"></a>有什么办法可以解决Keep-Alive在哑代理的问题？</h3><p>Netscape通过将Connection:Keep-Alive改成Proxy-Connectoion:Keep-Alive进行传输。由于Proxy-Connectoion:Keep-Alive是自定义的，服务器并不知道是什么意思，如果哑代理传输过去后，服务器当做普通连接进行处理，就不会出现代理收不到接下来的请求的问题了。</p>
<p><img src="https://note.youdao.com/yws/api/personal/file/WEB3eadd942432552d68e7b7f188a514ad9?method=download&amp;shareKey=bfe5f398f69e5eae8c2d59064b94fb7f" alt="哑代理聪明代理解决方式"></p>
<p>但这个方法只能在中间没有出现哑代理和聪明的代理结合的情况下才有效。</p>
<p><img src="https://note.youdao.com/yws/api/personal/file/WEB7c17e8f0d3cb9917d30b5a68cad0125c?method=download&amp;shareKey=7c2c1e2db3ebf9b5c6ac6c775c339644" alt="哑代理聪明代理混合"></p>
<h3 id="持久连接和keep-alive有什么不同？"><a href="#持久连接和keep-alive有什么不同？" class="headerlink" title="持久连接和keep-alive有什么不同？"></a>持久连接和keep-alive有什么不同？</h3><p>keep-alive是HTTP/1.0+加入的首部字段，而持久连接是在HTTP/1.1就默认支持的，如果要在事务结束后关闭，就需要在报文里添加Connection:close首部。</p>
<h3 id="持久连接和管道化连接有什么不同？"><a href="#持久连接和管道化连接有什么不同？" class="headerlink" title="持久连接和管道化连接有什么不同？"></a>持久连接和管道化连接有什么不同？</h3><p>管道连接是在持久连接上，相对于keep-alive的又一个性能优化，在响应到达之前，可以将多条请求加入队列。当第一条请求通过网络流向服务器时，第二条和第三条请求也可以开始发送了。</p>
<p>具体区别：</p>
<p><img src="https://note.youdao.com/yws/api/personal/file/WEBa087747b00a36815c73c788e573cd5ac?method=download&amp;shareKey=d8117a777bea2780f75692d9b314cf78" alt="三种连接的区别"></p>
<h3 id="什么是幂等事物，什么是非幂等事物？"><a href="#什么是幂等事物，什么是非幂等事物？" class="headerlink" title="什么是幂等事物，什么是非幂等事物？"></a>什么是幂等事物，什么是非幂等事物？</h3><p>如果一个事物，不管执行一次还是执行多次，得到的结果都是相同的，那么这个事物就是幂等的。比如：GET、HEAD、PUT、DELETE、TRACE和OPTIONS方法。</p>
<p>反之，非幂等事物的请求（比如POST），这种事物就不应该以管道化的方式传送非幂等请求，要发送一条非幂等请求，就需要等待来自前一条请求的响应状态。</p>
<h3 id="怎么样的连接是正常关闭的？"><a href="#怎么样的连接是正常关闭的？" class="headerlink" title="怎么样的连接是正常关闭的？"></a>怎么样的连接是正常关闭的？</h3><h4 id="完全关闭与半关闭有什么区别？"><a href="#完全关闭与半关闭有什么区别？" class="headerlink" title="完全关闭与半关闭有什么区别？"></a>完全关闭与半关闭有什么区别？</h4><ol>
<li>应用程序关闭TCP输入和输出信道中的任意一个，只有两者都关闭了，socket才会调用close()将TCP连接的输入和输出信道都关闭，此时才是完全关闭。</li>
<li>当socket调用shutdown()时，此时会单独关闭输入/输出信道，被称为“半关闭”。</li>
</ol>
<h4 id="半关闭状态，哪种情况更加危险？"><a href="#半关闭状态，哪种情况更加危险？" class="headerlink" title="半关闭状态，哪种情况更加危险？"></a>半关闭状态，哪种情况更加危险？</h4><p>关闭连接的输出信道是安全的，因为连接另一端的对等实体会从其缓冲区中读取所有数据之后收到一条通知，说明流结束了，这样你就知道将连接关闭了。</p>
<p>而关闭连接的输入信道是危险的，大部分操作系统会对这种情况视为很严重的错误来处理，比如：假设你在一条持久连接发送了10条管道式请求，此时数据还在应用缓冲区存着，此时第11条请求，服务器将连接关闭，而这条请求会发送到已经关闭的连接上去，并且会回送一条重置的信息，之前缓冲数据都会丢失。</p>
<p><img src="https://note.youdao.com/yws/api/personal/file/WEBd2aeddd8bc5679ee1b39df879772498b?method=download&amp;shareKey=3584790325996d4033aa39969b56de73" alt="输入输出信道"></p>
<h4 id="那么正确关闭HTTP请求连接顺序是什么样的？"><a href="#那么正确关闭HTTP请求连接顺序是什么样的？" class="headerlink" title="那么正确关闭HTTP请求连接顺序是什么样的？"></a>那么正确关闭HTTP请求连接顺序是什么样的？</h4><p>正常关闭的应用程序首先应该关闭输出信道，然后等待连接另一端的实体关闭输入信道。</p>

          
        
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2018/03/30/看你用过AIDL，来回答一下下面的问题/" itemprop="url">
                  看你用过AIDL，来回答一下下面的问题
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2018-03-30T10:34:35+08:00" content="2018-03-30">
              2018-03-30
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/用法/" itemprop="url" rel="index">
                    <span itemprop="name">用法</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
          

          

          
          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="听说你用过AIDL，来回答一下下面的问题"><a href="#听说你用过AIDL，来回答一下下面的问题" class="headerlink" title="听说你用过AIDL，来回答一下下面的问题"></a>听说你用过AIDL，来回答一下下面的问题</h1><h2 id="远程服务和本地服务有什么区别？"><a href="#远程服务和本地服务有什么区别？" class="headerlink" title="远程服务和本地服务有什么区别？"></a>远程服务和本地服务有什么区别？</h2><p>远程Service与调用者不在同一个进程里（即远程Service是运行在另外一个进程）；而本地服务则是与调用者运行在同一个进程里.</p>
<p><img src="https://note.youdao.com/yws/api/personal/file/WEBb04a338cd8535d591dac72913f58fe0b?method=download&amp;shareKey=cfc7cfa45ca7da191b07815906f883da" alt="本地服务和远程服务的区别"></p>
<h2 id="与Binder和AIDL相关的类有哪些？"><a href="#与Binder和AIDL相关的类有哪些？" class="headerlink" title="与Binder和AIDL相关的类有哪些？"></a>与Binder和AIDL相关的类有哪些？</h2><p><img src="https://note.youdao.com/yws/api/personal/file/WEBacec11f703dd60b08468fa217fa61837?method=download&amp;shareKey=174b58f6c56f45b5b13f7bc642c11ade" alt=""></p>
<p>AIDL生成的是IMyService接口，stub和proxy都实现了IMyService。</p>
<h2 id="IInterface是什么？"><a href="#IInterface是什么？" class="headerlink" title="IInterface是什么？"></a>IInterface是什么？</h2><p>IInterface是一个用于表达Service提供的功能的一个契约，也就是说IInterface里有的方法，Service都可以提供，只要拿到IInterface，就可以直接调用里面的方法，就是一个接口。</p>
<h2 id="IMyService为什么要分Stub和Proxy"><a href="#IMyService为什么要分Stub和Proxy" class="headerlink" title="IMyService为什么要分Stub和Proxy?"></a>IMyService为什么要分Stub和Proxy?</h2><p>这是为了适用于本地调用和远程调用两种情况。</p>
<ol>
<li>如果Service运行在和Client同一个进程，那么直接使用Stub即可。 </li>
<li>如果Service运行在其他进程，客户端使用的是Proxy，这里这个Proxy的功能就是把参数封装后发送给Binder驱动，然后执行一系列IPC操作最后再取出结果返回。</li>
</ol>
<h2 id="如果使用的是远端服务，是不是Stub就没用了？"><a href="#如果使用的是远端服务，是不是Stub就没用了？" class="headerlink" title="如果使用的是远端服务，是不是Stub就没用了？"></a>如果使用的是远端服务，是不是Stub就没用了？</h2><p>不是的，Client使用Proxy发出去消息后，Service接受请求并作出相应就需要Stub，Stub是继承自</p>
<h2 id="如何判断Service运行在同一个进程还是不同的进程？"><a href="#如何判断Service运行在同一个进程还是不同的进程？" class="headerlink" title="如何判断Service运行在同一个进程还是不同的进程？"></a>如何判断Service运行在同一个进程还是不同的进程？</h2><p>如果 <strong>Service</strong> 运行在同一进程，那么客户端拿到的 <strong>IBinder</strong> 就是 <strong>Stub</strong> 类，而 <strong>Stub</strong> 的 <strong>queryLocalInterface</strong> 又会返回自己；而 <strong>Service</strong> 运行在单独进程中时，客户端拿到的 <strong>IBinder</strong> 就是系统提供好的 <strong>BinderProxy</strong>，<strong>BinderProxy</strong> 中的 <strong>queryLocalInterface</strong> 默认直接返回 <strong>null</strong>，根据代码，<strong>asInterface</strong> 就会构造一个 <strong>Proxy</strong> 返回给客户端。接着就继续我们之前那个问题提到的流程。</p>
<h2 id="AIDL是不是Binder-IPC必需的？"><a href="#AIDL是不是Binder-IPC必需的？" class="headerlink" title="AIDL是不是Binder IPC必需的？"></a>AIDL是不是Binder IPC必需的？</h2><p>不是的，AIDL只是一种规范，我们完全可以用binder类和BinderProxy类就可以自己实现Service与客户端的通信。</p>
<p>例如：<br>Service</p>
<p><img src="https://note.youdao.com/yws/api/personal/file/WEBd157868fca0b72e5d0f4476caeff8ab7?method=download&amp;shareKey=4e055d88181a10a29a81be5f643de590" alt="Service.onBind"></p>
<p>Client</p>
<p><img src="https://note.youdao.com/yws/api/personal/file/WEBd1e9d678db70029248f7463ea9523c04?method=download&amp;shareKey=6f117034aaf1e553735e3c7cbc688fe6" alt="Client.serviceConnected"></p>
<p>但是在日常开发中，我们最好还是按照AIDL的规范来进行操作。</p>
<h2 id="Binder远程通信流程是什么样的？"><a href="#Binder远程通信流程是什么样的？" class="headerlink" title="Binder远程通信流程是什么样的？"></a>Binder远程通信流程是什么样的？</h2><p><img src="https://note.youdao.com/yws/api/personal/file/WEB271e57b8c299a05434eb4dfee600dda0?method=download&amp;shareKey=7cd6547a89e45d2d66b4a9e7ddb4c98c" alt="Binder通信流程"></p>

          
        
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2018/03/28/SurfaceView和TextureView对比/" itemprop="url">
                  SurfaceView和TextureView对比
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2018-03-28T13:52:58+08:00" content="2018-03-28">
              2018-03-28
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/视频/" itemprop="url" rel="index">
                    <span itemprop="name">视频</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
          

          

          
          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="SurfaceView及TextureView对比"><a href="#SurfaceView及TextureView对比" class="headerlink" title="SurfaceView及TextureView对比"></a>SurfaceView及TextureView对比</h1><h2 id="SurfaceView是什么？"><a href="#SurfaceView是什么？" class="headerlink" title="SurfaceView是什么？"></a>SurfaceView是什么？</h2><p>它继承自类View，因此它本质上是一个View。但与普通View不同的是，它有自己的Surface。有自己的Surface，在WMS中有对应的WindowState，在SurfaceFlinger中有Layer。我们知道，一般的Activity包含的多个View会组成View hierachy的树形结构，只有最顶层的DecorView，也就是根结点视图，才是对WMS可见的。这个DecorView在WMS中有一个对应的WindowState。相应地，在SF中对应的Layer。而SurfaceView自带一个Surface，这个Surface在WMS中有自己对应的WindowState，在SF中也会有自己的Layer。虽然在App端它仍在View hierachy中，但在Server端（WMS和SF）中，它与宿主窗口是分离的。</p>
<p><img src="https://note.youdao.com/yws/api/personal/file/WEB683a92bd2aaadb2aa9eb3a9312c787d0?method=download&amp;shareKey=e3be2c2ca348fa888942b849536dd92c" alt="SurfaceView结构"></p>
<h2 id="SurfaceView这样设计的优势和缺陷是什么？"><a href="#SurfaceView这样设计的优势和缺陷是什么？" class="headerlink" title="SurfaceView这样设计的优势和缺陷是什么？"></a>SurfaceView这样设计的优势和缺陷是什么？</h2><h3 id="优势"><a href="#优势" class="headerlink" title="优势"></a>优势</h3><p>这样的好处是对这个Surface的渲染可以放到单独线程去做，渲染时可以有自己的GL context。这对于一些游戏、视频等性能相关的应用非常有益，因为它不会影响主线程对事件的响应。</p>
<h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><p>因为这个Surface不在View hierachy中，它的显示也不受View的属性控制，所以不能进行平移，缩放等变换，也不能放在其它ViewGroup中，一些View中的特性也无法使用。</p>
<h2 id="SurfaceView双缓冲是什么？"><a href="#SurfaceView双缓冲是什么？" class="headerlink" title="SurfaceView双缓冲是什么？"></a>SurfaceView双缓冲是什么？</h2><blockquote>
<p>通俗来讲就是有两个缓冲区，一个后台缓冲区和一个前台缓冲区，每次后台缓冲区接受数据，当填充完整后交换给前台缓冲，这样就保证了前台缓冲里的数据都是完整的。</p>
</blockquote>
<p>双缓冲：SurfaceView在更新视图时用到了两张Canvas：</p>
<ol>
<li>frontCanvas：实际显示的canvas</li>
<li>backCanvas：存储的是上一次更改前的canvas</li>
</ol>
<p>流程如下：</p>
<p><img src="https://note.youdao.com/yws/api/personal/file/WEB870926aec79c9b78404e61e7674605cf?method=download&amp;shareKey=73fb3846d2744ca54f31f516067f4a39" alt="双缓冲流程"></p>
<h3 id="好处是什么？"><a href="#好处是什么？" class="headerlink" title="好处是什么？"></a>好处是什么？</h3><ol>
<li>提高渲染效率</li>
<li>可以避免刷新频率过高而出现的闪烁现象</li>
</ol>
<h2 id="TextureView是什么？"><a href="#TextureView是什么？" class="headerlink" title="TextureView是什么？"></a>TextureView是什么？</h2><blockquote>
<p>在Android4.0(API level 14)中引入，与SurfaceView一样继承View，它可以将内容流直接投影到View中，它可以将内容流直接投影到View中，可以用于实现Live preview等功能。</p>
</blockquote>
<ol>
<li>和SurfaceView不同，不在WMS中单独创建窗口，而是作为View  hierachy中的一个普通view，因此可以合其他普通View一样进行移动，旋转，缩放，动画等变化。</li>
<li>和SurfaceView不同，TextureView必须在硬件加速的窗口中。</li>
<li>它显示的内容流数据可以来自App进程或是远端进程。</li>
<li>TextureView继承自View，它与其它的View一样在View hierachy中管理与绘制。TextureView重载了draw()方法，其中主要SurfaceTexture中收到的图像数据作为纹理更新到对应的HardwareLayer中。</li>
</ol>
<h2 id="TextureView优点和缺点？"><a href="#TextureView优点和缺点？" class="headerlink" title="TextureView优点和缺点？"></a>TextureView优点和缺点？</h2><p><strong>优点</strong>：支持移动、旋转、缩放等动画，支持截图<br><strong>缺点</strong>：必须在硬件加速的窗口中使用，占用内存比SurfaceView高，在5.0以前在主线程渲染，5.0以后有单独的渲染线程。</p>
<h2 id="TextureView和SurfaceView区别是什么？"><a href="#TextureView和SurfaceView区别是什么？" class="headerlink" title="TextureView和SurfaceView区别是什么？"></a>TextureView和SurfaceView区别是什么？</h2><p><img src="https://note.youdao.com/yws/api/personal/file/WEB7529fdd04d9cf09323a2d83303427b22?method=download&amp;shareKey=5c37edeaf1c1d09ee6d5f42631733ebd" alt="区别"></p>
<h2 id="播放器应该选哪个？"><a href="#播放器应该选哪个？" class="headerlink" title="播放器应该选哪个？"></a>播放器应该选哪个？</h2><p>从性能和安全性角度出发，<strong>优先选SurfaceView</strong></p>
<ol>
<li>在android 7.0上系统surfaceview的性能比TextureView更有优势，支持对象的内容位置和包含的应用内容同步更新，平移、缩放不会产生黑边。 在7.0以下系统如果使用场景有动画效果，可以选择性使用TextureView</li>
<li>由于失效(invalidation)和缓冲的特性，TextureView增加了额外1~3帧的延迟显示画面更新</li>
<li>TextureView总是使用GL合成，而SurfaceView可以使用硬件overlay后端，可以占用更少的内存带宽，消耗更少的能量</li>
<li>TextureView的内部缓冲队列导致比SurfaceView使用更多的内存</li>
<li>SurfaceView： 内部自己持有surface，surface 创建、销毁、大小改变时系统来处理的，通过surfaceHolder 的callback回调通知。当画布创建好时，可以将surface绑定到MediaPlayer中。SurfaceView如果为用户可见的时候，创建SurfaceView的SurfaceHolder用于显示视频流解析的帧图片，如果发现SurfaceView变为用户不可见的时候，则立即销毁SurfaceView的SurfaceHolder，以达到节约系统资源的目的</li>
</ol>

          
        
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
  </section>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/"><i class="fa fa-angle-left"></i></a><a class="page-number" href="/">1</a><span class="page-number current">2</span><a class="page-number" href="/page/3/">3</a><span class="space">&hellip;</span><a class="page-number" href="/page/6/">6</a><a class="extend next" rel="next" href="/page/3/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      

      <section class="site-overview sidebar-panel  sidebar-panel-active ">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="/images/avatar.jpg"
               alt="SkyAcer" />
          <p class="site-author-name" itemprop="name">SkyAcer</p>
          <p class="site-description motion-element" itemprop="description">Little And More.</p>
        </div>
        <nav class="site-state motion-element">
          <div class="site-state-item site-state-posts">
            <a href="/archives">
              <span class="site-state-item-count">28</span>
              <span class="site-state-item-name">日志</span>
            </a>
          </div>
          
          
            <div class="site-state-item site-state-categories">
              
                <span class="site-state-item-count">17</span>
                <span class="site-state-item-name">分类</span>
              
            </div>
          

          
            <div class="site-state-item site-state-tags">
              <a href="/tags">
                <span class="site-state-item-count">17</span>
                <span class="site-state-item-name">标签</span>
              </a>
            </div>
          

        </nav>

        

        <div class="links-of-author motion-element">
          
        </div>

        
        

        <div class="links-of-author motion-element">
          
        </div>

      </section>

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy; 
  <span itemprop="copyrightYear">2018</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">SkyAcer</span>
</div>

<div class="powered-by">
  由 <a class="theme-link" href="http://hexo.io">Hexo</a> 强力驱动
</div>

<div class="theme-info">
  主题 -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Pisces
  </a>
</div>



      </div>
    </footer>

    <div class="back-to-top">
      <i class="fa fa-arrow-up"></i>
    </div>
  </div>

  


  




<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>


  <script type="text/javascript" src="/vendors/jquery/index.js?v=2.1.3"></script>

  <script type="text/javascript" src="/vendors/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  <script type="text/javascript" src="/vendors/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  <script type="text/javascript" src="/vendors/velocity/velocity.min.js"></script>

  <script type="text/javascript" src="/vendors/velocity/velocity.ui.min.js"></script>

  <script type="text/javascript" src="/vendors/fancybox/source/jquery.fancybox.pack.js"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=0.5.0"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=0.5.0"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=0.5.0"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=0.5.0"></script>



  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=0.5.0"></script>



  



  



  
  
  

  


</body>
</html>
