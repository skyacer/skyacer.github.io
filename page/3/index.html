<!doctype html>



  


<html class="theme-next pisces use-motion">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>



<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />












  <link href="/vendors/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css"/>




  <link href="//fonts.googleapis.com/css?family=Lato:300,400,700,400italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">



<link href="/vendors/font-awesome/css/font-awesome.min.css?v=4.4.0" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=0.5.0" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="Hexo, NexT" />








  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=0.5.0" />






<meta name="description" content="Little And More.">
<meta property="og:type" content="website">
<meta property="og:title" content="SkyAcer&#39;s blog">
<meta property="og:url" content="http://skyacer.github.io/page/3/index.html">
<meta property="og:site_name" content="SkyAcer&#39;s blog">
<meta property="og:description" content="Little And More.">
<meta property="og:locale" content="zh-Hans">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="SkyAcer&#39;s blog">
<meta name="twitter:description" content="Little And More.">



<script type="text/javascript" id="hexo.configuration">
  var NexT = window.NexT || {};
  var CONFIG = {
    scheme: 'Pisces',
    sidebar: {"position":"left","display":"post"},
    fancybox: true,
    motion: true,
    duoshuo: {
      userId: 0,
      author: '博主'
    }
  };
</script>

  <title> SkyAcer's blog </title>
</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  








  
  
    
  

  <div class="container one-collumn sidebar-position-left 
   page-home 
 ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-meta ">
  

  <div class="custom-logo-site-title">
    <a href="/"  class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <span class="site-title">SkyAcer's blog</span>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>
  <p class="site-subtitle">Hacking,Thoughts.</p>
</div>

<div class="site-nav-toggle">
  <button>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
  </button>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-home fa-fw"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            
              <i class="menu-item-icon fa fa-archive fa-fw"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags" rel="section">
            
              <i class="menu-item-icon fa fa-tags fa-fw"></i> <br />
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-commonweal">
          <a href="/404.html" rel="section">
            
              <i class="menu-item-icon fa fa-heartbeat fa-fw"></i> <br />
            
            公益404
          </a>
        </li>
      

      
    </ul>
  

  
</nav>

 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2018/04/17/RecyclerView源码解析/" itemprop="url">
                  RecyclerView源码解析
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2018-04-17T16:36:08+08:00" content="2018-04-17">
              2018-04-17
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/View/" itemprop="url" rel="index">
                    <span itemprop="name">View</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
          

          

          
          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="RecyclerView源码解析"><a href="#RecyclerView源码解析" class="headerlink" title="RecyclerView源码解析"></a>RecyclerView源码解析</h1><h2 id="总体框架"><a href="#总体框架" class="headerlink" title="总体框架"></a>总体框架</h2><h3 id="内部调用流程"><a href="#内部调用流程" class="headerlink" title="内部调用流程"></a>内部调用流程</h3><p><img src="https://note.youdao.com/yws/api/personal/file/WEBaaa20f9284dc534d3be53ceb6e3683a3?method=download&amp;shareKey=ef2fca96c536d923ea6ab1b4a2183644" alt="内部调用流程"></p>
<h3 id="设计思路"><a href="#设计思路" class="headerlink" title="设计思路"></a>设计思路</h3><blockquote>
<p>RecyclerView官网给出的定义是: A flexible view for providing a limited window into a large data set. 也就是在限定的视图内展示大量的数据</p>
</blockquote>
<p><img src="https://note.youdao.com/yws/api/personal/file/WEB2f5e28793cca033bc119504bc4d7c41f?method=download&amp;shareKey=3e4e9fd97ff1e9f09ac0771d20e752f7" alt="适配器模式"></p>
<p>如上所示，RecyclerView表示只会和ViewHolder进行接触，Adapter的工作是将Data转换为RecyclerView认识的ViewHolder，因此RecyclerView就间接地认识Datas。</p>
<p>而RecyclerView仍然不想管理子view，于是交给了LayoutManager来帮助完成布局（桥接模式）。</p>
<p><img src="https://note.youdao.com/yws/api/personal/file/WEB8a059ab9a6a178b0ec3ee8b0ae019298?method=download&amp;shareKey=d78b65294897b8799bde0531c3256b98" alt="桥接模式"></p>
<p>但是LayoutManager这个大管家也有弱点，它只知道怎么将这一个个View布局在RecyclerView上，但是并不知道如何管理这些View，此时要有个回收期Recycler回收器做管理。当LayoutManager在需要View的时候向Recycler进行索取，当LayoutManager不需要View（试图滑出）的时候，就直接将废弃的View丢给Recycler。</p>
<p><img src="https://note.youdao.com/yws/api/personal/file/WEB6cde858d77096432bb502a1d3267e352?method=download&amp;shareKey=63d6b41952091f8b3af1e6e03a172647" alt="Recycler"></p>
<p>到了这里，看似一切都很完美，但是RecyclerView还想让子View变动的动画要优雅，所以通过观察者模式，引入了ItemAnimator(观察者模式)。</p>
<p><img src="https://note.youdao.com/yws/api/personal/file/WEBb2ff9d64047966e71e191d3c66fd88b6?method=download&amp;shareKey=a2c113f8a90134e437b95bf1d361f4ff" alt=""></p>
<h2 id="设计模式"><a href="#设计模式" class="headerlink" title="设计模式"></a>设计模式</h2><ul>
<li>通过桥接模式，使RecyclerView将布局方式独立成LayoutManager，实现对布局的定制化。</li>
<li>通过组合模式，使RecyclerView通过dispatchLayout对item View进行布局绘制。</li>
<li>通过适配器模式，ViewHolder将RecyclerView与ItemView联系起来，使得RecyclerView方便操作ItemView。</li>
<li>通过观察者模式，给ViewHolder注册观察者，当调用notifyDataSetChanged时，就能重新绘制。</li>
</ul>
<h2 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h2><h3 id="设计结构"><a href="#设计结构" class="headerlink" title="设计结构"></a>设计结构</h3><p><img src="https://note.youdao.com/yws/api/personal/file/WEBbb61dc925d026053c5d5fd14c7539edf?method=download&amp;shareKey=2790c3eb0a3f59f871c8d4541ef69ed4" alt="设计结构"></p>
<h3 id="类关系图"><a href="#类关系图" class="headerlink" title="类关系图"></a>类关系图</h3><p><img src="https://note.youdao.com/yws/api/personal/file/WEBa5cfb53836bc3c7fe1d4a11f8c2ffb29?method=download&amp;shareKey=2c2a4a7037d3c6580c1c9c0cca13502b" alt="类关系图"></p>
<ul>
<li>RecyclerViewDataObserver： 数据观察器</li>
<li>Recycler： View 循环复用系统，核心部件</li>
<li>SavedState： RecyclerView状态</li>
<li>AdapterHelper：适配器更新</li>
<li>ChildHelper：管理子View</li>
<li>ViewInfoStore：存储子VIEW的动画信息</li>
<li>Adapter：数据适配器</li>
<li>LayoutManager：负责子VIEW的布局，核心部件</li>
<li>ItemAnimator：Item动画</li>
<li>ViewFlinger：快速滑动管理</li>
<li>NestedScrollingChildHelper：管理子VIEW嵌套滑动</li>
</ul>
<h3 id="绘制详情"><a href="#绘制详情" class="headerlink" title="绘制详情"></a>绘制详情</h3><p>以我们平时使用RecyclerView的行为举例：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">recyclerView = (RecyclerView) findViewById(R.id.recyclerView);  </span><br><span class="line">LinearLayoutManager layoutManager = new LinearLayoutManager(this);  </span><br><span class="line">//设置布局管理器  </span><br><span class="line">recyclerView.setLayoutManager(layoutManager);  </span><br><span class="line">//设置为垂直布局，这也是默认的  </span><br><span class="line">layoutManager.setOrientation(OrientationHelper. VERTICAL);  </span><br><span class="line">//设置Adapter  </span><br><span class="line">recyclerView.setAdapter( recycleAdapter);  </span><br><span class="line"> //设置分隔线  </span><br><span class="line">recyclerView.addItemDecoration( new DividerGridItemDecoration(this ));  </span><br><span class="line">//设置增加或删除条目的动画  </span><br><span class="line">recyclerView.setItemAnimator( new DefaultItemAnimator());</span><br></pre></td></tr></table></figure>
<h3 id="初始化整体流程图如下"><a href="#初始化整体流程图如下" class="headerlink" title="初始化整体流程图如下"></a>初始化整体流程图如下</h3><p><img src="https://note.youdao.com/yws/api/personal/file/WEBca3ee08fea0d2c88b4bb959fa6e7b37d?method=download&amp;shareKey=af0fae22f03cfb0ab37b8d889c3188e9" alt="流程图"></p>
<h3 id="RecyclerView-layout（setLayoutManager）流程是什么样的？"><a href="#RecyclerView-layout（setLayoutManager）流程是什么样的？" class="headerlink" title="RecyclerView layout（setLayoutManager）流程是什么样的？"></a>RecyclerView layout（setLayoutManager）流程是什么样的？</h3><p><img src="https://note.youdao.com/yws/api/personal/file/WEB749b77d77ef0b7b430abaa44ba51e739?method=download&amp;shareKey=9d46381b8409bcd6a7d8fa5408b124ed" alt="RecyclerView Layout流程"></p>
<h3 id="layout过程中onLayoutChildren是什么流程？"><a href="#layout过程中onLayoutChildren是什么流程？" class="headerlink" title="layout过程中onLayoutChildren是什么流程？"></a>layout过程中onLayoutChildren是什么流程？</h3><p><img src="https://note.youdao.com/yws/api/personal/file/WEB2408904753cd6aee9d430862d107cbd3?method=download&amp;shareKey=9a29c10d31ad325d5b1e81700cafb0b8" alt=""></p>
<ul>
<li>找到anchor点</li>
<li>根据anchor一直向前布局，直到充满anchor点前面的所有区域</li>
<li>根据anchor一直向后布局，直到填充满anchor点后面所有区域，以垂直布局来说明，mAnchorInfo为布局锚点信息，包含了子控件在Y轴上起始绘制偏移量(coordinate)，ItemView在Adapter中的索引信息(position)和布局方向(mLayoutFromEnd) ——指start、end方向。确定布局锚点，以此为起点向开始和结束方向填充ItemView。</li>
</ul>
<h3 id="setAdapter方法最终调用的流程？"><a href="#setAdapter方法最终调用的流程？" class="headerlink" title="setAdapter方法最终调用的流程？"></a>setAdapter方法最终调用的流程？</h3><ol>
<li>如果之前存在Adapter，先移除原来的，注销观察者，从RecyclerView Detached。</li>
<li>根据参数，决定是否清除原来的ViewHolder。</li>
<li>重置AdapterHelper，更新Adapter，注册观察者。</li>
</ol>
<h3 id="RecyclerView的滑动过程是什么样的？"><a href="#RecyclerView的滑动过程是什么样的？" class="headerlink" title="RecyclerView的滑动过程是什么样的？"></a>RecyclerView的滑动过程是什么样的？</h3><p><img src="https://note.youdao.com/yws/api/personal/file/WEB3b18149dec7c15370c35b6ae0b894575?method=download&amp;shareKey=187a8d1c6699f89ae7f64670b09f98cd" alt="滑动过程"></p>
<h3 id="缓存逻辑是什么样的？"><a href="#缓存逻辑是什么样的？" class="headerlink" title="缓存逻辑是什么样的？"></a>缓存逻辑是什么样的？</h3><p>总共分为两级缓存</p>
<ol>
<li>mCachedViews，先进先出的数据结构，将新的View存入mCachedViews，移除头元素，并将头元素放入mRecyclerPool</li>
<li>mRecyclerPool，可以多个ReyclerView共享，减少内存开销。</li>
</ol>
<h3 id="AdapterView与RecyclerView的区别？"><a href="#AdapterView与RecyclerView的区别？" class="headerlink" title="AdapterView与RecyclerView的区别？"></a>AdapterView与RecyclerView的区别？</h3><p><img src="https://note.youdao.com/yws/api/personal/file/WEB4edaacbfaf0b69b263ec9f0002627249?method=download&amp;shareKey=9f60f307584f038c0834883e96f764d5" alt="区别"></p>
<h3 id="RecyclerView中有哪些设计精巧的地方？"><a href="#RecyclerView中有哪些设计精巧的地方？" class="headerlink" title="RecyclerView中有哪些设计精巧的地方？"></a>RecyclerView中有哪些设计精巧的地方？</h3><h4 id="Bucket"><a href="#Bucket" class="headerlink" title="Bucket"></a>Bucket</h4><blockquote>
<p>用来表示不设上限的状态，Bucket是一个链表结构，当index大于64的时候，它便会去下一个Bucket寻找，Bucket不设上限的表示状态。</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">static class Bucket &#123;</span><br><span class="line">    final static int BITS_PER_WORD = Long.SIZE;</span><br><span class="line">    final static long LAST_BIT = 1L &lt;&lt; (Long.SIZE - 1);</span><br><span class="line">    long mData = 0;</span><br><span class="line">    Bucket next;</span><br><span class="line">    void set(int index) &#123;</span><br><span class="line">        if (index &gt;= BITS_PER_WORD) &#123;</span><br><span class="line">            ensureNext();</span><br><span class="line">            next.set(index - BITS_PER_WORD);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            mData |= 1L &lt;&lt; index;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="Pools"><a href="#Pools" class="headerlink" title="Pools"></a>Pools</h4><p>相当于Messages的池的概念，通过Message.obtain()可以在很多情况下避免创建新的对象</p>
<ul>
<li>RecycleView将Item的增删改封装为UpdateOp类</li>
<li>ViewInfoStore类中的静态内部类infoRecord</li>
</ul>
<h2 id="使用RecyclerView有没有遇到不好用的地方？"><a href="#使用RecyclerView有没有遇到不好用的地方？" class="headerlink" title="使用RecyclerView有没有遇到不好用的地方？"></a>使用RecyclerView有没有遇到不好用的地方？</h2><p>RecyclerView也不是万能的，它的灵活性也是有一定限制的，比如我就遇到了一不是很好解决的问题：Recyler的缓存级别是一个Item的整个View，而我们没办法自定义缓存级别，这样说比较抽象，举个例子，我的某些Item的某个子View加载很耗时，所以我希望我在上下滑动的时候，Item的其它View是可以被回收利用的，但这个加载很耗时的View是不要重复使用的。即我希望用空间换取时间来获取滑动的流畅性。当然，这样的需求不常见，RecyclerView也不能很好的满足这一点。</p>

          
        
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2018/04/15/《Android优化专题》——音频播放/" itemprop="url">
                  《Android优化专题》——音频播放
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2018-04-15T15:37:51+08:00" content="2018-04-15">
              2018-04-15
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/Android优化/" itemprop="url" rel="index">
                    <span itemprop="name">Android优化</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
          

          

          
          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="《Android优化专题》——音频播放"><a href="#《Android优化专题》——音频播放" class="headerlink" title="《Android优化专题》——音频播放"></a>《Android优化专题》——音频播放</h1><h2 id="一、控制app的音量与播放"><a href="#一、控制app的音量与播放" class="headerlink" title="一、控制app的音量与播放"></a>一、控制app的音量与播放</h2><h3 id="使用硬件音量键来控制音量"><a href="#使用硬件音量键来控制音量" class="headerlink" title="使用硬件音量键来控制音量"></a>使用硬件音量键来控制音量</h3><p>需要在Activity或者Fragment创建的时候就设置音量控制，这样确保不管App是否可见，音频控制功能都正常工作。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">setVolumeControlStream(AudioManager.STREAM_MUSIC);</span><br></pre></td></tr></table></figure>
<h3 id="使用硬件的播放控制按键来控制App的音频播放"><a href="#使用硬件的播放控制按键来控制App的音频播放" class="headerlink" title="使用硬件的播放控制按键来控制App的音频播放"></a>使用硬件的播放控制按键来控制App的音频播放</h3><p>无论用户通过手机或者线控耳机等按下哪些控制按钮，比如播放、暂停，系统都会广播一个带有ACTION_MEDIA_BUTTON的Intent。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;receiver android:name=&quot;.RemoteControlReceiver&quot;&gt;</span><br><span class="line">    &lt;intent-filter&gt;</span><br><span class="line">        &lt;action android:name=&quot;android.intent.action.MEDIA_BUTTON&quot; /&gt;</span><br><span class="line">    &lt;/intent-filter&gt;</span><br><span class="line">&lt;/receiver&gt;</span><br></pre></td></tr></table></figure>
<p>Receiver需要判断广播来自哪个按钮</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public class RemoteControlReceiver extends BroadcastReceiver &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void onReceive(Context context, Intent intent) &#123;</span><br><span class="line">        if (Intent.ACTION_MEDIA_BUTTON.equals(intent.getAction())) &#123;</span><br><span class="line">            KeyEvent event = (KeyEvent)intent.getParcelableExtra(Intent.EXTRA_KEY_EVENT);</span><br><span class="line">            if (KeyEvent.KEYCODE_MEDIA_PLAY == event.getKeyCode()) &#123;</span><br><span class="line">                // Handle key press.  </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="如何注册监听和取消监听"><a href="#如何注册监听和取消监听" class="headerlink" title="如何注册监听和取消监听"></a>如何注册监听和取消监听</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">AudioManager am = mContext.getSystemService(Context.AUDIO_SERVICE);</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">// Start listening for button presses</span><br><span class="line">am.registerMediaButtonEventReceiver(RemoteControlReceiver);</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">// Stop listening for button presses</span><br><span class="line">am.unregisterMediaButtonEventReceiver(RemoteControlReceiver);</span><br></pre></td></tr></table></figure>
<h2 id="二、管理音频焦点"><a href="#二、管理音频焦点" class="headerlink" title="二、管理音频焦点"></a>二、管理音频焦点</h2><h3 id="请求获取音频焦点"><a href="#请求获取音频焦点" class="headerlink" title="请求获取音频焦点"></a>请求获取音频焦点</h3><p>requestAudioFocus() 来获取到音频流焦点。</p>
<ul>
<li>短暂的焦点锁定：当期待播放一个短暂的音频时候（比如推送声音）</li>
<li>永久的焦点锁定：当计划播放可预期到的较长的音频时候（比如播放音乐）</li>
</ul>
<p>我们必须在开始播放前请求音频焦点，比如用户此时点击了播放按钮</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">AudioManager am = mContext.getSystemService(Context.AUDIO_SERVICE);</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">// Request audio focus for playback  </span><br><span class="line">int result = am.requestAudioFocus(afChangeListener,</span><br><span class="line">                                 // Use the music stream.  </span><br><span class="line">                                 AudioManager.STREAM_MUSIC,</span><br><span class="line">                                 // Request permanent focus.  </span><br><span class="line">                                 AudioManager.AUDIOFOCUS_GAIN);</span><br><span class="line"></span><br><span class="line">if (result == AudioManager.AUDIOFOCUS_REQUEST_GRANTED) &#123;</span><br><span class="line">    am.unregisterMediaButtonEventReceiver(RemoteControlReceiver);</span><br><span class="line">    // Start playback.  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>一旦结束播放，需要调用abandonAudioFocus()方法，通知系统说不再需要获取焦点并且取消注册AudioManager.OnAudioFocusChangeListener的焦点。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// Abandon audio focus when playback complete</span><br><span class="line">am.abandonAudioFocus(afChangeListener);</span><br></pre></td></tr></table></figure>
<p>当请求短暂音频焦点，我们可以选择是否开启”ducking”，Ducking机制可以允许音频间歇性短暂播放。可以让其他App继续播放，仅在短暂的时间内降低自己的音量。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">// Request audio focus for playback  </span><br><span class="line">int result = am.requestAudioFocus(afChangeListener,</span><br><span class="line">                             // Use the music stream.  </span><br><span class="line">                             AudioManager.STREAM_MUSIC,</span><br><span class="line">                             // Request permanent focus.  </span><br><span class="line">                             AudioManager.AUDIOFOCUS_GAIN_TRANSIENT_MAY_DUCK);</span><br><span class="line"></span><br><span class="line">if (result == AudioManager.AUDIOFOCUS_REQUEST_GRANTED) &#123;</span><br><span class="line">    // Start playback.  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="处理失去音频焦点"><a href="#处理失去音频焦点" class="headerlink" title="处理失去音频焦点"></a>处理失去音频焦点</h3><ul>
<li>失去短暂焦点：在这种情况下，暂停当前音频的播放或者降低音量，需要准备恢复播放在重新获取到焦点之后。</li>
<li>失去永久焦点：假设另一个程序开始播放音乐，此时我们的程序就应该彻底结束。停止播放，放弃自己的音频焦点。</li>
<li>Ducking：降低音量，让其余短暂声音突出，之后恢复原音量。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">OnAudioFocusChangeListener afChangeListener = new OnAudioFocusChangeListener() &#123;</span><br><span class="line">    public void onAudioFocusChange(int focusChange) &#123;</span><br><span class="line">        if (focusChange == AUDIOFOCUS_LOSS_TRANSIENT</span><br><span class="line">            // Pause playback  </span><br><span class="line">            //失去短暂焦点</span><br><span class="line">        &#125; else if (focusChange == AudioManager.AUDIOFOCUS_GAIN) &#123;</span><br><span class="line">            // Resume playback</span><br><span class="line">            //恢复焦点   </span><br><span class="line">        &#125; else if (focusChange==AUDIOFOCUS_LOSS_TRANSIENT_CAN_DUCK</span><br><span class="line">            // Lower the volume  </span><br><span class="line">        &#125; else if (focusChange == AudioManager.AUDIOFOCUS_LOSS) &#123;</span><br><span class="line">    am.unregisterMediaButtonEventReceiver(RemoteControlReceiver);</span><br><span class="line">            am.abandonAudioFocus(afChangeListener);</span><br><span class="line">            // Stop playback  </span><br><span class="line">            // 失去永久焦点</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="三、音频设备的相关问题"><a href="#三、音频设备的相关问题" class="headerlink" title="三、音频设备的相关问题"></a>三、音频设备的相关问题</h2><h3 id="检测目前正在使用的硬件设备"><a href="#检测目前正在使用的硬件设备" class="headerlink" title="检测目前正在使用的硬件设备"></a>检测目前正在使用的硬件设备</h3><p>可以使用AudioManager来查询某个音频是否输出到扬声器，有线耳机还是蓝牙上。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">if (isBluetoothA2dpOn()) &#123;</span><br><span class="line">    // Adjust output for Bluetooth.  </span><br><span class="line">&#125; else if (isSpeakerphoneOn()) &#123;</span><br><span class="line">    // Adjust output for Speakerphone.  </span><br><span class="line">&#125; else if (isWiredHeadsetOn()) &#123;</span><br><span class="line">    // Adjust output for headsets  </span><br><span class="line">&#125; else &#123;</span><br><span class="line">    // If audio plays and noone can hear it, is it still playing?  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="处理音频输出设备的改变"><a href="#处理音频输出设备的改变" class="headerlink" title="处理音频输出设备的改变"></a>处理音频输出设备的改变</h3><p>当耳机线被拔出，或者蓝牙耳机连接断开时，如果在播放音乐/视频，为了用户体验，避免突如其来的扬声器播放，我们通常做法是暂停此时正在播放的音乐/视频。</p>
<p>在这种情况下，系统会广播带有ACTION_AUDIO_BECOMING_NOISY的intent。我们只需要接受这种广播，对其进行处理即可。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">private class NoisyAudioStreamReceiver extends BroadcastReceiver &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void onReceive(Context context, Intent intent) &#123;</span><br><span class="line">        if (AudioManager.ACTION_AUDIO_BECOMING_NOISY.equals(intent.getAction())) &#123;</span><br><span class="line">            // Pause the playback  </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private IntentFilter intentFilter = new IntentFilter(AudioManager.ACTION_AUDIO_BECOMING_NOISY);</span><br><span class="line"></span><br><span class="line">private void startPlayback() &#123;</span><br><span class="line">    registerReceiver(myNoisyAudioStreamReceiver(), intentFilter);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private void stopPlayback() &#123;</span><br><span class="line">    unregisterReceiver(myNoisyAudioStreamReceiver);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
          
        
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2018/04/12/JVM内存模型/" itemprop="url">
                  JVM内存模型
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2018-04-12T14:49:40+08:00" content="2018-04-12">
              2018-04-12
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/JVM/" itemprop="url" rel="index">
                    <span itemprop="name">JVM</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
          

          

          
          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="JVM内存模型"><a href="#JVM内存模型" class="headerlink" title="JVM内存模型"></a>JVM内存模型</h1><h2 id="简单来说JVM内存模型是什么样的？"><a href="#简单来说JVM内存模型是什么样的？" class="headerlink" title="简单来说JVM内存模型是什么样的？"></a>简单来说JVM内存模型是什么样的？</h2><p><img src="https://note.youdao.com/yws/api/personal/file/WEB9b72e7ca84813b9d70d9e53b2337545f?method=download&amp;shareKey=c659a9b8ad449a74d3a92fd212f495e9" alt=""></p>
<h3 id="线程私有区："><a href="#线程私有区：" class="headerlink" title="线程私有区："></a>线程私有区：</h3><ul>
<li>程序计数器，记录正在执行的虚拟机字节码的地址；</li>
<li>虚拟机栈，方法执行的内存区，每个方法执行时在虚拟机栈中创建栈帧；</li>
<li>本地方法栈，虚拟机的Native方法执行的内存区；</li>
</ul>
<h3 id="线程共享区："><a href="#线程共享区：" class="headerlink" title="线程共享区："></a>线程共享区：</h3><ul>
<li>Java堆：对象分配内存的区域；</li>
<li>方法区：存放类信息、常量、静态变量、编译器编译后的代码等数据；<ul>
<li>常量池：存放编译器生成的字面量和符号引用，是方法区的一部分。 </li>
</ul>
</li>
</ul>
<h3 id="通常所说的Java堆和Java栈是指什么？"><a href="#通常所说的Java堆和Java栈是指什么？" class="headerlink" title="通常所说的Java堆和Java栈是指什么？"></a>通常所说的Java堆和Java栈是指什么？</h3><p>通常所说的Java堆指的是共享数据区的堆，Java栈指的是线程私有的虚拟机栈。</p>
<h2 id="JVM中更详细的内存模型是什么样的？"><a href="#JVM中更详细的内存模型是什么样的？" class="headerlink" title="JVM中更详细的内存模型是什么样的？"></a>JVM中更详细的内存模型是什么样的？</h2><p><img src="https://note.youdao.com/yws/api/personal/file/WEB73bae4dd3b8c5e8b481d92d6cb8a07d5?method=download&amp;shareKey=d9f8bfec8cb4b4af1862d0a6e86bdeea" alt="JVM更详细的内存模型"></p>
<h3 id="程序计数器"><a href="#程序计数器" class="headerlink" title="程序计数器"></a>程序计数器</h3><ol>
<li>每个线程都有计数器，是私有内存空间，该区域是整个内存中较小的一块。</li>
<li>当线程正在执行一个Java方法时，PC计数器记录的是正在执行的虚拟机字节码的地址。</li>
<li>当线程正在执行Native方法时，PC计数器则为空</li>
</ol>
<h3 id="虚拟机栈"><a href="#虚拟机栈" class="headerlink" title="虚拟机栈"></a>虚拟机栈</h3><blockquote>
<p>栈祯是用于支持虚拟机进行方法执行的数据结构，是属性运行时数据区的虚拟机的栈元素。</p>
</blockquote>
<ol>
<li>局部变量表，一组变量存储空间，容量以slot为最小单位。</li>
<li>操作栈（stack大小，编译器确定），操作栈元素的数据必须与字节码指令序列严格匹配。</li>
<li>动态连接，指向运行时常量池中该栈所属方法的引用，为了动态连接使用。<ul>
<li>前面的解析过程是静态解析</li>
<li>对于运行期转化为直接引用，动态解析。</li>
</ul>
</li>
<li>方法返回地址<ul>
<li>正常退出，执行引擎遇到方法返回的字节码，将返回值传递给调用者。</li>
<li>异常退出，遇到Exception，并且方法未捕获异常，不会有任何返回值。</li>
</ul>
</li>
<li>额外附加信息，由具体虚拟机实现。</li>
</ol>
<p><strong>异常（Exception）</strong></p>
<ul>
<li>StackOverFlowError：当线程请求栈深度超出虚拟机栈允许深度时抛出</li>
<li>OutOfMemoryError：当Java虚拟机动态扩展到无法申请足够内存时抛出</li>
</ul>
<h3 id="本地方法栈"><a href="#本地方法栈" class="headerlink" title="本地方法栈"></a>本地方法栈</h3><p>本地方法栈为虚拟机使用到的Native方法提供内存空间，而虚拟机栈则为Java方法提供内存空间。</p>
<h3 id="Java堆"><a href="#Java堆" class="headerlink" title="Java堆"></a>Java堆</h3><p>Java堆是虚拟机管理的最大一块内存，也是GC的主战场，存放的是几乎所有的对象实例和数组数据。</p>
<ul>
<li>从内存回收角度，Java堆被分为新生代和老年代；为了更快地回收内存。</li>
<li>从内存分配角度，Java堆可以划分出线程私有的分配缓冲区（Thread Local Allocation Buffer,TLAB），为了更快地分配内存。</li>
</ul>
<h3 id="对象实例结构是什么样的？"><a href="#对象实例结构是什么样的？" class="headerlink" title="对象实例结构是什么样的？"></a>对象实例结构是什么样的？</h3><p><img src="https://note.youdao.com/yws/api/personal/file/WEBe2af8709014a9b7dc3005005fda1ea82?method=download&amp;shareKey=14e5e6c91dc5864b718ec8d95003351e" alt="对象实例结构"></p>
<p>填充数据不一定存在，是为了字节对齐而存在的</p>
<p>此区域可以抛出OOM Error异常</p>
<h3 id="方法区"><a href="#方法区" class="headerlink" title="方法区"></a>方法区</h3><p>主要存放被虚拟机加载的类信息、常量、静态变量、编译器编译后的代码数据。</p>
<p>此区域可以抛出OOM Error异常</p>
<h3 id="运行时常量池"><a href="#运行时常量池" class="headerlink" title="运行时常量池"></a>运行时常量池</h3><p>属于方法区的一部分，用于存放编译器生成的各种字面量和符号引用。运行时常量池除了编译器产生的Class文件的常量池，还可以在运行期，将新的常量加入常量池，比如String的intern()方法。</p>
<ul>
<li>字面量：与Java语言层面的常量概念相近，包含文本字符串，声明为final的常量值等等。</li>
<li>符号引用：<ul>
<li>类和接口的全限定名</li>
<li>字段的名称和描述符</li>
<li>方法的名称和描述符 </li>
</ul>
</li>
</ul>
<p>此区域<strong>不会</strong>抛出OOM Error异常</p>

          
        
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2018/04/11/Android窗口管理分析（一）——View是如何绘制到屏幕上的/" itemprop="url">
                  Android窗口管理分析（一）——View是如何绘制到屏幕上的
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2018-04-11T15:42:02+08:00" content="2018-04-11">
              2018-04-11
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/framework/" itemprop="url" rel="index">
                    <span itemprop="name">framework</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
          

          

          
          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="Android窗口管理分析（一）——View是如何绘制到屏幕上的"><a href="#Android窗口管理分析（一）——View是如何绘制到屏幕上的" class="headerlink" title="Android窗口管理分析（一）——View是如何绘制到屏幕上的"></a>Android窗口管理分析（一）——View是如何绘制到屏幕上的</h1><blockquote>
<p>窗口管理涉及到的模块很多，除了WindowManagerService还包括SurfaceFlinger服务、Linux的共享内存及tmpfs文件系统、Binder通信、InputManagerService、VSYNC同步技术等。</p>
</blockquote>
<h2 id="View的窗口管理分为哪些部分？"><a href="#View的窗口管理分为哪些部分？" class="headerlink" title="View的窗口管理分为哪些部分？"></a>View的窗口管理分为哪些部分？</h2><p><img src="https://note.youdao.com/yws/api/personal/file/WEBdb44b5849365c6f181d3c424dc60e1ab?method=download&amp;shareKey=30075989c77b1a06262ff679ef2ed252" alt="窗口管理"></p>
<h2 id="WMS是负责View绘制的吗？"><a href="#WMS是负责View绘制的吗？" class="headerlink" title="WMS是负责View绘制的吗？"></a>WMS是负责View绘制的吗？</h2><p><strong>WMS的作用是窗口管理，不负责View的绘制，真正完成图像绘制的是SurfaceFlinger服务</strong></p>
<p>WMS（WindowManagerService）是负责Android的窗口的管理，比如窗口的添加、移除、调整顺序等等。至于图像的绘制和合成都不是WMS管理的范畴。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">TextView mview=new TextView(context);</span><br><span class="line">    ...&lt;!--设置颜色 样式--&gt;</span><br><span class="line">    WindowManager mWindowManager = (WindowManager) getSystemService(Context.WINDOW_SERVICE);</span><br><span class="line">    WindowManager.LayoutParams wmParams = new WindowManager.LayoutParams();</span><br><span class="line">    wmParams.type = WindowManager.LayoutParams.TYPE_TOAST;</span><br><span class="line">    wmParams.format = PixelFormat.RGBA_8888;</span><br><span class="line">    wmParams.width = 800;</span><br><span class="line">    wmParams.height = 800;</span><br><span class="line">    mWindowManager.addView(mview, wmParams);</span><br></pre></td></tr></table></figure>
<ol>
<li>在利用WindowManager.addView添加窗口之前，TextView的onDraw不会被调用，也就是说View必须被添加到窗口中，才会被绘制。换句话说，<strong>只有申请了依附窗口，View才会有可以绘制的目标内存。</strong></li>
<li>在添加窗口的时候，除了WMS自己进行注册整理，还需要向SurfaceFlinger服务申请一块Surface画布，对应的是一块内存。</li>
<li>只有这块内存申请成功之后，APP才会有绘画的目标，这块内存是APP和SurfaceFlinger服务端共享的，省去了绘图资源的拷贝。</li>
</ol>
<p><img src="https://note.youdao.com/yws/api/personal/file/WEB552342f685a75dfac6192a6898c70c21?method=download&amp;shareKey=9b0c041e0aa0a537614211820967f4ce" alt="Android绘图原理"></p>
<p><strong>可以看到App通过unLockCanvasAndPost直接和SurfaceFlinger通信进行重绘的。WMS只负责窗口的管理，不负责绘制。</strong></p>
<h2 id="窗口分组是什么样的？"><a href="#窗口分组是什么样的？" class="headerlink" title="窗口分组是什么样的？"></a>窗口分组是什么样的？</h2><p>Android中的窗口主要分为三种：</p>
<ol>
<li>系统窗口——Toast</li>
<li>应用窗口——Dialog、Activity。不过Dialog必须依附Activity才能存在</li>
<li>子窗口——PopupWindow，必须依附其他窗口，依附的窗口只能是1，2而不能是3</li>
</ol>
<p><img src="https://note.youdao.com/yws/api/personal/file/WEB98371b5048dfa8b7fe0142093823d404?method=download&amp;shareKey=fba43e8d94e0d2b4d30cb2f10704f573" alt="窗口组织形式"></p>
<p>WMS不仅只是管理窗口，还负责窗口动画，Touch事件等等。</p>
<h2 id="View绘制的内存分配是什么机制？"><a href="#View绘制的内存分配是什么机制？" class="headerlink" title="View绘制的内存分配是什么机制？"></a>View绘制的内存分配是什么机制？</h2><p>每个Activity看做一个图层，对应一块Surface，Surface绘图表面对应的内存是SurfaceFlinger申请的，内存是APP与SurfaceFlinger间进程共享的，所以APP和SurfaceFlinger的通信基于<strong>共享内存</strong>实现的。</p>
<h2 id="共享内存的具体实现是什么样的？"><a href="#共享内存的具体实现是什么样的？" class="headerlink" title="共享内存的具体实现是什么样的？"></a>共享内存的具体实现是什么样的？</h2><p>共享内存是基于MAP+tmpfs文件系统实现，可以理解为SF为APP申请一块内存，然后通过binder将内存相关的信息传递给APP，APP端在这块内存中绘制内容，绘制完毕后通知SF图层混排，再由SF将数据渲染到屏幕上，这么做的目的主要考虑图像内存比较大，用socket,binder方式传递效率上无法满足要求。</p>
<p><img src="https://note.youdao.com/yws/api/personal/file/WEBe00aaff15eaf1ac892950c9e4c6fd4b4?method=download&amp;shareKey=e57fbd76b670782fb8bb85869ec2d0d3" alt="共享内存具体实现"></p>
<ol>
<li>SurfaceFlinger服务属于系统服务，主要用于将APP绘制完毕的数据渲染到屏幕上。</li>
<li>各应用的View的绘制都需要经过SurfaceFlinger服务。</li>
<li>WindowManagerService：WMS控制Surface画布的添加和次序，动画还有触摸事件。</li>
<li>每个App进程负责相应图层的绘制。</li>
<li>App与SurfaceFlinger通信是通过匿名内存来实现的。</li>
</ol>

          
        
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2018/04/04/HTTP浅析（一）HTTP报文/" itemprop="url">
                  HTTP解析（一）HTTP报文
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2018-04-04T17:27:32+08:00" content="2018-04-04">
              2018-04-04
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/基础知识/" itemprop="url" rel="index">
                    <span itemprop="name">基础知识</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
          

          

          
          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="HTTP浅析（一）HTTP报文"><a href="#HTTP浅析（一）HTTP报文" class="headerlink" title="HTTP浅析（一）HTTP报文"></a>HTTP浅析（一）HTTP报文</h1><p><img src="https://note.youdao.com/yws/api/personal/file/WEB0dbed166d932eb00e22bccb5438230eb?method=download&amp;shareKey=a5ed5c1fbdc8496b9839ba3fe967c133" alt="HTTP报文"></p>
<ol>
<li>起始行</li>
<li>首部</li>
<li>主体（非必须）</li>
</ol>
<h3 id="结构图"><a href="#结构图" class="headerlink" title="结构图"></a>结构图</h3><p><img src="https://note.youdao.com/yws/api/personal/file/WEB6daa85ab664df6f242e6a0ab5c031aad?method=download&amp;shareKey=b82f6a53c791a919eec21bb7e03b778f" alt="HTTP报文结构图"></p>
<h2 id="连接管理"><a href="#连接管理" class="headerlink" title="连接管理"></a>连接管理</h2><h3 id="从浏览器键入地址到连接结束的过程是什么？"><a href="#从浏览器键入地址到连接结束的过程是什么？" class="headerlink" title="从浏览器键入地址到连接结束的过程是什么？"></a>从浏览器键入地址到连接结束的过程是什么？</h3><p><img src="https://note.youdao.com/yws/api/personal/file/WEB2e66135edc8807da9a26b82c7f6fe49b?method=download&amp;shareKey=5d42e46fb1f35a721f6700404182fe78" alt="连接过程"></p>
<p>TCP为HTTP提供一条可靠的比特传输管道，从TCP连接一端填入的字节会从另一端以原有的顺序、正确地传送出来。</p>
<h3 id="HTTP和HTTPS的区别？"><a href="#HTTP和HTTPS的区别？" class="headerlink" title="HTTP和HTTPS的区别？"></a>HTTP和HTTPS的区别？</h3><p><img src="https://note.youdao.com/yws/api/personal/file/WEB014ec3806a6ade023937cf16362f8e2b?method=download&amp;shareKey=ca78563f5a64ea7de698304d2d9c723b" alt=""></p>
<h3 id="TCP连接持续不断地进行"><a href="#TCP连接持续不断地进行" class="headerlink" title="TCP连接持续不断地进行"></a>TCP连接持续不断地进行</h3><p>TCP连接根据四个值来识别</p>
<ol>
<li>源IP地址</li>
<li>源端口号</li>
<li>目的IP地址</li>
<li>目的端口号</li>
</ol>
<p>这四个值唯一确定了一条连接，任意一条不相同的连接必然这四个值不会完全相同。</p>
<h3 id="TCP结构是什么？"><a href="#TCP结构是什么？" class="headerlink" title="TCP结构是什么？"></a>TCP结构是什么？</h3><p><img src="https://note.youdao.com/yws/api/personal/file/WEB8979962c8f98c373c80f33dc1f6677f9?method=download&amp;shareKey=2015d94639e71cf59dd0f696da882912" alt="TCP结构图"></p>
<h3 id="如何用Socket实现HTTP事务？"><a href="#如何用Socket实现HTTP事务？" class="headerlink" title="如何用Socket实现HTTP事务？"></a>如何用Socket实现HTTP事务？</h3><p><img src="https://note.youdao.com/yws/api/personal/file/WEB3c1d56f9ec210ee4b1c20bcb9ad638af?method=download&amp;shareKey=8ee5d2c611ab91d812316957645e29df" alt="如何用Socket实现HTTP事务"></p>
<h3 id="TCP客户端和服务器如何通过Socket通信？"><a href="#TCP客户端和服务器如何通过Socket通信？" class="headerlink" title="TCP客户端和服务器如何通过Socket通信？"></a>TCP客户端和服务器如何通过Socket通信？</h3><p><img src="https://note.youdao.com/yws/api/personal/file/WEB3c1d56f9ec210ee4b1c20bcb9ad638af?method=download&amp;shareKey=8ee5d2c611ab91d812316957645e29df" alt="通过Socket通信"></p>
<h3 id="HTTP事务的时延有哪些原因？"><a href="#HTTP事务的时延有哪些原因？" class="headerlink" title="HTTP事务的时延有哪些原因？"></a>HTTP事务的时延有哪些原因？</h3><p>由于和建立TCP连接相比，事务处理时间是很短的，除非在处理很复杂的动态资源，否则HTTP的时延就是由TCP网络时延导致的。</p>
<ol>
<li>如果最近没有对URI中的主机名访问，通过DNS解析系统要转换IP需要花费数十秒。</li>
<li>TCP每次连接都需要三次握手，这个值最多一两秒，但是连接多的话会累加上去（非HTTP2.0的情况）</li>
<li>一旦连接建立，读取请求报文，传输请求报文，处理请求报文都需要时间。</li>
<li>回送HTTP相应也需要时间。</li>
</ol>
<h3 id="我们应该从哪些方面来提升TCP的性能？"><a href="#我们应该从哪些方面来提升TCP的性能？" class="headerlink" title="我们应该从哪些方面来提升TCP的性能？"></a>我们应该从哪些方面来提升TCP的性能？</h3><ol>
<li>TCP连接建立握手</li>
<li>TCP慢启动拥塞控制</li>
<li>数据聚集的Nagle算法</li>
<li>用于捎带确认的TCP延迟确认算法</li>
<li>TIME_WAIT时延和端口耗尽</li>
</ol>
<h3 id="什么是TCP的延迟确认机制？"><a href="#什么是TCP的延迟确认机制？" class="headerlink" title="什么是TCP的延迟确认机制？"></a>什么是TCP的延迟确认机制？</h3><p>由于因特网无法确保可靠的分组传输（因特网路由器超负荷的话，可以随意丢弃分组，所以TCP实现了自己的确认机制来确保数据的成功传输）</p>
<p><img src="https://note.youdao.com/yws/api/personal/file/WEB661a339d12a31ad81a5ba68c79fb6b34?method=download&amp;shareKey=70f21e7cbb55c0ed891869e621837eb4" alt="TCP延迟确认"></p>
<h3 id="什么是TCP慢启动？"><a href="#什么是TCP慢启动？" class="headerlink" title="什么是TCP慢启动？"></a>什么是TCP慢启动？</h3><p>TCP面对大量的数据，不会一次性将所有分组都发出去，TCP会随着时间进行自我“调谐”，起初会限制连接的最大速度。如果成功则会逐渐加大传输速度，简单来说：</p>
<p>发送一个分组 -&gt; 确认发送成功 -&gt; 具备一次性发送两个分组的权限 -&gt; 发送两个分组 -&gt; 以此类推</p>
<h3 id="什么是Nagle算法和TCP-NODELAY？"><a href="#什么是Nagle算法和TCP-NODELAY？" class="headerlink" title="什么是Nagle算法和TCP_NODELAY？"></a>什么是Nagle算法和TCP_NODELAY？</h3><p>由于每个TCP段都会有40个字节的标记和首部无法省略，所以在发送频繁的小数据请求时，这40个多余的字节带来的性能问题就会变得严重。</p>
<p>Nagle算法试图在发送一个分组前，将大量的TCP数据绑定在一起，以提高网络效率。</p>
<p>仅适合频繁的小数据请求</p>
<p>缺点：可能会因为无法填满一个分组，导致一直等待永远不会到来的数据而产生延迟</p>
<h3 id="什么是TIME-WAIT累积与端口耗尽？"><a href="#什么是TIME-WAIT累积与端口耗尽？" class="headerlink" title="什么是TIME_WAIT累积与端口耗尽？"></a>什么是TIME_WAIT累积与端口耗尽？</h3><p>在TCP关闭后，在内存中会维持一个小的控制块，用来记录最近这个关闭的IP地址和端口号，通常会存在一段时间，通常是所顾忌的最大分段试用期的两倍（2MSL,通常为两分钟），确保分组被复制且插入了具有相同连接值（源/目的IP地址和端口号），这样会破坏TCP数据。</p>
<p><img src="https://note.youdao.com/yws/api/personal/file/WEBb568c12c17e19e314530750afc6690e9?method=download&amp;shareKey=ca31faf73759d96177949f489e139282" alt="TIME_WAIT"></p>
<p>但是这种情况下有可能产生问题，原因是因为可用端口数是有限的，也就是假如可用端口是60000个，那么如果2MSL两分钟，则连接率不能高于 60000 / 120 = 500个/秒。</p>
<p>另外要注意大量打开连接或控制块的情况下，有些操作系统的速度会严重减缓。</p>
<h3 id="从哪些方面来提升HTTP性能？"><a href="#从哪些方面来提升HTTP性能？" class="headerlink" title="从哪些方面来提升HTTP性能？"></a>从哪些方面来提升HTTP性能？</h3><ul>
<li>并行连接</li>
<li>持久连接</li>
<li>管道化连接</li>
<li>复用连接</li>
</ul>
<h3 id="并行连接有什么优点和限制？"><a href="#并行连接有什么优点和限制？" class="headerlink" title="并行连接有什么优点和限制？"></a>并行连接有什么优点和限制？</h3><p><strong>并行连接不一定更快，但会让人“感觉上”更快</strong>，因为如果客户端的网络带宽较小时，大部分的时间其实是用来传输数据的，，如果此时一个连接就足以把带宽占满反倒并行连接会消耗很多内存资源，在效率上也没有什么提升，得不偿失。</p>
<p>一般浏览器把并行连接数限定在较小的值，通常是4个。</p>
<h3 id="持久连接是什么？与并行连接相比有什么好处？"><a href="#持久连接是什么？与并行连接相比有什么好处？" class="headerlink" title="持久连接是什么？与并行连接相比有什么好处？"></a>持久连接是什么？与并行连接相比有什么好处？</h3><p>在HTTP/1.1协议中，支持HTTP设备在事物处理结束之后将TCP保持打开状态，以便之后的复用。</p>
<p>好处是既可以避免缓慢的连接建立，也就是三次握手阶段，还可以避免慢启动的拥塞适应阶段，以便更快速地进行数据传输。</p>
<h3 id="Keep-Alive首部在哑代理中会出现什么问题？"><a href="#Keep-Alive首部在哑代理中会出现什么问题？" class="headerlink" title="Keep-Alive首部在哑代理中会出现什么问题？"></a>Keep-Alive首部在哑代理中会出现什么问题？</h3><p><strong>会出现仅有第一个请求有效，其余请求都被代理忽略，从而导致客户端一直loading而得不到返回结果。</strong></p>
<p>原因如下：</p>
<p><img src="https://note.youdao.com/yws/api/personal/file/WEBcbe56b9b9f29b37c71cd540e81ad8125?method=download&amp;shareKey=b8b0d5fb2b422811f9cb17743b6de858" alt="Keep-Alive"></p>
<p>主要原因就是逐跳首部被哑代理当成了端到端首部进行传输。</p>
<h3 id="什么是端到端首部？什么是逐跳首部？"><a href="#什么是端到端首部？什么是逐跳首部？" class="headerlink" title="什么是端到端首部？什么是逐跳首部？"></a>什么是端到端首部？什么是逐跳首部？</h3><ul>
<li><p>端到端首部（End-to-end Header）分在此类别中的首部会转发给请求/响应对应的最终接受目标，且必须保存在由缓存生成的响应中，另外规定它必须被转发。</p>
</li>
<li><p>逐跳首部（Hop-by-hop Header）分在此类别中的首部只对单次转发有效，会因通过缓存或代理而不再转发。所有的Connection首部都是不能被转发的，例如Connection/Keep-Alive/Proxy-Authenticate/Proxy-Authorization/Trailer/TE/Transfer-Encoding/Upgrade</p>
</li>
</ul>
<h3 id="有什么办法可以解决Keep-Alive在哑代理的问题？"><a href="#有什么办法可以解决Keep-Alive在哑代理的问题？" class="headerlink" title="有什么办法可以解决Keep-Alive在哑代理的问题？"></a>有什么办法可以解决Keep-Alive在哑代理的问题？</h3><p>Netscape通过将Connection:Keep-Alive改成Proxy-Connectoion:Keep-Alive进行传输。由于Proxy-Connectoion:Keep-Alive是自定义的，服务器并不知道是什么意思，如果哑代理传输过去后，服务器当做普通连接进行处理，就不会出现代理收不到接下来的请求的问题了。</p>
<p><img src="https://note.youdao.com/yws/api/personal/file/WEB3eadd942432552d68e7b7f188a514ad9?method=download&amp;shareKey=bfe5f398f69e5eae8c2d59064b94fb7f" alt="哑代理聪明代理解决方式"></p>
<p>但这个方法只能在中间没有出现哑代理和聪明的代理结合的情况下才有效。</p>
<p><img src="https://note.youdao.com/yws/api/personal/file/WEB7c17e8f0d3cb9917d30b5a68cad0125c?method=download&amp;shareKey=7c2c1e2db3ebf9b5c6ac6c775c339644" alt="哑代理聪明代理混合"></p>
<h3 id="持久连接和keep-alive有什么不同？"><a href="#持久连接和keep-alive有什么不同？" class="headerlink" title="持久连接和keep-alive有什么不同？"></a>持久连接和keep-alive有什么不同？</h3><p>keep-alive是HTTP/1.0+加入的首部字段，而持久连接是在HTTP/1.1就默认支持的，如果要在事务结束后关闭，就需要在报文里添加Connection:close首部。</p>
<h3 id="持久连接和管道化连接有什么不同？"><a href="#持久连接和管道化连接有什么不同？" class="headerlink" title="持久连接和管道化连接有什么不同？"></a>持久连接和管道化连接有什么不同？</h3><p>管道连接是在持久连接上，相对于keep-alive的又一个性能优化，在响应到达之前，可以将多条请求加入队列。当第一条请求通过网络流向服务器时，第二条和第三条请求也可以开始发送了。</p>
<p>具体区别：</p>
<p><img src="https://note.youdao.com/yws/api/personal/file/WEBa087747b00a36815c73c788e573cd5ac?method=download&amp;shareKey=d8117a777bea2780f75692d9b314cf78" alt="三种连接的区别"></p>
<h3 id="什么是幂等事物，什么是非幂等事物？"><a href="#什么是幂等事物，什么是非幂等事物？" class="headerlink" title="什么是幂等事物，什么是非幂等事物？"></a>什么是幂等事物，什么是非幂等事物？</h3><p>如果一个事物，不管执行一次还是执行多次，得到的结果都是相同的，那么这个事物就是幂等的。比如：GET、HEAD、PUT、DELETE、TRACE和OPTIONS方法。</p>
<p>反之，非幂等事物的请求（比如POST），这种事物就不应该以管道化的方式传送非幂等请求，要发送一条非幂等请求，就需要等待来自前一条请求的响应状态。</p>
<h3 id="怎么样的连接是正常关闭的？"><a href="#怎么样的连接是正常关闭的？" class="headerlink" title="怎么样的连接是正常关闭的？"></a>怎么样的连接是正常关闭的？</h3><h4 id="完全关闭与半关闭有什么区别？"><a href="#完全关闭与半关闭有什么区别？" class="headerlink" title="完全关闭与半关闭有什么区别？"></a>完全关闭与半关闭有什么区别？</h4><ol>
<li>应用程序关闭TCP输入和输出信道中的任意一个，只有两者都关闭了，socket才会调用close()将TCP连接的输入和输出信道都关闭，此时才是完全关闭。</li>
<li>当socket调用shutdown()时，此时会单独关闭输入/输出信道，被称为“半关闭”。</li>
</ol>
<h4 id="半关闭状态，哪种情况更加危险？"><a href="#半关闭状态，哪种情况更加危险？" class="headerlink" title="半关闭状态，哪种情况更加危险？"></a>半关闭状态，哪种情况更加危险？</h4><p>关闭连接的输出信道是安全的，因为连接另一端的对等实体会从其缓冲区中读取所有数据之后收到一条通知，说明流结束了，这样你就知道将连接关闭了。</p>
<p>而关闭连接的输入信道是危险的，大部分操作系统会对这种情况视为很严重的错误来处理，比如：假设你在一条持久连接发送了10条管道式请求，此时数据还在应用缓冲区存着，此时第11条请求，服务器将连接关闭，而这条请求会发送到已经关闭的连接上去，并且会回送一条重置的信息，之前缓冲数据都会丢失。</p>
<p><img src="https://note.youdao.com/yws/api/personal/file/WEBd2aeddd8bc5679ee1b39df879772498b?method=download&amp;shareKey=3584790325996d4033aa39969b56de73" alt="输入输出信道"></p>
<h4 id="那么正确关闭HTTP请求连接顺序是什么样的？"><a href="#那么正确关闭HTTP请求连接顺序是什么样的？" class="headerlink" title="那么正确关闭HTTP请求连接顺序是什么样的？"></a>那么正确关闭HTTP请求连接顺序是什么样的？</h4><p>正常关闭的应用程序首先应该关闭输出信道，然后等待连接另一端的实体关闭输入信道。</p>

          
        
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
  </section>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/2/"><i class="fa fa-angle-left"></i></a><a class="page-number" href="/">1</a><a class="page-number" href="/page/2/">2</a><span class="page-number current">3</span><a class="page-number" href="/page/4/">4</a><span class="space">&hellip;</span><a class="page-number" href="/page/7/">7</a><a class="extend next" rel="next" href="/page/4/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      

      <section class="site-overview sidebar-panel  sidebar-panel-active ">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="/images/avatar.jpg"
               alt="SkyAcer" />
          <p class="site-author-name" itemprop="name">SkyAcer</p>
          <p class="site-description motion-element" itemprop="description">Little And More.</p>
        </div>
        <nav class="site-state motion-element">
          <div class="site-state-item site-state-posts">
            <a href="/archives">
              <span class="site-state-item-count">35</span>
              <span class="site-state-item-name">日志</span>
            </a>
          </div>
          
          
            <div class="site-state-item site-state-categories">
              
                <span class="site-state-item-count">19</span>
                <span class="site-state-item-name">分类</span>
              
            </div>
          

          
            <div class="site-state-item site-state-tags">
              <a href="/tags">
                <span class="site-state-item-count">21</span>
                <span class="site-state-item-name">标签</span>
              </a>
            </div>
          

        </nav>

        

        <div class="links-of-author motion-element">
          
        </div>

        
        

        <div class="links-of-author motion-element">
          
        </div>

      </section>

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy; 
  <span itemprop="copyrightYear">2018</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">SkyAcer</span>
</div>

<div class="powered-by">
  由 <a class="theme-link" href="http://hexo.io">Hexo</a> 强力驱动
</div>

<div class="theme-info">
  主题 -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Pisces
  </a>
</div>



      </div>
    </footer>

    <div class="back-to-top">
      <i class="fa fa-arrow-up"></i>
    </div>
  </div>

  


  




<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>


  <script type="text/javascript" src="/vendors/jquery/index.js?v=2.1.3"></script>

  <script type="text/javascript" src="/vendors/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  <script type="text/javascript" src="/vendors/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  <script type="text/javascript" src="/vendors/velocity/velocity.min.js"></script>

  <script type="text/javascript" src="/vendors/velocity/velocity.ui.min.js"></script>

  <script type="text/javascript" src="/vendors/fancybox/source/jquery.fancybox.pack.js"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=0.5.0"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=0.5.0"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=0.5.0"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=0.5.0"></script>



  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=0.5.0"></script>



  



  



  
  
  

  


</body>
</html>
